
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model ContentType
 * 
 */
export type ContentType = $Result.DefaultSelection<Prisma.$ContentTypePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ContentCategory
 * 
 */
export type ContentCategory = $Result.DefaultSelection<Prisma.$ContentCategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ContentTag
 * 
 */
export type ContentTag = $Result.DefaultSelection<Prisma.$ContentTagPayload>
/**
 * Model Site
 * 
 */
export type Site = $Result.DefaultSelection<Prisma.$SitePayload>
/**
 * Model SiteContent
 * 
 */
export type SiteContent = $Result.DefaultSelection<Prisma.$SiteContentPayload>
/**
 * Model MediaAsset
 * 
 */
export type MediaAsset = $Result.DefaultSelection<Prisma.$MediaAssetPayload>
/**
 * Model SiteMedia
 * 
 */
export type SiteMedia = $Result.DefaultSelection<Prisma.$SiteMediaPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model SiteProduct
 * 
 */
export type SiteProduct = $Result.DefaultSelection<Prisma.$SiteProductPayload>
/**
 * Model ProductCustomField
 * 
 */
export type ProductCustomField = $Result.DefaultSelection<Prisma.$ProductCustomFieldPayload>
/**
 * Model ProductPriceHistory
 * 
 */
export type ProductPriceHistory = $Result.DefaultSelection<Prisma.$ProductPriceHistoryPayload>
/**
 * Model PriceAlert
 * 
 */
export type PriceAlert = $Result.DefaultSelection<Prisma.$PriceAlertPayload>
/**
 * Model InteractiveQuiz
 * 
 */
export type InteractiveQuiz = $Result.DefaultSelection<Prisma.$InteractiveQuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizQuestionOption
 * 
 */
export type QuizQuestionOption = $Result.DefaultSelection<Prisma.$QuizQuestionOptionPayload>
/**
 * Model QuizResult
 * 
 */
export type QuizResult = $Result.DefaultSelection<Prisma.$QuizResultPayload>
/**
 * Model QuizAnswer
 * 
 */
export type QuizAnswer = $Result.DefaultSelection<Prisma.$QuizAnswerPayload>
/**
 * Model AffiliateLink
 * 
 */
export type AffiliateLink = $Result.DefaultSelection<Prisma.$AffiliateLinkPayload>
/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model LinkClick
 * 
 */
export type LinkClick = $Result.DefaultSelection<Prisma.$LinkClickPayload>
/**
 * Model Conversion
 * 
 */
export type Conversion = $Result.DefaultSelection<Prisma.$ConversionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model NewsletterSubscriber
 * 
 */
export type NewsletterSubscriber = $Result.DefaultSelection<Prisma.$NewsletterSubscriberPayload>
/**
 * Model NewsletterCampaign
 * 
 */
export type NewsletterCampaign = $Result.DefaultSelection<Prisma.$NewsletterCampaignPayload>
/**
 * Model Newsletter
 * 
 */
export type Newsletter = $Result.DefaultSelection<Prisma.$NewsletterPayload>
/**
 * Model SocialMediaAccount
 * 
 */
export type SocialMediaAccount = $Result.DefaultSelection<Prisma.$SocialMediaAccountPayload>
/**
 * Model SocialMediaPost
 * 
 */
export type SocialMediaPost = $Result.DefaultSelection<Prisma.$SocialMediaPostPayload>
/**
 * Model AffiliateProduct
 * 
 */
export type AffiliateProduct = $Result.DefaultSelection<Prisma.$AffiliateProductPayload>
/**
 * Model AffiliateLinkClick
 * 
 */
export type AffiliateLinkClick = $Result.DefaultSelection<Prisma.$AffiliateLinkClickPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeIngredient
 * 
 */
export type RecipeIngredient = $Result.DefaultSelection<Prisma.$RecipeIngredientPayload>
/**
 * Model RecipeInstruction
 * 
 */
export type RecipeInstruction = $Result.DefaultSelection<Prisma.$RecipeInstructionPayload>
/**
 * Model ContentVersion
 * 
 */
export type ContentVersion = $Result.DefaultSelection<Prisma.$ContentVersionPayload>
/**
 * Model RealTimeNotification
 * 
 */
export type RealTimeNotification = $Result.DefaultSelection<Prisma.$RealTimeNotificationPayload>
/**
 * Model AIContentLog
 * 
 */
export type AIContentLog = $Result.DefaultSelection<Prisma.$AIContentLogPayload>
/**
 * Model BulkImport
 * 
 */
export type BulkImport = $Result.DefaultSelection<Prisma.$BulkImportPayload>
/**
 * Model MakeWebhook
 * 
 */
export type MakeWebhook = $Result.DefaultSelection<Prisma.$MakeWebhookPayload>
/**
 * Model CookieConsent
 * 
 */
export type CookieConsent = $Result.DefaultSelection<Prisma.$CookieConsentPayload>
/**
 * Model AdSpace
 * 
 */
export type AdSpace = $Result.DefaultSelection<Prisma.$AdSpacePayload>
/**
 * Model CustomNiche
 * 
 */
export type CustomNiche = $Result.DefaultSelection<Prisma.$CustomNichePayload>
/**
 * Model AutoBlogPost
 * 
 */
export type AutoBlogPost = $Result.DefaultSelection<Prisma.$AutoBlogPostPayload>
/**
 * Model ContentSchedule
 * 
 */
export type ContentSchedule = $Result.DefaultSelection<Prisma.$ContentSchedulePayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Contents
 * const contents = await prisma.content.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Contents
   * const contents = await prisma.content.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentType`: Exposes CRUD operations for the **ContentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentTypes
    * const contentTypes = await prisma.contentType.findMany()
    * ```
    */
  get contentType(): Prisma.ContentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentCategory`: Exposes CRUD operations for the **ContentCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentCategories
    * const contentCategories = await prisma.contentCategory.findMany()
    * ```
    */
  get contentCategory(): Prisma.ContentCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentTag`: Exposes CRUD operations for the **ContentTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentTags
    * const contentTags = await prisma.contentTag.findMany()
    * ```
    */
  get contentTag(): Prisma.ContentTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteContent`: Exposes CRUD operations for the **SiteContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteContents
    * const siteContents = await prisma.siteContent.findMany()
    * ```
    */
  get siteContent(): Prisma.SiteContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaAsset`: Exposes CRUD operations for the **MediaAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAssets
    * const mediaAssets = await prisma.mediaAsset.findMany()
    * ```
    */
  get mediaAsset(): Prisma.MediaAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteMedia`: Exposes CRUD operations for the **SiteMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteMedias
    * const siteMedias = await prisma.siteMedia.findMany()
    * ```
    */
  get siteMedia(): Prisma.SiteMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteProduct`: Exposes CRUD operations for the **SiteProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteProducts
    * const siteProducts = await prisma.siteProduct.findMany()
    * ```
    */
  get siteProduct(): Prisma.SiteProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCustomField`: Exposes CRUD operations for the **ProductCustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCustomFields
    * const productCustomFields = await prisma.productCustomField.findMany()
    * ```
    */
  get productCustomField(): Prisma.ProductCustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productPriceHistory`: Exposes CRUD operations for the **ProductPriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPriceHistories
    * const productPriceHistories = await prisma.productPriceHistory.findMany()
    * ```
    */
  get productPriceHistory(): Prisma.ProductPriceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceAlert`: Exposes CRUD operations for the **PriceAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceAlerts
    * const priceAlerts = await prisma.priceAlert.findMany()
    * ```
    */
  get priceAlert(): Prisma.PriceAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interactiveQuiz`: Exposes CRUD operations for the **InteractiveQuiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteractiveQuizs
    * const interactiveQuizs = await prisma.interactiveQuiz.findMany()
    * ```
    */
  get interactiveQuiz(): Prisma.InteractiveQuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestionOption`: Exposes CRUD operations for the **QuizQuestionOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestionOptions
    * const quizQuestionOptions = await prisma.quizQuestionOption.findMany()
    * ```
    */
  get quizQuestionOption(): Prisma.QuizQuestionOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizResult`: Exposes CRUD operations for the **QuizResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizResults
    * const quizResults = await prisma.quizResult.findMany()
    * ```
    */
  get quizResult(): Prisma.QuizResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAnswer`: Exposes CRUD operations for the **QuizAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAnswers
    * const quizAnswers = await prisma.quizAnswer.findMany()
    * ```
    */
  get quizAnswer(): Prisma.QuizAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliateLink`: Exposes CRUD operations for the **AffiliateLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateLinks
    * const affiliateLinks = await prisma.affiliateLink.findMany()
    * ```
    */
  get affiliateLink(): Prisma.AffiliateLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkClick`: Exposes CRUD operations for the **LinkClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkClicks
    * const linkClicks = await prisma.linkClick.findMany()
    * ```
    */
  get linkClick(): Prisma.LinkClickDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversion`: Exposes CRUD operations for the **Conversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversions
    * const conversions = await prisma.conversion.findMany()
    * ```
    */
  get conversion(): Prisma.ConversionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletterSubscriber`: Exposes CRUD operations for the **NewsletterSubscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterSubscribers
    * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany()
    * ```
    */
  get newsletterSubscriber(): Prisma.NewsletterSubscriberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletterCampaign`: Exposes CRUD operations for the **NewsletterCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterCampaigns
    * const newsletterCampaigns = await prisma.newsletterCampaign.findMany()
    * ```
    */
  get newsletterCampaign(): Prisma.NewsletterCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletter`: Exposes CRUD operations for the **Newsletter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletters
    * const newsletters = await prisma.newsletter.findMany()
    * ```
    */
  get newsletter(): Prisma.NewsletterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialMediaAccount`: Exposes CRUD operations for the **SocialMediaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialMediaAccounts
    * const socialMediaAccounts = await prisma.socialMediaAccount.findMany()
    * ```
    */
  get socialMediaAccount(): Prisma.SocialMediaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialMediaPost`: Exposes CRUD operations for the **SocialMediaPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialMediaPosts
    * const socialMediaPosts = await prisma.socialMediaPost.findMany()
    * ```
    */
  get socialMediaPost(): Prisma.SocialMediaPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliateProduct`: Exposes CRUD operations for the **AffiliateProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateProducts
    * const affiliateProducts = await prisma.affiliateProduct.findMany()
    * ```
    */
  get affiliateProduct(): Prisma.AffiliateProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliateLinkClick`: Exposes CRUD operations for the **AffiliateLinkClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateLinkClicks
    * const affiliateLinkClicks = await prisma.affiliateLinkClick.findMany()
    * ```
    */
  get affiliateLinkClick(): Prisma.AffiliateLinkClickDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeIngredient`: Exposes CRUD operations for the **RecipeIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeIngredients
    * const recipeIngredients = await prisma.recipeIngredient.findMany()
    * ```
    */
  get recipeIngredient(): Prisma.RecipeIngredientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeInstruction`: Exposes CRUD operations for the **RecipeInstruction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeInstructions
    * const recipeInstructions = await prisma.recipeInstruction.findMany()
    * ```
    */
  get recipeInstruction(): Prisma.RecipeInstructionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentVersion`: Exposes CRUD operations for the **ContentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentVersions
    * const contentVersions = await prisma.contentVersion.findMany()
    * ```
    */
  get contentVersion(): Prisma.ContentVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.realTimeNotification`: Exposes CRUD operations for the **RealTimeNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealTimeNotifications
    * const realTimeNotifications = await prisma.realTimeNotification.findMany()
    * ```
    */
  get realTimeNotification(): Prisma.RealTimeNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIContentLog`: Exposes CRUD operations for the **AIContentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIContentLogs
    * const aIContentLogs = await prisma.aIContentLog.findMany()
    * ```
    */
  get aIContentLog(): Prisma.AIContentLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulkImport`: Exposes CRUD operations for the **BulkImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulkImports
    * const bulkImports = await prisma.bulkImport.findMany()
    * ```
    */
  get bulkImport(): Prisma.BulkImportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.makeWebhook`: Exposes CRUD operations for the **MakeWebhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MakeWebhooks
    * const makeWebhooks = await prisma.makeWebhook.findMany()
    * ```
    */
  get makeWebhook(): Prisma.MakeWebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cookieConsent`: Exposes CRUD operations for the **CookieConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CookieConsents
    * const cookieConsents = await prisma.cookieConsent.findMany()
    * ```
    */
  get cookieConsent(): Prisma.CookieConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adSpace`: Exposes CRUD operations for the **AdSpace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdSpaces
    * const adSpaces = await prisma.adSpace.findMany()
    * ```
    */
  get adSpace(): Prisma.AdSpaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customNiche`: Exposes CRUD operations for the **CustomNiche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomNiches
    * const customNiches = await prisma.customNiche.findMany()
    * ```
    */
  get customNiche(): Prisma.CustomNicheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoBlogPost`: Exposes CRUD operations for the **AutoBlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoBlogPosts
    * const autoBlogPosts = await prisma.autoBlogPost.findMany()
    * ```
    */
  get autoBlogPost(): Prisma.AutoBlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentSchedule`: Exposes CRUD operations for the **ContentSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentSchedules
    * const contentSchedules = await prisma.contentSchedule.findMany()
    * ```
    */
  get contentSchedule(): Prisma.ContentScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Content: 'Content',
    ContentType: 'ContentType',
    Category: 'Category',
    ContentCategory: 'ContentCategory',
    Tag: 'Tag',
    ContentTag: 'ContentTag',
    Site: 'Site',
    SiteContent: 'SiteContent',
    MediaAsset: 'MediaAsset',
    SiteMedia: 'SiteMedia',
    Product: 'Product',
    SiteProduct: 'SiteProduct',
    ProductCustomField: 'ProductCustomField',
    ProductPriceHistory: 'ProductPriceHistory',
    PriceAlert: 'PriceAlert',
    InteractiveQuiz: 'InteractiveQuiz',
    QuizQuestion: 'QuizQuestion',
    QuizQuestionOption: 'QuizQuestionOption',
    QuizResult: 'QuizResult',
    QuizAnswer: 'QuizAnswer',
    AffiliateLink: 'AffiliateLink',
    Merchant: 'Merchant',
    LinkClick: 'LinkClick',
    Conversion: 'Conversion',
    Role: 'Role',
    UserRole: 'UserRole',
    AuditLog: 'AuditLog',
    NewsletterSubscriber: 'NewsletterSubscriber',
    NewsletterCampaign: 'NewsletterCampaign',
    Newsletter: 'Newsletter',
    SocialMediaAccount: 'SocialMediaAccount',
    SocialMediaPost: 'SocialMediaPost',
    AffiliateProduct: 'AffiliateProduct',
    AffiliateLinkClick: 'AffiliateLinkClick',
    Recipe: 'Recipe',
    RecipeIngredient: 'RecipeIngredient',
    RecipeInstruction: 'RecipeInstruction',
    ContentVersion: 'ContentVersion',
    RealTimeNotification: 'RealTimeNotification',
    AIContentLog: 'AIContentLog',
    BulkImport: 'BulkImport',
    MakeWebhook: 'MakeWebhook',
    CookieConsent: 'CookieConsent',
    AdSpace: 'AdSpace',
    CustomNiche: 'CustomNiche',
    AutoBlogPost: 'AutoBlogPost',
    ContentSchedule: 'ContentSchedule',
    ProductCategory: 'ProductCategory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "content" | "contentType" | "category" | "contentCategory" | "tag" | "contentTag" | "site" | "siteContent" | "mediaAsset" | "siteMedia" | "product" | "siteProduct" | "productCustomField" | "productPriceHistory" | "priceAlert" | "interactiveQuiz" | "quizQuestion" | "quizQuestionOption" | "quizResult" | "quizAnswer" | "affiliateLink" | "merchant" | "linkClick" | "conversion" | "role" | "userRole" | "auditLog" | "newsletterSubscriber" | "newsletterCampaign" | "newsletter" | "socialMediaAccount" | "socialMediaPost" | "affiliateProduct" | "affiliateLinkClick" | "recipe" | "recipeIngredient" | "recipeInstruction" | "contentVersion" | "realTimeNotification" | "aIContentLog" | "bulkImport" | "makeWebhook" | "cookieConsent" | "adSpace" | "customNiche" | "autoBlogPost" | "contentSchedule" | "productCategory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      ContentType: {
        payload: Prisma.$ContentTypePayload<ExtArgs>
        fields: Prisma.ContentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          findFirst: {
            args: Prisma.ContentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          findMany: {
            args: Prisma.ContentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>[]
          }
          create: {
            args: Prisma.ContentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          createMany: {
            args: Prisma.ContentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>[]
          }
          delete: {
            args: Prisma.ContentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          update: {
            args: Prisma.ContentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          deleteMany: {
            args: Prisma.ContentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>[]
          }
          upsert: {
            args: Prisma.ContentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          aggregate: {
            args: Prisma.ContentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentType>
          }
          groupBy: {
            args: Prisma.ContentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContentTypeCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ContentCategory: {
        payload: Prisma.$ContentCategoryPayload<ExtArgs>
        fields: Prisma.ContentCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          findFirst: {
            args: Prisma.ContentCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          findMany: {
            args: Prisma.ContentCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>[]
          }
          create: {
            args: Prisma.ContentCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          createMany: {
            args: Prisma.ContentCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>[]
          }
          delete: {
            args: Prisma.ContentCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          update: {
            args: Prisma.ContentCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ContentCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ContentCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCategoryPayload>
          }
          aggregate: {
            args: Prisma.ContentCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentCategory>
          }
          groupBy: {
            args: Prisma.ContentCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ContentTag: {
        payload: Prisma.$ContentTagPayload<ExtArgs>
        fields: Prisma.ContentTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          findFirst: {
            args: Prisma.ContentTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          findMany: {
            args: Prisma.ContentTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>[]
          }
          create: {
            args: Prisma.ContentTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          createMany: {
            args: Prisma.ContentTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>[]
          }
          delete: {
            args: Prisma.ContentTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          update: {
            args: Prisma.ContentTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          deleteMany: {
            args: Prisma.ContentTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>[]
          }
          upsert: {
            args: Prisma.ContentTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          aggregate: {
            args: Prisma.ContentTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentTag>
          }
          groupBy: {
            args: Prisma.ContentTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentTagCountArgs<ExtArgs>
            result: $Utils.Optional<ContentTagCountAggregateOutputType> | number
          }
        }
      }
      Site: {
        payload: Prisma.$SitePayload<ExtArgs>
        fields: Prisma.SiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findFirst: {
            args: Prisma.SiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findMany: {
            args: Prisma.SiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          create: {
            args: Prisma.SiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          createMany: {
            args: Prisma.SiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          delete: {
            args: Prisma.SiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          update: {
            args: Prisma.SiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          deleteMany: {
            args: Prisma.SiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          upsert: {
            args: Prisma.SiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          aggregate: {
            args: Prisma.SiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite>
          }
          groupBy: {
            args: Prisma.SiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCountAggregateOutputType> | number
          }
        }
      }
      SiteContent: {
        payload: Prisma.$SiteContentPayload<ExtArgs>
        fields: Prisma.SiteContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          findFirst: {
            args: Prisma.SiteContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          findMany: {
            args: Prisma.SiteContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>[]
          }
          create: {
            args: Prisma.SiteContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          createMany: {
            args: Prisma.SiteContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>[]
          }
          delete: {
            args: Prisma.SiteContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          update: {
            args: Prisma.SiteContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          deleteMany: {
            args: Prisma.SiteContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>[]
          }
          upsert: {
            args: Prisma.SiteContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteContentPayload>
          }
          aggregate: {
            args: Prisma.SiteContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteContent>
          }
          groupBy: {
            args: Prisma.SiteContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteContentCountArgs<ExtArgs>
            result: $Utils.Optional<SiteContentCountAggregateOutputType> | number
          }
        }
      }
      MediaAsset: {
        payload: Prisma.$MediaAssetPayload<ExtArgs>
        fields: Prisma.MediaAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findFirst: {
            args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findMany: {
            args: Prisma.MediaAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          create: {
            args: Prisma.MediaAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          createMany: {
            args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          delete: {
            args: Prisma.MediaAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          update: {
            args: Prisma.MediaAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          deleteMany: {
            args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          upsert: {
            args: Prisma.MediaAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          aggregate: {
            args: Prisma.MediaAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAsset>
          }
          groupBy: {
            args: Prisma.MediaAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAssetCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetCountAggregateOutputType> | number
          }
        }
      }
      SiteMedia: {
        payload: Prisma.$SiteMediaPayload<ExtArgs>
        fields: Prisma.SiteMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          findFirst: {
            args: Prisma.SiteMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          findMany: {
            args: Prisma.SiteMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>[]
          }
          create: {
            args: Prisma.SiteMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          createMany: {
            args: Prisma.SiteMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>[]
          }
          delete: {
            args: Prisma.SiteMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          update: {
            args: Prisma.SiteMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          deleteMany: {
            args: Prisma.SiteMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>[]
          }
          upsert: {
            args: Prisma.SiteMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteMediaPayload>
          }
          aggregate: {
            args: Prisma.SiteMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteMedia>
          }
          groupBy: {
            args: Prisma.SiteMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteMediaCountArgs<ExtArgs>
            result: $Utils.Optional<SiteMediaCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      SiteProduct: {
        payload: Prisma.$SiteProductPayload<ExtArgs>
        fields: Prisma.SiteProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          findFirst: {
            args: Prisma.SiteProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          findMany: {
            args: Prisma.SiteProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>[]
          }
          create: {
            args: Prisma.SiteProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          createMany: {
            args: Prisma.SiteProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>[]
          }
          delete: {
            args: Prisma.SiteProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          update: {
            args: Prisma.SiteProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          deleteMany: {
            args: Prisma.SiteProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>[]
          }
          upsert: {
            args: Prisma.SiteProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteProductPayload>
          }
          aggregate: {
            args: Prisma.SiteProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteProduct>
          }
          groupBy: {
            args: Prisma.SiteProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteProductCountArgs<ExtArgs>
            result: $Utils.Optional<SiteProductCountAggregateOutputType> | number
          }
        }
      }
      ProductCustomField: {
        payload: Prisma.$ProductCustomFieldPayload<ExtArgs>
        fields: Prisma.ProductCustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          findFirst: {
            args: Prisma.ProductCustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          findMany: {
            args: Prisma.ProductCustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>[]
          }
          create: {
            args: Prisma.ProductCustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          createMany: {
            args: Prisma.ProductCustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>[]
          }
          delete: {
            args: Prisma.ProductCustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          update: {
            args: Prisma.ProductCustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.ProductCustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCustomFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>[]
          }
          upsert: {
            args: Prisma.ProductCustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomFieldPayload>
          }
          aggregate: {
            args: Prisma.ProductCustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCustomField>
          }
          groupBy: {
            args: Prisma.ProductCustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCustomFieldCountAggregateOutputType> | number
          }
        }
      }
      ProductPriceHistory: {
        payload: Prisma.$ProductPriceHistoryPayload<ExtArgs>
        fields: Prisma.ProductPriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.ProductPriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          findMany: {
            args: Prisma.ProductPriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>[]
          }
          create: {
            args: Prisma.ProductPriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          createMany: {
            args: Prisma.ProductPriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.ProductPriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          update: {
            args: Prisma.ProductPriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductPriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductPriceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductPriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.ProductPriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPriceHistory>
          }
          groupBy: {
            args: Prisma.ProductPriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      PriceAlert: {
        payload: Prisma.$PriceAlertPayload<ExtArgs>
        fields: Prisma.PriceAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          findFirst: {
            args: Prisma.PriceAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          findMany: {
            args: Prisma.PriceAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          create: {
            args: Prisma.PriceAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          createMany: {
            args: Prisma.PriceAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          delete: {
            args: Prisma.PriceAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          update: {
            args: Prisma.PriceAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          deleteMany: {
            args: Prisma.PriceAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          upsert: {
            args: Prisma.PriceAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          aggregate: {
            args: Prisma.PriceAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceAlert>
          }
          groupBy: {
            args: Prisma.PriceAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceAlertCountArgs<ExtArgs>
            result: $Utils.Optional<PriceAlertCountAggregateOutputType> | number
          }
        }
      }
      InteractiveQuiz: {
        payload: Prisma.$InteractiveQuizPayload<ExtArgs>
        fields: Prisma.InteractiveQuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractiveQuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractiveQuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          findFirst: {
            args: Prisma.InteractiveQuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractiveQuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          findMany: {
            args: Prisma.InteractiveQuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>[]
          }
          create: {
            args: Prisma.InteractiveQuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          createMany: {
            args: Prisma.InteractiveQuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractiveQuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>[]
          }
          delete: {
            args: Prisma.InteractiveQuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          update: {
            args: Prisma.InteractiveQuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          deleteMany: {
            args: Prisma.InteractiveQuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractiveQuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractiveQuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>[]
          }
          upsert: {
            args: Prisma.InteractiveQuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractiveQuizPayload>
          }
          aggregate: {
            args: Prisma.InteractiveQuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteractiveQuiz>
          }
          groupBy: {
            args: Prisma.InteractiveQuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractiveQuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractiveQuizCountArgs<ExtArgs>
            result: $Utils.Optional<InteractiveQuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestionOption: {
        payload: Prisma.$QuizQuestionOptionPayload<ExtArgs>
        fields: Prisma.QuizQuestionOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          update: {
            args: Prisma.QuizQuestionOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionOptionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestionOption>
          }
          groupBy: {
            args: Prisma.QuizQuestionOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionOptionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionOptionCountAggregateOutputType> | number
          }
        }
      }
      QuizResult: {
        payload: Prisma.$QuizResultPayload<ExtArgs>
        fields: Prisma.QuizResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          findFirst: {
            args: Prisma.QuizResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          findMany: {
            args: Prisma.QuizResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          create: {
            args: Prisma.QuizResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          createMany: {
            args: Prisma.QuizResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          delete: {
            args: Prisma.QuizResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          update: {
            args: Prisma.QuizResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          deleteMany: {
            args: Prisma.QuizResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          upsert: {
            args: Prisma.QuizResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          aggregate: {
            args: Prisma.QuizResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizResult>
          }
          groupBy: {
            args: Prisma.QuizResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizResultCountArgs<ExtArgs>
            result: $Utils.Optional<QuizResultCountAggregateOutputType> | number
          }
        }
      }
      QuizAnswer: {
        payload: Prisma.$QuizAnswerPayload<ExtArgs>
        fields: Prisma.QuizAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuizAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findMany: {
            args: Prisma.QuizAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          create: {
            args: Prisma.QuizAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          createMany: {
            args: Prisma.QuizAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuizAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          update: {
            args: Prisma.QuizAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuizAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuizAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuizAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAnswer>
          }
          groupBy: {
            args: Prisma.QuizAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerCountAggregateOutputType> | number
          }
        }
      }
      AffiliateLink: {
        payload: Prisma.$AffiliateLinkPayload<ExtArgs>
        fields: Prisma.AffiliateLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          findFirst: {
            args: Prisma.AffiliateLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          findMany: {
            args: Prisma.AffiliateLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>[]
          }
          create: {
            args: Prisma.AffiliateLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          createMany: {
            args: Prisma.AffiliateLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>[]
          }
          delete: {
            args: Prisma.AffiliateLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          update: {
            args: Prisma.AffiliateLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AffiliateLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>[]
          }
          upsert: {
            args: Prisma.AffiliateLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          aggregate: {
            args: Prisma.AffiliateLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateLink>
          }
          groupBy: {
            args: Prisma.AffiliateLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateLinkCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkCountAggregateOutputType> | number
          }
        }
      }
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      LinkClick: {
        payload: Prisma.$LinkClickPayload<ExtArgs>
        fields: Prisma.LinkClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkClickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkClickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          findFirst: {
            args: Prisma.LinkClickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkClickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          findMany: {
            args: Prisma.LinkClickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>[]
          }
          create: {
            args: Prisma.LinkClickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          createMany: {
            args: Prisma.LinkClickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkClickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>[]
          }
          delete: {
            args: Prisma.LinkClickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          update: {
            args: Prisma.LinkClickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          deleteMany: {
            args: Prisma.LinkClickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkClickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkClickUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>[]
          }
          upsert: {
            args: Prisma.LinkClickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkClickPayload>
          }
          aggregate: {
            args: Prisma.LinkClickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkClick>
          }
          groupBy: {
            args: Prisma.LinkClickGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkClickCountArgs<ExtArgs>
            result: $Utils.Optional<LinkClickCountAggregateOutputType> | number
          }
        }
      }
      Conversion: {
        payload: Prisma.$ConversionPayload<ExtArgs>
        fields: Prisma.ConversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findFirst: {
            args: Prisma.ConversionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findMany: {
            args: Prisma.ConversionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          create: {
            args: Prisma.ConversionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          createMany: {
            args: Prisma.ConversionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          delete: {
            args: Prisma.ConversionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          update: {
            args: Prisma.ConversionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          deleteMany: {
            args: Prisma.ConversionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          upsert: {
            args: Prisma.ConversionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          aggregate: {
            args: Prisma.ConversionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversion>
          }
          groupBy: {
            args: Prisma.ConversionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversionCountArgs<ExtArgs>
            result: $Utils.Optional<ConversionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      NewsletterSubscriber: {
        payload: Prisma.$NewsletterSubscriberPayload<ExtArgs>
        fields: Prisma.NewsletterSubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterSubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          findFirst: {
            args: Prisma.NewsletterSubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          findMany: {
            args: Prisma.NewsletterSubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
          }
          create: {
            args: Prisma.NewsletterSubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          createMany: {
            args: Prisma.NewsletterSubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
          }
          delete: {
            args: Prisma.NewsletterSubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          update: {
            args: Prisma.NewsletterSubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterSubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterSubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsletterSubscriberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
          }
          upsert: {
            args: Prisma.NewsletterSubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          aggregate: {
            args: Prisma.NewsletterSubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterSubscriber>
          }
          groupBy: {
            args: Prisma.NewsletterSubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterSubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriberCountAggregateOutputType> | number
          }
        }
      }
      NewsletterCampaign: {
        payload: Prisma.$NewsletterCampaignPayload<ExtArgs>
        fields: Prisma.NewsletterCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          findFirst: {
            args: Prisma.NewsletterCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          findMany: {
            args: Prisma.NewsletterCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>[]
          }
          create: {
            args: Prisma.NewsletterCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          createMany: {
            args: Prisma.NewsletterCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>[]
          }
          delete: {
            args: Prisma.NewsletterCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          update: {
            args: Prisma.NewsletterCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsletterCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>[]
          }
          upsert: {
            args: Prisma.NewsletterCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterCampaignPayload>
          }
          aggregate: {
            args: Prisma.NewsletterCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterCampaign>
          }
          groupBy: {
            args: Prisma.NewsletterCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCampaignCountAggregateOutputType> | number
          }
        }
      }
      Newsletter: {
        payload: Prisma.$NewsletterPayload<ExtArgs>
        fields: Prisma.NewsletterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          findFirst: {
            args: Prisma.NewsletterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          findMany: {
            args: Prisma.NewsletterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
          }
          create: {
            args: Prisma.NewsletterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          createMany: {
            args: Prisma.NewsletterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
          }
          delete: {
            args: Prisma.NewsletterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          update: {
            args: Prisma.NewsletterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsletterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
          }
          upsert: {
            args: Prisma.NewsletterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          aggregate: {
            args: Prisma.NewsletterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter>
          }
          groupBy: {
            args: Prisma.NewsletterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCountAggregateOutputType> | number
          }
        }
      }
      SocialMediaAccount: {
        payload: Prisma.$SocialMediaAccountPayload<ExtArgs>
        fields: Prisma.SocialMediaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialMediaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          findFirst: {
            args: Prisma.SocialMediaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialMediaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          findMany: {
            args: Prisma.SocialMediaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          create: {
            args: Prisma.SocialMediaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          createMany: {
            args: Prisma.SocialMediaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialMediaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          delete: {
            args: Prisma.SocialMediaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          update: {
            args: Prisma.SocialMediaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          deleteMany: {
            args: Prisma.SocialMediaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialMediaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          upsert: {
            args: Prisma.SocialMediaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          aggregate: {
            args: Prisma.SocialMediaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialMediaAccount>
          }
          groupBy: {
            args: Prisma.SocialMediaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialMediaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaAccountCountAggregateOutputType> | number
          }
        }
      }
      SocialMediaPost: {
        payload: Prisma.$SocialMediaPostPayload<ExtArgs>
        fields: Prisma.SocialMediaPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialMediaPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialMediaPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          findFirst: {
            args: Prisma.SocialMediaPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialMediaPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          findMany: {
            args: Prisma.SocialMediaPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>[]
          }
          create: {
            args: Prisma.SocialMediaPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          createMany: {
            args: Prisma.SocialMediaPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialMediaPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>[]
          }
          delete: {
            args: Prisma.SocialMediaPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          update: {
            args: Prisma.SocialMediaPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          deleteMany: {
            args: Prisma.SocialMediaPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialMediaPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialMediaPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>[]
          }
          upsert: {
            args: Prisma.SocialMediaPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPostPayload>
          }
          aggregate: {
            args: Prisma.SocialMediaPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialMediaPost>
          }
          groupBy: {
            args: Prisma.SocialMediaPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialMediaPostCountArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaPostCountAggregateOutputType> | number
          }
        }
      }
      AffiliateProduct: {
        payload: Prisma.$AffiliateProductPayload<ExtArgs>
        fields: Prisma.AffiliateProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          findFirst: {
            args: Prisma.AffiliateProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          findMany: {
            args: Prisma.AffiliateProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>[]
          }
          create: {
            args: Prisma.AffiliateProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          createMany: {
            args: Prisma.AffiliateProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>[]
          }
          delete: {
            args: Prisma.AffiliateProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          update: {
            args: Prisma.AffiliateProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AffiliateProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>[]
          }
          upsert: {
            args: Prisma.AffiliateProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductPayload>
          }
          aggregate: {
            args: Prisma.AffiliateProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateProduct>
          }
          groupBy: {
            args: Prisma.AffiliateProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateProductCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProductCountAggregateOutputType> | number
          }
        }
      }
      AffiliateLinkClick: {
        payload: Prisma.$AffiliateLinkClickPayload<ExtArgs>
        fields: Prisma.AffiliateLinkClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateLinkClickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateLinkClickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          findFirst: {
            args: Prisma.AffiliateLinkClickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateLinkClickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          findMany: {
            args: Prisma.AffiliateLinkClickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>[]
          }
          create: {
            args: Prisma.AffiliateLinkClickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          createMany: {
            args: Prisma.AffiliateLinkClickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateLinkClickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>[]
          }
          delete: {
            args: Prisma.AffiliateLinkClickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          update: {
            args: Prisma.AffiliateLinkClickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateLinkClickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateLinkClickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AffiliateLinkClickUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>[]
          }
          upsert: {
            args: Prisma.AffiliateLinkClickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkClickPayload>
          }
          aggregate: {
            args: Prisma.AffiliateLinkClickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateLinkClick>
          }
          groupBy: {
            args: Prisma.AffiliateLinkClickGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateLinkClickCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkClickCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeIngredient: {
        payload: Prisma.$RecipeIngredientPayload<ExtArgs>
        fields: Prisma.RecipeIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findFirst: {
            args: Prisma.RecipeIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findMany: {
            args: Prisma.RecipeIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          create: {
            args: Prisma.RecipeIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          createMany: {
            args: Prisma.RecipeIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          delete: {
            args: Prisma.RecipeIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          update: {
            args: Prisma.RecipeIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          deleteMany: {
            args: Prisma.RecipeIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          upsert: {
            args: Prisma.RecipeIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          aggregate: {
            args: Prisma.RecipeIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeIngredient>
          }
          groupBy: {
            args: Prisma.RecipeIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientCountAggregateOutputType> | number
          }
        }
      }
      RecipeInstruction: {
        payload: Prisma.$RecipeInstructionPayload<ExtArgs>
        fields: Prisma.RecipeInstructionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeInstructionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeInstructionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          findFirst: {
            args: Prisma.RecipeInstructionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeInstructionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          findMany: {
            args: Prisma.RecipeInstructionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          create: {
            args: Prisma.RecipeInstructionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          createMany: {
            args: Prisma.RecipeInstructionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeInstructionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          delete: {
            args: Prisma.RecipeInstructionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          update: {
            args: Prisma.RecipeInstructionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          deleteMany: {
            args: Prisma.RecipeInstructionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeInstructionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeInstructionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          upsert: {
            args: Prisma.RecipeInstructionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          aggregate: {
            args: Prisma.RecipeInstructionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeInstruction>
          }
          groupBy: {
            args: Prisma.RecipeInstructionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeInstructionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeInstructionCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeInstructionCountAggregateOutputType> | number
          }
        }
      }
      ContentVersion: {
        payload: Prisma.$ContentVersionPayload<ExtArgs>
        fields: Prisma.ContentVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          findFirst: {
            args: Prisma.ContentVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          findMany: {
            args: Prisma.ContentVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          create: {
            args: Prisma.ContentVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          createMany: {
            args: Prisma.ContentVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          delete: {
            args: Prisma.ContentVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          update: {
            args: Prisma.ContentVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          deleteMany: {
            args: Prisma.ContentVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>[]
          }
          upsert: {
            args: Prisma.ContentVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentVersionPayload>
          }
          aggregate: {
            args: Prisma.ContentVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentVersion>
          }
          groupBy: {
            args: Prisma.ContentVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ContentVersionCountAggregateOutputType> | number
          }
        }
      }
      RealTimeNotification: {
        payload: Prisma.$RealTimeNotificationPayload<ExtArgs>
        fields: Prisma.RealTimeNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealTimeNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealTimeNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          findFirst: {
            args: Prisma.RealTimeNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealTimeNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          findMany: {
            args: Prisma.RealTimeNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>[]
          }
          create: {
            args: Prisma.RealTimeNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          createMany: {
            args: Prisma.RealTimeNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RealTimeNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>[]
          }
          delete: {
            args: Prisma.RealTimeNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          update: {
            args: Prisma.RealTimeNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          deleteMany: {
            args: Prisma.RealTimeNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RealTimeNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RealTimeNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>[]
          }
          upsert: {
            args: Prisma.RealTimeNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeNotificationPayload>
          }
          aggregate: {
            args: Prisma.RealTimeNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRealTimeNotification>
          }
          groupBy: {
            args: Prisma.RealTimeNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RealTimeNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealTimeNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<RealTimeNotificationCountAggregateOutputType> | number
          }
        }
      }
      AIContentLog: {
        payload: Prisma.$AIContentLogPayload<ExtArgs>
        fields: Prisma.AIContentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIContentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIContentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          findFirst: {
            args: Prisma.AIContentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIContentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          findMany: {
            args: Prisma.AIContentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>[]
          }
          create: {
            args: Prisma.AIContentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          createMany: {
            args: Prisma.AIContentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIContentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>[]
          }
          delete: {
            args: Prisma.AIContentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          update: {
            args: Prisma.AIContentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          deleteMany: {
            args: Prisma.AIContentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIContentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIContentLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>[]
          }
          upsert: {
            args: Prisma.AIContentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIContentLogPayload>
          }
          aggregate: {
            args: Prisma.AIContentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIContentLog>
          }
          groupBy: {
            args: Prisma.AIContentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIContentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIContentLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIContentLogCountAggregateOutputType> | number
          }
        }
      }
      BulkImport: {
        payload: Prisma.$BulkImportPayload<ExtArgs>
        fields: Prisma.BulkImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulkImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulkImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          findFirst: {
            args: Prisma.BulkImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulkImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          findMany: {
            args: Prisma.BulkImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>[]
          }
          create: {
            args: Prisma.BulkImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          createMany: {
            args: Prisma.BulkImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulkImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>[]
          }
          delete: {
            args: Prisma.BulkImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          update: {
            args: Prisma.BulkImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          deleteMany: {
            args: Prisma.BulkImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulkImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BulkImportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>[]
          }
          upsert: {
            args: Prisma.BulkImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportPayload>
          }
          aggregate: {
            args: Prisma.BulkImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulkImport>
          }
          groupBy: {
            args: Prisma.BulkImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulkImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulkImportCountArgs<ExtArgs>
            result: $Utils.Optional<BulkImportCountAggregateOutputType> | number
          }
        }
      }
      MakeWebhook: {
        payload: Prisma.$MakeWebhookPayload<ExtArgs>
        fields: Prisma.MakeWebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MakeWebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MakeWebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          findFirst: {
            args: Prisma.MakeWebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MakeWebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          findMany: {
            args: Prisma.MakeWebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>[]
          }
          create: {
            args: Prisma.MakeWebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          createMany: {
            args: Prisma.MakeWebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MakeWebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>[]
          }
          delete: {
            args: Prisma.MakeWebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          update: {
            args: Prisma.MakeWebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          deleteMany: {
            args: Prisma.MakeWebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MakeWebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MakeWebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>[]
          }
          upsert: {
            args: Prisma.MakeWebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MakeWebhookPayload>
          }
          aggregate: {
            args: Prisma.MakeWebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMakeWebhook>
          }
          groupBy: {
            args: Prisma.MakeWebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<MakeWebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.MakeWebhookCountArgs<ExtArgs>
            result: $Utils.Optional<MakeWebhookCountAggregateOutputType> | number
          }
        }
      }
      CookieConsent: {
        payload: Prisma.$CookieConsentPayload<ExtArgs>
        fields: Prisma.CookieConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CookieConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CookieConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          findFirst: {
            args: Prisma.CookieConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CookieConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          findMany: {
            args: Prisma.CookieConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>[]
          }
          create: {
            args: Prisma.CookieConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          createMany: {
            args: Prisma.CookieConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CookieConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>[]
          }
          delete: {
            args: Prisma.CookieConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          update: {
            args: Prisma.CookieConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          deleteMany: {
            args: Prisma.CookieConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CookieConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CookieConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>[]
          }
          upsert: {
            args: Prisma.CookieConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CookieConsentPayload>
          }
          aggregate: {
            args: Prisma.CookieConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCookieConsent>
          }
          groupBy: {
            args: Prisma.CookieConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CookieConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CookieConsentCountArgs<ExtArgs>
            result: $Utils.Optional<CookieConsentCountAggregateOutputType> | number
          }
        }
      }
      AdSpace: {
        payload: Prisma.$AdSpacePayload<ExtArgs>
        fields: Prisma.AdSpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdSpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdSpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          findFirst: {
            args: Prisma.AdSpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdSpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          findMany: {
            args: Prisma.AdSpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>[]
          }
          create: {
            args: Prisma.AdSpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          createMany: {
            args: Prisma.AdSpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdSpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>[]
          }
          delete: {
            args: Prisma.AdSpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          update: {
            args: Prisma.AdSpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          deleteMany: {
            args: Prisma.AdSpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdSpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdSpaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>[]
          }
          upsert: {
            args: Prisma.AdSpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSpacePayload>
          }
          aggregate: {
            args: Prisma.AdSpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdSpace>
          }
          groupBy: {
            args: Prisma.AdSpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdSpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdSpaceCountArgs<ExtArgs>
            result: $Utils.Optional<AdSpaceCountAggregateOutputType> | number
          }
        }
      }
      CustomNiche: {
        payload: Prisma.$CustomNichePayload<ExtArgs>
        fields: Prisma.CustomNicheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomNicheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomNicheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          findFirst: {
            args: Prisma.CustomNicheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomNicheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          findMany: {
            args: Prisma.CustomNicheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>[]
          }
          create: {
            args: Prisma.CustomNicheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          createMany: {
            args: Prisma.CustomNicheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomNicheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>[]
          }
          delete: {
            args: Prisma.CustomNicheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          update: {
            args: Prisma.CustomNicheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          deleteMany: {
            args: Prisma.CustomNicheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomNicheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomNicheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>[]
          }
          upsert: {
            args: Prisma.CustomNicheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomNichePayload>
          }
          aggregate: {
            args: Prisma.CustomNicheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomNiche>
          }
          groupBy: {
            args: Prisma.CustomNicheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomNicheGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomNicheCountArgs<ExtArgs>
            result: $Utils.Optional<CustomNicheCountAggregateOutputType> | number
          }
        }
      }
      AutoBlogPost: {
        payload: Prisma.$AutoBlogPostPayload<ExtArgs>
        fields: Prisma.AutoBlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoBlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoBlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          findFirst: {
            args: Prisma.AutoBlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoBlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          findMany: {
            args: Prisma.AutoBlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>[]
          }
          create: {
            args: Prisma.AutoBlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          createMany: {
            args: Prisma.AutoBlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoBlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>[]
          }
          delete: {
            args: Prisma.AutoBlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          update: {
            args: Prisma.AutoBlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          deleteMany: {
            args: Prisma.AutoBlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoBlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutoBlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>[]
          }
          upsert: {
            args: Prisma.AutoBlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoBlogPostPayload>
          }
          aggregate: {
            args: Prisma.AutoBlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoBlogPost>
          }
          groupBy: {
            args: Prisma.AutoBlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoBlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoBlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<AutoBlogPostCountAggregateOutputType> | number
          }
        }
      }
      ContentSchedule: {
        payload: Prisma.$ContentSchedulePayload<ExtArgs>
        fields: Prisma.ContentScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          findFirst: {
            args: Prisma.ContentScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          findMany: {
            args: Prisma.ContentScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>[]
          }
          create: {
            args: Prisma.ContentScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          createMany: {
            args: Prisma.ContentScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>[]
          }
          delete: {
            args: Prisma.ContentScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          update: {
            args: Prisma.ContentScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ContentScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>[]
          }
          upsert: {
            args: Prisma.ContentScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSchedulePayload>
          }
          aggregate: {
            args: Prisma.ContentScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentSchedule>
          }
          groupBy: {
            args: Prisma.ContentScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ContentScheduleCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    content?: ContentOmit
    contentType?: ContentTypeOmit
    category?: CategoryOmit
    contentCategory?: ContentCategoryOmit
    tag?: TagOmit
    contentTag?: ContentTagOmit
    site?: SiteOmit
    siteContent?: SiteContentOmit
    mediaAsset?: MediaAssetOmit
    siteMedia?: SiteMediaOmit
    product?: ProductOmit
    siteProduct?: SiteProductOmit
    productCustomField?: ProductCustomFieldOmit
    productPriceHistory?: ProductPriceHistoryOmit
    priceAlert?: PriceAlertOmit
    interactiveQuiz?: InteractiveQuizOmit
    quizQuestion?: QuizQuestionOmit
    quizQuestionOption?: QuizQuestionOptionOmit
    quizResult?: QuizResultOmit
    quizAnswer?: QuizAnswerOmit
    affiliateLink?: AffiliateLinkOmit
    merchant?: MerchantOmit
    linkClick?: LinkClickOmit
    conversion?: ConversionOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    auditLog?: AuditLogOmit
    newsletterSubscriber?: NewsletterSubscriberOmit
    newsletterCampaign?: NewsletterCampaignOmit
    newsletter?: NewsletterOmit
    socialMediaAccount?: SocialMediaAccountOmit
    socialMediaPost?: SocialMediaPostOmit
    affiliateProduct?: AffiliateProductOmit
    affiliateLinkClick?: AffiliateLinkClickOmit
    recipe?: RecipeOmit
    recipeIngredient?: RecipeIngredientOmit
    recipeInstruction?: RecipeInstructionOmit
    contentVersion?: ContentVersionOmit
    realTimeNotification?: RealTimeNotificationOmit
    aIContentLog?: AIContentLogOmit
    bulkImport?: BulkImportOmit
    makeWebhook?: MakeWebhookOmit
    cookieConsent?: CookieConsentOmit
    adSpace?: AdSpaceOmit
    customNiche?: CustomNicheOmit
    autoBlogPost?: AutoBlogPostOmit
    contentSchedule?: ContentScheduleOmit
    productCategory?: ProductCategoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    categories: number
    tags: number
    versions: number
    siteContent: number
    media: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ContentCountOutputTypeCountCategoriesArgs
    tags?: boolean | ContentCountOutputTypeCountTagsArgs
    versions?: boolean | ContentCountOutputTypeCountVersionsArgs
    siteContent?: boolean | ContentCountOutputTypeCountSiteContentArgs
    media?: boolean | ContentCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCategoryWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentVersionWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountSiteContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteContentWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteMediaWhereInput
  }


  /**
   * Count Type ContentTypeCountOutputType
   */

  export type ContentTypeCountOutputType = {
    content: number
  }

  export type ContentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentTypeCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * ContentTypeCountOutputType without action
   */
  export type ContentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTypeCountOutputType
     */
    select?: ContentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentTypeCountOutputType without action
   */
  export type ContentTypeCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    content: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    content?: boolean | CategoryCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    content: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | TagCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
  }


  /**
   * Count Type SiteCountOutputType
   */

  export type SiteCountOutputType = {
    affiliateLinks: number
    autoBlogPosts: number
    contentSchedules: number
    quizzes: number
    priceAlerts: number
    productCategories: number
    customFields: number
    content: number
    media: number
    products: number
  }

  export type SiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | SiteCountOutputTypeCountAffiliateLinksArgs
    autoBlogPosts?: boolean | SiteCountOutputTypeCountAutoBlogPostsArgs
    contentSchedules?: boolean | SiteCountOutputTypeCountContentSchedulesArgs
    quizzes?: boolean | SiteCountOutputTypeCountQuizzesArgs
    priceAlerts?: boolean | SiteCountOutputTypeCountPriceAlertsArgs
    productCategories?: boolean | SiteCountOutputTypeCountProductCategoriesArgs
    customFields?: boolean | SiteCountOutputTypeCountCustomFieldsArgs
    content?: boolean | SiteCountOutputTypeCountContentArgs
    media?: boolean | SiteCountOutputTypeCountMediaArgs
    products?: boolean | SiteCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCountOutputType
     */
    select?: SiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountAffiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountAutoBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoBlogPostWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountContentSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentScheduleWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractiveQuizWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountPriceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceAlertWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCustomFieldWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteContentWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteMediaWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteProductWhereInput
  }


  /**
   * Count Type MediaAssetCountOutputType
   */

  export type MediaAssetCountOutputType = {
    siteMedia: number
  }

  export type MediaAssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteMedia?: boolean | MediaAssetCountOutputTypeCountSiteMediaArgs
  }

  // Custom InputTypes
  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAssetCountOutputType
     */
    select?: MediaAssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeCountSiteMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteMediaWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    affiliateLinks: number
    customFields: number
    priceHistory: number
    siteProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | ProductCountOutputTypeCountAffiliateLinksArgs
    customFields?: boolean | ProductCountOutputTypeCountCustomFieldsArgs
    priceHistory?: boolean | ProductCountOutputTypeCountPriceHistoryArgs
    siteProducts?: boolean | ProductCountOutputTypeCountSiteProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAffiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCustomFieldWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPriceHistoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSiteProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteProductWhereInput
  }


  /**
   * Count Type InteractiveQuizCountOutputType
   */

  export type InteractiveQuizCountOutputType = {
    questions: number
    results: number
  }

  export type InteractiveQuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | InteractiveQuizCountOutputTypeCountQuestionsArgs
    results?: boolean | InteractiveQuizCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * InteractiveQuizCountOutputType without action
   */
  export type InteractiveQuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuizCountOutputType
     */
    select?: InteractiveQuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InteractiveQuizCountOutputType without action
   */
  export type InteractiveQuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * InteractiveQuizCountOutputType without action
   */
  export type InteractiveQuizCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResultWhereInput
  }


  /**
   * Count Type QuizQuestionCountOutputType
   */

  export type QuizQuestionCountOutputType = {
    answers: number
    options: number
  }

  export type QuizQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizQuestionCountOutputTypeCountAnswersArgs
    options?: boolean | QuizQuestionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionOptionWhereInput
  }


  /**
   * Count Type QuizResultCountOutputType
   */

  export type QuizResultCountOutputType = {
    quizAnswers: number
  }

  export type QuizResultCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAnswers?: boolean | QuizResultCountOutputTypeCountQuizAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizResultCountOutputType without action
   */
  export type QuizResultCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResultCountOutputType
     */
    select?: QuizResultCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizResultCountOutputType without action
   */
  export type QuizResultCountOutputTypeCountQuizAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }


  /**
   * Count Type AffiliateLinkCountOutputType
   */

  export type AffiliateLinkCountOutputType = {
    conversions: number
    linkClicks: number
  }

  export type AffiliateLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversions?: boolean | AffiliateLinkCountOutputTypeCountConversionsArgs
    linkClicks?: boolean | AffiliateLinkCountOutputTypeCountLinkClicksArgs
  }

  // Custom InputTypes
  /**
   * AffiliateLinkCountOutputType without action
   */
  export type AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkCountOutputType
     */
    select?: AffiliateLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateLinkCountOutputType without action
   */
  export type AffiliateLinkCountOutputTypeCountConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
  }

  /**
   * AffiliateLinkCountOutputType without action
   */
  export type AffiliateLinkCountOutputTypeCountLinkClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkClickWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    affiliateLinks: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | MerchantCountOutputTypeCountAffiliateLinksArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountAffiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    ingredients: number
    instructions: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | RecipeCountOutputTypeCountIngredientsArgs
    instructions?: boolean | RecipeCountOutputTypeCountInstructionsArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountInstructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInstructionWhereInput
  }


  /**
   * Count Type CustomNicheCountOutputType
   */

  export type CustomNicheCountOutputType = {
    sites: number
  }

  export type CustomNicheCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | CustomNicheCountOutputTypeCountSitesArgs
  }

  // Custom InputTypes
  /**
   * CustomNicheCountOutputType without action
   */
  export type CustomNicheCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNicheCountOutputType
     */
    select?: CustomNicheCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomNicheCountOutputType without action
   */
  export type CustomNicheCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    children: number
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductCategoryCountOutputTypeCountChildrenArgs
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteProductWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    contentTypeId: number | null
    version: number | null
  }

  export type ContentSumAggregateOutputType = {
    contentTypeId: number | null
    version: number | null
  }

  export type ContentMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    contentTypeId: number | null
    status: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
    scheduledPublishAt: Date | null
  }

  export type ContentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    contentTypeId: number | null
    status: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
    scheduledPublishAt: Date | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    contentTypeId: number
    data: number
    status: number
    createdBy: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    version: number
    scheduledPublishAt: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    contentTypeId?: true
    version?: true
  }

  export type ContentSumAggregateInputType = {
    contentTypeId?: true
    version?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    contentTypeId?: true
    status?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    scheduledPublishAt?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    contentTypeId?: true
    status?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    scheduledPublishAt?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    contentTypeId?: true
    data?: true
    status?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    scheduledPublishAt?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonValue
    status: string
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
    scheduledPublishAt: Date | null
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    contentTypeId?: boolean
    data?: boolean
    status?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    scheduledPublishAt?: boolean
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
    categories?: boolean | Content$categoriesArgs<ExtArgs>
    tags?: boolean | Content$tagsArgs<ExtArgs>
    versions?: boolean | Content$versionsArgs<ExtArgs>
    siteContent?: boolean | Content$siteContentArgs<ExtArgs>
    media?: boolean | Content$mediaArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    contentTypeId?: boolean
    data?: boolean
    status?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    scheduledPublishAt?: boolean
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    contentTypeId?: boolean
    data?: boolean
    status?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    scheduledPublishAt?: boolean
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    contentTypeId?: boolean
    data?: boolean
    status?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    scheduledPublishAt?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "contentTypeId" | "data" | "status" | "createdBy" | "updatedBy" | "createdAt" | "updatedAt" | "version" | "scheduledPublishAt", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
    categories?: boolean | Content$categoriesArgs<ExtArgs>
    tags?: boolean | Content$tagsArgs<ExtArgs>
    versions?: boolean | Content$versionsArgs<ExtArgs>
    siteContent?: boolean | Content$siteContentArgs<ExtArgs>
    media?: boolean | Content$mediaArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentType?: boolean | ContentTypeDefaultArgs<ExtArgs>
  }

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      contentType: Prisma.$ContentTypePayload<ExtArgs>
      categories: Prisma.$ContentCategoryPayload<ExtArgs>[]
      tags: Prisma.$ContentTagPayload<ExtArgs>[]
      versions: Prisma.$ContentVersionPayload<ExtArgs>[]
      siteContent: Prisma.$SiteContentPayload<ExtArgs>[]
      media: Prisma.$SiteMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      contentTypeId: number
      data: Prisma.JsonValue
      status: string
      createdBy: string | null
      updatedBy: string | null
      createdAt: Date | null
      updatedAt: Date | null
      version: number | null
      scheduledPublishAt: Date | null
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentType<T extends ContentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentTypeDefaultArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends Content$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Content$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Content$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Content$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Content$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Content$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteContent<T extends Content$siteContentArgs<ExtArgs> = {}>(args?: Subset<T, Content$siteContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends Content$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Content$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'String'>
    readonly title: FieldRef<"Content", 'String'>
    readonly slug: FieldRef<"Content", 'String'>
    readonly contentTypeId: FieldRef<"Content", 'Int'>
    readonly data: FieldRef<"Content", 'Json'>
    readonly status: FieldRef<"Content", 'String'>
    readonly createdBy: FieldRef<"Content", 'String'>
    readonly updatedBy: FieldRef<"Content", 'String'>
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
    readonly version: FieldRef<"Content", 'Int'>
    readonly scheduledPublishAt: FieldRef<"Content", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.categories
   */
  export type Content$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    where?: ContentCategoryWhereInput
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    cursor?: ContentCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCategoryScalarFieldEnum | ContentCategoryScalarFieldEnum[]
  }

  /**
   * Content.tags
   */
  export type Content$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    cursor?: ContentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * Content.versions
   */
  export type Content$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    where?: ContentVersionWhereInput
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    cursor?: ContentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * Content.siteContent
   */
  export type Content$siteContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    where?: SiteContentWhereInput
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    cursor?: SiteContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteContentScalarFieldEnum | SiteContentScalarFieldEnum[]
  }

  /**
   * Content.media
   */
  export type Content$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    where?: SiteMediaWhereInput
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    cursor?: SiteMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentType
   */

  export type AggregateContentType = {
    _count: ContentTypeCountAggregateOutputType | null
    _avg: ContentTypeAvgAggregateOutputType | null
    _sum: ContentTypeSumAggregateOutputType | null
    _min: ContentTypeMinAggregateOutputType | null
    _max: ContentTypeMaxAggregateOutputType | null
  }

  export type ContentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ContentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ContentTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    schema: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentTypeAvgAggregateInputType = {
    id?: true
  }

  export type ContentTypeSumAggregateInputType = {
    id?: true
  }

  export type ContentTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schema?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentType to aggregate.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTypes
    **/
    _count?: true | ContentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTypeMaxAggregateInputType
  }

  export type GetContentTypeAggregateType<T extends ContentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentType[P]>
      : GetScalarType<T[P], AggregateContentType[P]>
  }




  export type ContentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTypeWhereInput
    orderBy?: ContentTypeOrderByWithAggregationInput | ContentTypeOrderByWithAggregationInput[]
    by: ContentTypeScalarFieldEnum[] | ContentTypeScalarFieldEnum
    having?: ContentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTypeCountAggregateInputType | true
    _avg?: ContentTypeAvgAggregateInputType
    _sum?: ContentTypeSumAggregateInputType
    _min?: ContentTypeMinAggregateInputType
    _max?: ContentTypeMaxAggregateInputType
  }

  export type ContentTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    schema: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ContentTypeCountAggregateOutputType | null
    _avg: ContentTypeAvgAggregateOutputType | null
    _sum: ContentTypeSumAggregateOutputType | null
    _min: ContentTypeMinAggregateOutputType | null
    _max: ContentTypeMaxAggregateOutputType | null
  }

  type GetContentTypeGroupByPayload<T extends ContentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schema?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | ContentType$contentArgs<ExtArgs>
    _count?: boolean | ContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentType"]>

  export type ContentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schema?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentType"]>

  export type ContentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schema?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentType"]>

  export type ContentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    schema?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "schema" | "createdAt" | "updatedAt", ExtArgs["result"]["contentType"]>
  export type ContentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentType$contentArgs<ExtArgs>
    _count?: boolean | ContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentType"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      schema: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["contentType"]>
    composites: {}
  }

  type ContentTypeGetPayload<S extends boolean | null | undefined | ContentTypeDefaultArgs> = $Result.GetResult<Prisma.$ContentTypePayload, S>

  type ContentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentTypeCountAggregateInputType | true
    }

  export interface ContentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentType'], meta: { name: 'ContentType' } }
    /**
     * Find zero or one ContentType that matches the filter.
     * @param {ContentTypeFindUniqueArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTypeFindUniqueArgs>(args: SelectSubset<T, ContentTypeFindUniqueArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentTypeFindUniqueOrThrowArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindFirstArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTypeFindFirstArgs>(args?: SelectSubset<T, ContentTypeFindFirstArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindFirstOrThrowArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTypes
     * const contentTypes = await prisma.contentType.findMany()
     * 
     * // Get first 10 ContentTypes
     * const contentTypes = await prisma.contentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentTypeWithIdOnly = await prisma.contentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentTypeFindManyArgs>(args?: SelectSubset<T, ContentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentType.
     * @param {ContentTypeCreateArgs} args - Arguments to create a ContentType.
     * @example
     * // Create one ContentType
     * const ContentType = await prisma.contentType.create({
     *   data: {
     *     // ... data to create a ContentType
     *   }
     * })
     * 
     */
    create<T extends ContentTypeCreateArgs>(args: SelectSubset<T, ContentTypeCreateArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentTypes.
     * @param {ContentTypeCreateManyArgs} args - Arguments to create many ContentTypes.
     * @example
     * // Create many ContentTypes
     * const contentType = await prisma.contentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTypeCreateManyArgs>(args?: SelectSubset<T, ContentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentTypes and returns the data saved in the database.
     * @param {ContentTypeCreateManyAndReturnArgs} args - Arguments to create many ContentTypes.
     * @example
     * // Create many ContentTypes
     * const contentType = await prisma.contentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentTypes and only return the `id`
     * const contentTypeWithIdOnly = await prisma.contentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentType.
     * @param {ContentTypeDeleteArgs} args - Arguments to delete one ContentType.
     * @example
     * // Delete one ContentType
     * const ContentType = await prisma.contentType.delete({
     *   where: {
     *     // ... filter to delete one ContentType
     *   }
     * })
     * 
     */
    delete<T extends ContentTypeDeleteArgs>(args: SelectSubset<T, ContentTypeDeleteArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentType.
     * @param {ContentTypeUpdateArgs} args - Arguments to update one ContentType.
     * @example
     * // Update one ContentType
     * const contentType = await prisma.contentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTypeUpdateArgs>(args: SelectSubset<T, ContentTypeUpdateArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentTypes.
     * @param {ContentTypeDeleteManyArgs} args - Arguments to filter ContentTypes to delete.
     * @example
     * // Delete a few ContentTypes
     * const { count } = await prisma.contentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTypeDeleteManyArgs>(args?: SelectSubset<T, ContentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTypes
     * const contentType = await prisma.contentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTypeUpdateManyArgs>(args: SelectSubset<T, ContentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTypes and returns the data updated in the database.
     * @param {ContentTypeUpdateManyAndReturnArgs} args - Arguments to update many ContentTypes.
     * @example
     * // Update many ContentTypes
     * const contentType = await prisma.contentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentTypes and only return the `id`
     * const contentTypeWithIdOnly = await prisma.contentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentType.
     * @param {ContentTypeUpsertArgs} args - Arguments to update or create a ContentType.
     * @example
     * // Update or create a ContentType
     * const contentType = await prisma.contentType.upsert({
     *   create: {
     *     // ... data to create a ContentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentType we want to update
     *   }
     * })
     */
    upsert<T extends ContentTypeUpsertArgs>(args: SelectSubset<T, ContentTypeUpsertArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeCountArgs} args - Arguments to filter ContentTypes to count.
     * @example
     * // Count the number of ContentTypes
     * const count = await prisma.contentType.count({
     *   where: {
     *     // ... the filter for the ContentTypes we want to count
     *   }
     * })
    **/
    count<T extends ContentTypeCountArgs>(
      args?: Subset<T, ContentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTypeAggregateArgs>(args: Subset<T, ContentTypeAggregateArgs>): Prisma.PrismaPromise<GetContentTypeAggregateType<T>>

    /**
     * Group by ContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentType model
   */
  readonly fields: ContentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentType$contentArgs<ExtArgs> = {}>(args?: Subset<T, ContentType$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentType model
   */
  interface ContentTypeFieldRefs {
    readonly id: FieldRef<"ContentType", 'Int'>
    readonly name: FieldRef<"ContentType", 'String'>
    readonly description: FieldRef<"ContentType", 'String'>
    readonly schema: FieldRef<"ContentType", 'Json'>
    readonly createdAt: FieldRef<"ContentType", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentType findUnique
   */
  export type ContentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType findUniqueOrThrow
   */
  export type ContentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType findFirst
   */
  export type ContentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTypes.
     */
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType findFirstOrThrow
   */
  export type ContentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTypes.
     */
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType findMany
   */
  export type ContentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentTypes to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType create
   */
  export type ContentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentType.
     */
    data: XOR<ContentTypeCreateInput, ContentTypeUncheckedCreateInput>
  }

  /**
   * ContentType createMany
   */
  export type ContentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTypes.
     */
    data: ContentTypeCreateManyInput | ContentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentType createManyAndReturn
   */
  export type ContentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ContentTypes.
     */
    data: ContentTypeCreateManyInput | ContentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentType update
   */
  export type ContentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentType.
     */
    data: XOR<ContentTypeUpdateInput, ContentTypeUncheckedUpdateInput>
    /**
     * Choose, which ContentType to update.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType updateMany
   */
  export type ContentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTypes.
     */
    data: XOR<ContentTypeUpdateManyMutationInput, ContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContentTypes to update
     */
    where?: ContentTypeWhereInput
    /**
     * Limit how many ContentTypes to update.
     */
    limit?: number
  }

  /**
   * ContentType updateManyAndReturn
   */
  export type ContentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * The data used to update ContentTypes.
     */
    data: XOR<ContentTypeUpdateManyMutationInput, ContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContentTypes to update
     */
    where?: ContentTypeWhereInput
    /**
     * Limit how many ContentTypes to update.
     */
    limit?: number
  }

  /**
   * ContentType upsert
   */
  export type ContentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentType to update in case it exists.
     */
    where: ContentTypeWhereUniqueInput
    /**
     * In case the ContentType found by the `where` argument doesn't exist, create a new ContentType with this data.
     */
    create: XOR<ContentTypeCreateInput, ContentTypeUncheckedCreateInput>
    /**
     * In case the ContentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTypeUpdateInput, ContentTypeUncheckedUpdateInput>
  }

  /**
   * ContentType delete
   */
  export type ContentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter which ContentType to delete.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType deleteMany
   */
  export type ContentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTypes to delete
     */
    where?: ContentTypeWhereInput
    /**
     * Limit how many ContentTypes to delete.
     */
    limit?: number
  }

  /**
   * ContentType.content
   */
  export type ContentType$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * ContentType without action
   */
  export type ContentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    slug: string
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    content?: boolean | Category$contentArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    content?: boolean | Category$contentArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      content: Prisma.$ContentCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      slug: string
      parentId: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    content<T extends Category$contentArgs<ExtArgs> = {}>(args?: Subset<T, Category$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.content
   */
  export type Category$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    where?: ContentCategoryWhereInput
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    cursor?: ContentCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCategoryScalarFieldEnum | ContentCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ContentCategory
   */

  export type AggregateContentCategory = {
    _count: ContentCategoryCountAggregateOutputType | null
    _avg: ContentCategoryAvgAggregateOutputType | null
    _sum: ContentCategorySumAggregateOutputType | null
    _min: ContentCategoryMinAggregateOutputType | null
    _max: ContentCategoryMaxAggregateOutputType | null
  }

  export type ContentCategoryAvgAggregateOutputType = {
    categoryId: number | null
  }

  export type ContentCategorySumAggregateOutputType = {
    categoryId: number | null
  }

  export type ContentCategoryMinAggregateOutputType = {
    contentId: string | null
    categoryId: number | null
  }

  export type ContentCategoryMaxAggregateOutputType = {
    contentId: string | null
    categoryId: number | null
  }

  export type ContentCategoryCountAggregateOutputType = {
    contentId: number
    categoryId: number
    _all: number
  }


  export type ContentCategoryAvgAggregateInputType = {
    categoryId?: true
  }

  export type ContentCategorySumAggregateInputType = {
    categoryId?: true
  }

  export type ContentCategoryMinAggregateInputType = {
    contentId?: true
    categoryId?: true
  }

  export type ContentCategoryMaxAggregateInputType = {
    contentId?: true
    categoryId?: true
  }

  export type ContentCategoryCountAggregateInputType = {
    contentId?: true
    categoryId?: true
    _all?: true
  }

  export type ContentCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCategory to aggregate.
     */
    where?: ContentCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCategories to fetch.
     */
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentCategories
    **/
    _count?: true | ContentCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentCategoryMaxAggregateInputType
  }

  export type GetContentCategoryAggregateType<T extends ContentCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateContentCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentCategory[P]>
      : GetScalarType<T[P], AggregateContentCategory[P]>
  }




  export type ContentCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCategoryWhereInput
    orderBy?: ContentCategoryOrderByWithAggregationInput | ContentCategoryOrderByWithAggregationInput[]
    by: ContentCategoryScalarFieldEnum[] | ContentCategoryScalarFieldEnum
    having?: ContentCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCategoryCountAggregateInputType | true
    _avg?: ContentCategoryAvgAggregateInputType
    _sum?: ContentCategorySumAggregateInputType
    _min?: ContentCategoryMinAggregateInputType
    _max?: ContentCategoryMaxAggregateInputType
  }

  export type ContentCategoryGroupByOutputType = {
    contentId: string
    categoryId: number
    _count: ContentCategoryCountAggregateOutputType | null
    _avg: ContentCategoryAvgAggregateOutputType | null
    _sum: ContentCategorySumAggregateOutputType | null
    _min: ContentCategoryMinAggregateOutputType | null
    _max: ContentCategoryMaxAggregateOutputType | null
  }

  type GetContentCategoryGroupByPayload<T extends ContentCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ContentCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ContentCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCategory"]>

  export type ContentCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCategory"]>

  export type ContentCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCategory"]>

  export type ContentCategorySelectScalar = {
    contentId?: boolean
    categoryId?: boolean
  }

  export type ContentCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contentId" | "categoryId", ExtArgs["result"]["contentCategory"]>
  export type ContentCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }

  export type $ContentCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentCategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      content: Prisma.$ContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contentId: string
      categoryId: number
    }, ExtArgs["result"]["contentCategory"]>
    composites: {}
  }

  type ContentCategoryGetPayload<S extends boolean | null | undefined | ContentCategoryDefaultArgs> = $Result.GetResult<Prisma.$ContentCategoryPayload, S>

  type ContentCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCategoryCountAggregateInputType | true
    }

  export interface ContentCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentCategory'], meta: { name: 'ContentCategory' } }
    /**
     * Find zero or one ContentCategory that matches the filter.
     * @param {ContentCategoryFindUniqueArgs} args - Arguments to find a ContentCategory
     * @example
     * // Get one ContentCategory
     * const contentCategory = await prisma.contentCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentCategoryFindUniqueArgs>(args: SelectSubset<T, ContentCategoryFindUniqueArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentCategoryFindUniqueOrThrowArgs} args - Arguments to find a ContentCategory
     * @example
     * // Get one ContentCategory
     * const contentCategory = await prisma.contentCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryFindFirstArgs} args - Arguments to find a ContentCategory
     * @example
     * // Get one ContentCategory
     * const contentCategory = await prisma.contentCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentCategoryFindFirstArgs>(args?: SelectSubset<T, ContentCategoryFindFirstArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryFindFirstOrThrowArgs} args - Arguments to find a ContentCategory
     * @example
     * // Get one ContentCategory
     * const contentCategory = await prisma.contentCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentCategories
     * const contentCategories = await prisma.contentCategory.findMany()
     * 
     * // Get first 10 ContentCategories
     * const contentCategories = await prisma.contentCategory.findMany({ take: 10 })
     * 
     * // Only select the `contentId`
     * const contentCategoryWithContentIdOnly = await prisma.contentCategory.findMany({ select: { contentId: true } })
     * 
     */
    findMany<T extends ContentCategoryFindManyArgs>(args?: SelectSubset<T, ContentCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentCategory.
     * @param {ContentCategoryCreateArgs} args - Arguments to create a ContentCategory.
     * @example
     * // Create one ContentCategory
     * const ContentCategory = await prisma.contentCategory.create({
     *   data: {
     *     // ... data to create a ContentCategory
     *   }
     * })
     * 
     */
    create<T extends ContentCategoryCreateArgs>(args: SelectSubset<T, ContentCategoryCreateArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentCategories.
     * @param {ContentCategoryCreateManyArgs} args - Arguments to create many ContentCategories.
     * @example
     * // Create many ContentCategories
     * const contentCategory = await prisma.contentCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCategoryCreateManyArgs>(args?: SelectSubset<T, ContentCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentCategories and returns the data saved in the database.
     * @param {ContentCategoryCreateManyAndReturnArgs} args - Arguments to create many ContentCategories.
     * @example
     * // Create many ContentCategories
     * const contentCategory = await prisma.contentCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentCategories and only return the `contentId`
     * const contentCategoryWithContentIdOnly = await prisma.contentCategory.createManyAndReturn({
     *   select: { contentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentCategory.
     * @param {ContentCategoryDeleteArgs} args - Arguments to delete one ContentCategory.
     * @example
     * // Delete one ContentCategory
     * const ContentCategory = await prisma.contentCategory.delete({
     *   where: {
     *     // ... filter to delete one ContentCategory
     *   }
     * })
     * 
     */
    delete<T extends ContentCategoryDeleteArgs>(args: SelectSubset<T, ContentCategoryDeleteArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentCategory.
     * @param {ContentCategoryUpdateArgs} args - Arguments to update one ContentCategory.
     * @example
     * // Update one ContentCategory
     * const contentCategory = await prisma.contentCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentCategoryUpdateArgs>(args: SelectSubset<T, ContentCategoryUpdateArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentCategories.
     * @param {ContentCategoryDeleteManyArgs} args - Arguments to filter ContentCategories to delete.
     * @example
     * // Delete a few ContentCategories
     * const { count } = await prisma.contentCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentCategoryDeleteManyArgs>(args?: SelectSubset<T, ContentCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentCategories
     * const contentCategory = await prisma.contentCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentCategoryUpdateManyArgs>(args: SelectSubset<T, ContentCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentCategories and returns the data updated in the database.
     * @param {ContentCategoryUpdateManyAndReturnArgs} args - Arguments to update many ContentCategories.
     * @example
     * // Update many ContentCategories
     * const contentCategory = await prisma.contentCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentCategories and only return the `contentId`
     * const contentCategoryWithContentIdOnly = await prisma.contentCategory.updateManyAndReturn({
     *   select: { contentId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentCategory.
     * @param {ContentCategoryUpsertArgs} args - Arguments to update or create a ContentCategory.
     * @example
     * // Update or create a ContentCategory
     * const contentCategory = await prisma.contentCategory.upsert({
     *   create: {
     *     // ... data to create a ContentCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentCategory we want to update
     *   }
     * })
     */
    upsert<T extends ContentCategoryUpsertArgs>(args: SelectSubset<T, ContentCategoryUpsertArgs<ExtArgs>>): Prisma__ContentCategoryClient<$Result.GetResult<Prisma.$ContentCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryCountArgs} args - Arguments to filter ContentCategories to count.
     * @example
     * // Count the number of ContentCategories
     * const count = await prisma.contentCategory.count({
     *   where: {
     *     // ... the filter for the ContentCategories we want to count
     *   }
     * })
    **/
    count<T extends ContentCategoryCountArgs>(
      args?: Subset<T, ContentCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentCategoryAggregateArgs>(args: Subset<T, ContentCategoryAggregateArgs>): Prisma.PrismaPromise<GetContentCategoryAggregateType<T>>

    /**
     * Group by ContentCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ContentCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentCategory model
   */
  readonly fields: ContentCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentCategory model
   */
  interface ContentCategoryFieldRefs {
    readonly contentId: FieldRef<"ContentCategory", 'String'>
    readonly categoryId: FieldRef<"ContentCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentCategory findUnique
   */
  export type ContentCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ContentCategory to fetch.
     */
    where: ContentCategoryWhereUniqueInput
  }

  /**
   * ContentCategory findUniqueOrThrow
   */
  export type ContentCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ContentCategory to fetch.
     */
    where: ContentCategoryWhereUniqueInput
  }

  /**
   * ContentCategory findFirst
   */
  export type ContentCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ContentCategory to fetch.
     */
    where?: ContentCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCategories to fetch.
     */
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCategories.
     */
    cursor?: ContentCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCategories.
     */
    distinct?: ContentCategoryScalarFieldEnum | ContentCategoryScalarFieldEnum[]
  }

  /**
   * ContentCategory findFirstOrThrow
   */
  export type ContentCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ContentCategory to fetch.
     */
    where?: ContentCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCategories to fetch.
     */
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCategories.
     */
    cursor?: ContentCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCategories.
     */
    distinct?: ContentCategoryScalarFieldEnum | ContentCategoryScalarFieldEnum[]
  }

  /**
   * ContentCategory findMany
   */
  export type ContentCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ContentCategories to fetch.
     */
    where?: ContentCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCategories to fetch.
     */
    orderBy?: ContentCategoryOrderByWithRelationInput | ContentCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentCategories.
     */
    cursor?: ContentCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCategories.
     */
    skip?: number
    distinct?: ContentCategoryScalarFieldEnum | ContentCategoryScalarFieldEnum[]
  }

  /**
   * ContentCategory create
   */
  export type ContentCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentCategory.
     */
    data: XOR<ContentCategoryCreateInput, ContentCategoryUncheckedCreateInput>
  }

  /**
   * ContentCategory createMany
   */
  export type ContentCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentCategories.
     */
    data: ContentCategoryCreateManyInput | ContentCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentCategory createManyAndReturn
   */
  export type ContentCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ContentCategories.
     */
    data: ContentCategoryCreateManyInput | ContentCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentCategory update
   */
  export type ContentCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentCategory.
     */
    data: XOR<ContentCategoryUpdateInput, ContentCategoryUncheckedUpdateInput>
    /**
     * Choose, which ContentCategory to update.
     */
    where: ContentCategoryWhereUniqueInput
  }

  /**
   * ContentCategory updateMany
   */
  export type ContentCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentCategories.
     */
    data: XOR<ContentCategoryUpdateManyMutationInput, ContentCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ContentCategories to update
     */
    where?: ContentCategoryWhereInput
    /**
     * Limit how many ContentCategories to update.
     */
    limit?: number
  }

  /**
   * ContentCategory updateManyAndReturn
   */
  export type ContentCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ContentCategories.
     */
    data: XOR<ContentCategoryUpdateManyMutationInput, ContentCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ContentCategories to update
     */
    where?: ContentCategoryWhereInput
    /**
     * Limit how many ContentCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentCategory upsert
   */
  export type ContentCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentCategory to update in case it exists.
     */
    where: ContentCategoryWhereUniqueInput
    /**
     * In case the ContentCategory found by the `where` argument doesn't exist, create a new ContentCategory with this data.
     */
    create: XOR<ContentCategoryCreateInput, ContentCategoryUncheckedCreateInput>
    /**
     * In case the ContentCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentCategoryUpdateInput, ContentCategoryUncheckedUpdateInput>
  }

  /**
   * ContentCategory delete
   */
  export type ContentCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
    /**
     * Filter which ContentCategory to delete.
     */
    where: ContentCategoryWhereUniqueInput
  }

  /**
   * ContentCategory deleteMany
   */
  export type ContentCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCategories to delete
     */
    where?: ContentCategoryWhereInput
    /**
     * Limit how many ContentCategories to delete.
     */
    limit?: number
  }

  /**
   * ContentCategory without action
   */
  export type ContentCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCategory
     */
    select?: ContentCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentCategory
     */
    omit?: ContentCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    description: string | null
    slug: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | Tag$contentArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | Tag$contentArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      content: Prisma.$ContentTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      slug: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends Tag$contentArgs<ExtArgs> = {}>(args?: Subset<T, Tag$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.content
   */
  export type Tag$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    cursor?: ContentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ContentTag
   */

  export type AggregateContentTag = {
    _count: ContentTagCountAggregateOutputType | null
    _avg: ContentTagAvgAggregateOutputType | null
    _sum: ContentTagSumAggregateOutputType | null
    _min: ContentTagMinAggregateOutputType | null
    _max: ContentTagMaxAggregateOutputType | null
  }

  export type ContentTagAvgAggregateOutputType = {
    tagId: number | null
  }

  export type ContentTagSumAggregateOutputType = {
    tagId: number | null
  }

  export type ContentTagMinAggregateOutputType = {
    contentId: string | null
    tagId: number | null
  }

  export type ContentTagMaxAggregateOutputType = {
    contentId: string | null
    tagId: number | null
  }

  export type ContentTagCountAggregateOutputType = {
    contentId: number
    tagId: number
    _all: number
  }


  export type ContentTagAvgAggregateInputType = {
    tagId?: true
  }

  export type ContentTagSumAggregateInputType = {
    tagId?: true
  }

  export type ContentTagMinAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagMaxAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagCountAggregateInputType = {
    contentId?: true
    tagId?: true
    _all?: true
  }

  export type ContentTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTag to aggregate.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTags
    **/
    _count?: true | ContentTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTagMaxAggregateInputType
  }

  export type GetContentTagAggregateType<T extends ContentTagAggregateArgs> = {
        [P in keyof T & keyof AggregateContentTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentTag[P]>
      : GetScalarType<T[P], AggregateContentTag[P]>
  }




  export type ContentTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithAggregationInput | ContentTagOrderByWithAggregationInput[]
    by: ContentTagScalarFieldEnum[] | ContentTagScalarFieldEnum
    having?: ContentTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTagCountAggregateInputType | true
    _avg?: ContentTagAvgAggregateInputType
    _sum?: ContentTagSumAggregateInputType
    _min?: ContentTagMinAggregateInputType
    _max?: ContentTagMaxAggregateInputType
  }

  export type ContentTagGroupByOutputType = {
    contentId: string
    tagId: number
    _count: ContentTagCountAggregateOutputType | null
    _avg: ContentTagAvgAggregateOutputType | null
    _sum: ContentTagSumAggregateOutputType | null
    _min: ContentTagMinAggregateOutputType | null
    _max: ContentTagMaxAggregateOutputType | null
  }

  type GetContentTagGroupByPayload<T extends ContentTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTagGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTagGroupByOutputType[P]>
        }
      >
    >


  export type ContentTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    tagId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTag"]>

  export type ContentTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    tagId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTag"]>

  export type ContentTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    tagId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTag"]>

  export type ContentTagSelectScalar = {
    contentId?: boolean
    tagId?: boolean
  }

  export type ContentTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contentId" | "tagId", ExtArgs["result"]["contentTag"]>
  export type ContentTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContentTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContentTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ContentTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentTag"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contentId: string
      tagId: number
    }, ExtArgs["result"]["contentTag"]>
    composites: {}
  }

  type ContentTagGetPayload<S extends boolean | null | undefined | ContentTagDefaultArgs> = $Result.GetResult<Prisma.$ContentTagPayload, S>

  type ContentTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentTagCountAggregateInputType | true
    }

  export interface ContentTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentTag'], meta: { name: 'ContentTag' } }
    /**
     * Find zero or one ContentTag that matches the filter.
     * @param {ContentTagFindUniqueArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTagFindUniqueArgs>(args: SelectSubset<T, ContentTagFindUniqueArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentTagFindUniqueOrThrowArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindFirstArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTagFindFirstArgs>(args?: SelectSubset<T, ContentTagFindFirstArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindFirstOrThrowArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTags
     * const contentTags = await prisma.contentTag.findMany()
     * 
     * // Get first 10 ContentTags
     * const contentTags = await prisma.contentTag.findMany({ take: 10 })
     * 
     * // Only select the `contentId`
     * const contentTagWithContentIdOnly = await prisma.contentTag.findMany({ select: { contentId: true } })
     * 
     */
    findMany<T extends ContentTagFindManyArgs>(args?: SelectSubset<T, ContentTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentTag.
     * @param {ContentTagCreateArgs} args - Arguments to create a ContentTag.
     * @example
     * // Create one ContentTag
     * const ContentTag = await prisma.contentTag.create({
     *   data: {
     *     // ... data to create a ContentTag
     *   }
     * })
     * 
     */
    create<T extends ContentTagCreateArgs>(args: SelectSubset<T, ContentTagCreateArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentTags.
     * @param {ContentTagCreateManyArgs} args - Arguments to create many ContentTags.
     * @example
     * // Create many ContentTags
     * const contentTag = await prisma.contentTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTagCreateManyArgs>(args?: SelectSubset<T, ContentTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentTags and returns the data saved in the database.
     * @param {ContentTagCreateManyAndReturnArgs} args - Arguments to create many ContentTags.
     * @example
     * // Create many ContentTags
     * const contentTag = await prisma.contentTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentTags and only return the `contentId`
     * const contentTagWithContentIdOnly = await prisma.contentTag.createManyAndReturn({
     *   select: { contentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentTag.
     * @param {ContentTagDeleteArgs} args - Arguments to delete one ContentTag.
     * @example
     * // Delete one ContentTag
     * const ContentTag = await prisma.contentTag.delete({
     *   where: {
     *     // ... filter to delete one ContentTag
     *   }
     * })
     * 
     */
    delete<T extends ContentTagDeleteArgs>(args: SelectSubset<T, ContentTagDeleteArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentTag.
     * @param {ContentTagUpdateArgs} args - Arguments to update one ContentTag.
     * @example
     * // Update one ContentTag
     * const contentTag = await prisma.contentTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTagUpdateArgs>(args: SelectSubset<T, ContentTagUpdateArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentTags.
     * @param {ContentTagDeleteManyArgs} args - Arguments to filter ContentTags to delete.
     * @example
     * // Delete a few ContentTags
     * const { count } = await prisma.contentTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTagDeleteManyArgs>(args?: SelectSubset<T, ContentTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTags
     * const contentTag = await prisma.contentTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTagUpdateManyArgs>(args: SelectSubset<T, ContentTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTags and returns the data updated in the database.
     * @param {ContentTagUpdateManyAndReturnArgs} args - Arguments to update many ContentTags.
     * @example
     * // Update many ContentTags
     * const contentTag = await prisma.contentTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentTags and only return the `contentId`
     * const contentTagWithContentIdOnly = await prisma.contentTag.updateManyAndReturn({
     *   select: { contentId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentTag.
     * @param {ContentTagUpsertArgs} args - Arguments to update or create a ContentTag.
     * @example
     * // Update or create a ContentTag
     * const contentTag = await prisma.contentTag.upsert({
     *   create: {
     *     // ... data to create a ContentTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentTag we want to update
     *   }
     * })
     */
    upsert<T extends ContentTagUpsertArgs>(args: SelectSubset<T, ContentTagUpsertArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagCountArgs} args - Arguments to filter ContentTags to count.
     * @example
     * // Count the number of ContentTags
     * const count = await prisma.contentTag.count({
     *   where: {
     *     // ... the filter for the ContentTags we want to count
     *   }
     * })
    **/
    count<T extends ContentTagCountArgs>(
      args?: Subset<T, ContentTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTagAggregateArgs>(args: Subset<T, ContentTagAggregateArgs>): Prisma.PrismaPromise<GetContentTagAggregateType<T>>

    /**
     * Group by ContentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTagGroupByArgs['orderBy'] }
        : { orderBy?: ContentTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentTag model
   */
  readonly fields: ContentTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentTag model
   */
  interface ContentTagFieldRefs {
    readonly contentId: FieldRef<"ContentTag", 'String'>
    readonly tagId: FieldRef<"ContentTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentTag findUnique
   */
  export type ContentTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag findUniqueOrThrow
   */
  export type ContentTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag findFirst
   */
  export type ContentTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTags.
     */
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag findFirstOrThrow
   */
  export type ContentTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTags.
     */
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag findMany
   */
  export type ContentTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTags to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag create
   */
  export type ContentTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentTag.
     */
    data: XOR<ContentTagCreateInput, ContentTagUncheckedCreateInput>
  }

  /**
   * ContentTag createMany
   */
  export type ContentTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTags.
     */
    data: ContentTagCreateManyInput | ContentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentTag createManyAndReturn
   */
  export type ContentTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * The data used to create many ContentTags.
     */
    data: ContentTagCreateManyInput | ContentTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentTag update
   */
  export type ContentTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentTag.
     */
    data: XOR<ContentTagUpdateInput, ContentTagUncheckedUpdateInput>
    /**
     * Choose, which ContentTag to update.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag updateMany
   */
  export type ContentTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTags.
     */
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyInput>
    /**
     * Filter which ContentTags to update
     */
    where?: ContentTagWhereInput
    /**
     * Limit how many ContentTags to update.
     */
    limit?: number
  }

  /**
   * ContentTag updateManyAndReturn
   */
  export type ContentTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * The data used to update ContentTags.
     */
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyInput>
    /**
     * Filter which ContentTags to update
     */
    where?: ContentTagWhereInput
    /**
     * Limit how many ContentTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentTag upsert
   */
  export type ContentTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentTag to update in case it exists.
     */
    where: ContentTagWhereUniqueInput
    /**
     * In case the ContentTag found by the `where` argument doesn't exist, create a new ContentTag with this data.
     */
    create: XOR<ContentTagCreateInput, ContentTagUncheckedCreateInput>
    /**
     * In case the ContentTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTagUpdateInput, ContentTagUncheckedUpdateInput>
  }

  /**
   * ContentTag delete
   */
  export type ContentTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter which ContentTag to delete.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag deleteMany
   */
  export type ContentTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTags to delete
     */
    where?: ContentTagWhereInput
    /**
     * Limit how many ContentTags to delete.
     */
    limit?: number
  }

  /**
   * ContentTag without action
   */
  export type ContentTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTag
     */
    omit?: ContentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
  }


  /**
   * Model Site
   */

  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    nicheType: string | null
    customNicheId: string | null
    targetAudience: string | null
    siteTitle: string | null
    siteDescription: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    aboutTitle: string | null
    aboutDescription: string | null
    contactEmail: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    featuredPostsTitle: string | null
    featuredPostsSubtitle: string | null
    featuredProductsTitle: string | null
    featuredProductsSubtitle: string | null
    newsletterTitle: string | null
    newsletterSubtitle: string | null
    autoBlogEnabled: boolean | null
    autoBlogFrequency: string | null
    footerText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    nicheType: string | null
    customNicheId: string | null
    targetAudience: string | null
    siteTitle: string | null
    siteDescription: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    aboutTitle: string | null
    aboutDescription: string | null
    contactEmail: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    featuredPostsTitle: string | null
    featuredPostsSubtitle: string | null
    featuredProductsTitle: string | null
    featuredProductsSubtitle: string | null
    newsletterTitle: string | null
    newsletterSubtitle: string | null
    autoBlogEnabled: boolean | null
    autoBlogFrequency: string | null
    footerText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    logoUrl: number
    primaryColor: number
    secondaryColor: number
    nicheType: number
    customNicheId: number
    nicheKeywords: number
    targetAudience: number
    siteTitle: number
    siteDescription: number
    heroTitle: number
    heroSubtitle: number
    aboutTitle: number
    aboutDescription: number
    contactEmail: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    featuredPostsTitle: number
    featuredPostsSubtitle: number
    featuredProductsTitle: number
    featuredProductsSubtitle: number
    newsletterTitle: number
    newsletterSubtitle: number
    autoBlogEnabled: number
    autoBlogFrequency: number
    autoBlogPostTypes: number
    autoBlogCategories: number
    footerText: number
    socialLinks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    nicheType?: true
    customNicheId?: true
    targetAudience?: true
    siteTitle?: true
    siteDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    aboutTitle?: true
    aboutDescription?: true
    contactEmail?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    featuredPostsTitle?: true
    featuredPostsSubtitle?: true
    featuredProductsTitle?: true
    featuredProductsSubtitle?: true
    newsletterTitle?: true
    newsletterSubtitle?: true
    autoBlogEnabled?: true
    autoBlogFrequency?: true
    footerText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    nicheType?: true
    customNicheId?: true
    targetAudience?: true
    siteTitle?: true
    siteDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    aboutTitle?: true
    aboutDescription?: true
    contactEmail?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    featuredPostsTitle?: true
    featuredPostsSubtitle?: true
    featuredProductsTitle?: true
    featuredProductsSubtitle?: true
    newsletterTitle?: true
    newsletterSubtitle?: true
    autoBlogEnabled?: true
    autoBlogFrequency?: true
    footerText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    nicheType?: true
    customNicheId?: true
    nicheKeywords?: true
    targetAudience?: true
    siteTitle?: true
    siteDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    aboutTitle?: true
    aboutDescription?: true
    contactEmail?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    featuredPostsTitle?: true
    featuredPostsSubtitle?: true
    featuredProductsTitle?: true
    featuredProductsSubtitle?: true
    newsletterTitle?: true
    newsletterSubtitle?: true
    autoBlogEnabled?: true
    autoBlogFrequency?: true
    autoBlogPostTypes?: true
    autoBlogCategories?: true
    footerText?: true
    socialLinks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithAggregationInput | SiteOrderByWithAggregationInput[]
    by: SiteScalarFieldEnum[] | SiteScalarFieldEnum
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }

  export type SiteGroupByOutputType = {
    id: string
    name: string
    domain: string
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    nicheType: string
    customNicheId: string | null
    nicheKeywords: JsonValue | null
    targetAudience: string | null
    siteTitle: string | null
    siteDescription: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    aboutTitle: string | null
    aboutDescription: string | null
    contactEmail: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    featuredPostsTitle: string | null
    featuredPostsSubtitle: string | null
    featuredProductsTitle: string | null
    featuredProductsSubtitle: string | null
    newsletterTitle: string | null
    newsletterSubtitle: string | null
    autoBlogEnabled: boolean
    autoBlogFrequency: string | null
    autoBlogPostTypes: JsonValue | null
    autoBlogCategories: JsonValue | null
    footerText: string | null
    socialLinks: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SiteCountAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    nicheType?: boolean
    customNicheId?: boolean
    nicheKeywords?: boolean
    targetAudience?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    aboutTitle?: boolean
    aboutDescription?: boolean
    contactEmail?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    featuredPostsTitle?: boolean
    featuredPostsSubtitle?: boolean
    featuredProductsTitle?: boolean
    featuredProductsSubtitle?: boolean
    newsletterTitle?: boolean
    newsletterSubtitle?: boolean
    autoBlogEnabled?: boolean
    autoBlogFrequency?: boolean
    autoBlogPostTypes?: boolean
    autoBlogCategories?: boolean
    footerText?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliateLinks?: boolean | Site$affiliateLinksArgs<ExtArgs>
    autoBlogPosts?: boolean | Site$autoBlogPostsArgs<ExtArgs>
    contentSchedules?: boolean | Site$contentSchedulesArgs<ExtArgs>
    quizzes?: boolean | Site$quizzesArgs<ExtArgs>
    priceAlerts?: boolean | Site$priceAlertsArgs<ExtArgs>
    productCategories?: boolean | Site$productCategoriesArgs<ExtArgs>
    customFields?: boolean | Site$customFieldsArgs<ExtArgs>
    content?: boolean | Site$contentArgs<ExtArgs>
    media?: boolean | Site$mediaArgs<ExtArgs>
    products?: boolean | Site$productsArgs<ExtArgs>
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    nicheType?: boolean
    customNicheId?: boolean
    nicheKeywords?: boolean
    targetAudience?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    aboutTitle?: boolean
    aboutDescription?: boolean
    contactEmail?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    featuredPostsTitle?: boolean
    featuredPostsSubtitle?: boolean
    featuredProductsTitle?: boolean
    featuredProductsSubtitle?: boolean
    newsletterTitle?: boolean
    newsletterSubtitle?: boolean
    autoBlogEnabled?: boolean
    autoBlogFrequency?: boolean
    autoBlogPostTypes?: boolean
    autoBlogCategories?: boolean
    footerText?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    nicheType?: boolean
    customNicheId?: boolean
    nicheKeywords?: boolean
    targetAudience?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    aboutTitle?: boolean
    aboutDescription?: boolean
    contactEmail?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    featuredPostsTitle?: boolean
    featuredPostsSubtitle?: boolean
    featuredProductsTitle?: boolean
    featuredProductsSubtitle?: boolean
    newsletterTitle?: boolean
    newsletterSubtitle?: boolean
    autoBlogEnabled?: boolean
    autoBlogFrequency?: boolean
    autoBlogPostTypes?: boolean
    autoBlogCategories?: boolean
    footerText?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    nicheType?: boolean
    customNicheId?: boolean
    nicheKeywords?: boolean
    targetAudience?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    aboutTitle?: boolean
    aboutDescription?: boolean
    contactEmail?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    featuredPostsTitle?: boolean
    featuredPostsSubtitle?: boolean
    featuredProductsTitle?: boolean
    featuredProductsSubtitle?: boolean
    newsletterTitle?: boolean
    newsletterSubtitle?: boolean
    autoBlogEnabled?: boolean
    autoBlogFrequency?: boolean
    autoBlogPostTypes?: boolean
    autoBlogCategories?: boolean
    footerText?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "logoUrl" | "primaryColor" | "secondaryColor" | "nicheType" | "customNicheId" | "nicheKeywords" | "targetAudience" | "siteTitle" | "siteDescription" | "heroTitle" | "heroSubtitle" | "aboutTitle" | "aboutDescription" | "contactEmail" | "metaTitle" | "metaDescription" | "metaKeywords" | "featuredPostsTitle" | "featuredPostsSubtitle" | "featuredProductsTitle" | "featuredProductsSubtitle" | "newsletterTitle" | "newsletterSubtitle" | "autoBlogEnabled" | "autoBlogFrequency" | "autoBlogPostTypes" | "autoBlogCategories" | "footerText" | "socialLinks" | "createdAt" | "updatedAt", ExtArgs["result"]["site"]>
  export type SiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | Site$affiliateLinksArgs<ExtArgs>
    autoBlogPosts?: boolean | Site$autoBlogPostsArgs<ExtArgs>
    contentSchedules?: boolean | Site$contentSchedulesArgs<ExtArgs>
    quizzes?: boolean | Site$quizzesArgs<ExtArgs>
    priceAlerts?: boolean | Site$priceAlertsArgs<ExtArgs>
    productCategories?: boolean | Site$productCategoriesArgs<ExtArgs>
    customFields?: boolean | Site$customFieldsArgs<ExtArgs>
    content?: boolean | Site$contentArgs<ExtArgs>
    media?: boolean | Site$mediaArgs<ExtArgs>
    products?: boolean | Site$productsArgs<ExtArgs>
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
  }
  export type SiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customNiche?: boolean | Site$customNicheArgs<ExtArgs>
  }

  export type $SitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Site"
    objects: {
      affiliateLinks: Prisma.$AffiliateLinkPayload<ExtArgs>[]
      autoBlogPosts: Prisma.$AutoBlogPostPayload<ExtArgs>[]
      contentSchedules: Prisma.$ContentSchedulePayload<ExtArgs>[]
      quizzes: Prisma.$InteractiveQuizPayload<ExtArgs>[]
      priceAlerts: Prisma.$PriceAlertPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      customFields: Prisma.$ProductCustomFieldPayload<ExtArgs>[]
      content: Prisma.$SiteContentPayload<ExtArgs>[]
      media: Prisma.$SiteMediaPayload<ExtArgs>[]
      products: Prisma.$SiteProductPayload<ExtArgs>[]
      customNiche: Prisma.$CustomNichePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      logoUrl: string | null
      primaryColor: string | null
      secondaryColor: string | null
      nicheType: string
      customNicheId: string | null
      nicheKeywords: Prisma.JsonValue | null
      targetAudience: string | null
      siteTitle: string | null
      siteDescription: string | null
      heroTitle: string | null
      heroSubtitle: string | null
      aboutTitle: string | null
      aboutDescription: string | null
      contactEmail: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
      featuredPostsTitle: string | null
      featuredPostsSubtitle: string | null
      featuredProductsTitle: string | null
      featuredProductsSubtitle: string | null
      newsletterTitle: string | null
      newsletterSubtitle: string | null
      autoBlogEnabled: boolean
      autoBlogFrequency: string | null
      autoBlogPostTypes: Prisma.JsonValue | null
      autoBlogCategories: Prisma.JsonValue | null
      footerText: string | null
      socialLinks: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["site"]>
    composites: {}
  }

  type SiteGetPayload<S extends boolean | null | undefined | SiteDefaultArgs> = $Result.GetResult<Prisma.$SitePayload, S>

  type SiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Site'], meta: { name: 'Site' } }
    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteFindUniqueArgs>(args: SelectSubset<T, SiteFindUniqueArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Site that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteFindFirstArgs>(args?: SelectSubset<T, SiteFindFirstArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteFindManyArgs>(args?: SelectSubset<T, SiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
     */
    create<T extends SiteCreateArgs>(args: SelectSubset<T, SiteCreateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCreateManyArgs>(args?: SelectSubset<T, SiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {SiteCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
     */
    delete<T extends SiteDeleteArgs>(args: SelectSubset<T, SiteDeleteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteUpdateArgs>(args: SelectSubset<T, SiteUpdateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteDeleteManyArgs>(args?: SelectSubset<T, SiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteUpdateManyArgs>(args: SelectSubset<T, SiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {SiteUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
     */
    upsert<T extends SiteUpsertArgs>(args: SelectSubset<T, SiteUpsertArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Site model
   */
  readonly fields: SiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateLinks<T extends Site$affiliateLinksArgs<ExtArgs> = {}>(args?: Subset<T, Site$affiliateLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoBlogPosts<T extends Site$autoBlogPostsArgs<ExtArgs> = {}>(args?: Subset<T, Site$autoBlogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contentSchedules<T extends Site$contentSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Site$contentSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends Site$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Site$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceAlerts<T extends Site$priceAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Site$priceAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategories<T extends Site$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Site$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customFields<T extends Site$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Site$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    content<T extends Site$contentArgs<ExtArgs> = {}>(args?: Subset<T, Site$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends Site$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Site$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Site$productsArgs<ExtArgs> = {}>(args?: Subset<T, Site$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customNiche<T extends Site$customNicheArgs<ExtArgs> = {}>(args?: Subset<T, Site$customNicheArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Site model
   */
  interface SiteFieldRefs {
    readonly id: FieldRef<"Site", 'String'>
    readonly name: FieldRef<"Site", 'String'>
    readonly domain: FieldRef<"Site", 'String'>
    readonly logoUrl: FieldRef<"Site", 'String'>
    readonly primaryColor: FieldRef<"Site", 'String'>
    readonly secondaryColor: FieldRef<"Site", 'String'>
    readonly nicheType: FieldRef<"Site", 'String'>
    readonly customNicheId: FieldRef<"Site", 'String'>
    readonly nicheKeywords: FieldRef<"Site", 'Json'>
    readonly targetAudience: FieldRef<"Site", 'String'>
    readonly siteTitle: FieldRef<"Site", 'String'>
    readonly siteDescription: FieldRef<"Site", 'String'>
    readonly heroTitle: FieldRef<"Site", 'String'>
    readonly heroSubtitle: FieldRef<"Site", 'String'>
    readonly aboutTitle: FieldRef<"Site", 'String'>
    readonly aboutDescription: FieldRef<"Site", 'String'>
    readonly contactEmail: FieldRef<"Site", 'String'>
    readonly metaTitle: FieldRef<"Site", 'String'>
    readonly metaDescription: FieldRef<"Site", 'String'>
    readonly metaKeywords: FieldRef<"Site", 'String'>
    readonly featuredPostsTitle: FieldRef<"Site", 'String'>
    readonly featuredPostsSubtitle: FieldRef<"Site", 'String'>
    readonly featuredProductsTitle: FieldRef<"Site", 'String'>
    readonly featuredProductsSubtitle: FieldRef<"Site", 'String'>
    readonly newsletterTitle: FieldRef<"Site", 'String'>
    readonly newsletterSubtitle: FieldRef<"Site", 'String'>
    readonly autoBlogEnabled: FieldRef<"Site", 'Boolean'>
    readonly autoBlogFrequency: FieldRef<"Site", 'String'>
    readonly autoBlogPostTypes: FieldRef<"Site", 'Json'>
    readonly autoBlogCategories: FieldRef<"Site", 'Json'>
    readonly footerText: FieldRef<"Site", 'String'>
    readonly socialLinks: FieldRef<"Site", 'Json'>
    readonly createdAt: FieldRef<"Site", 'DateTime'>
    readonly updatedAt: FieldRef<"Site", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Site findUnique
   */
  export type SiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findFirst
   */
  export type SiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findMany
   */
  export type SiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site create
   */
  export type SiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }

  /**
   * Site createMany
   */
  export type SiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Site createManyAndReturn
   */
  export type SiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site update
   */
  export type SiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
  }

  /**
   * Site updateManyAndReturn
   */
  export type SiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site upsert
   */
  export type SiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }

  /**
   * Site delete
   */
  export type SiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to delete.
     */
    limit?: number
  }

  /**
   * Site.affiliateLinks
   */
  export type Site$affiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    cursor?: AffiliateLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * Site.autoBlogPosts
   */
  export type Site$autoBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    where?: AutoBlogPostWhereInput
    orderBy?: AutoBlogPostOrderByWithRelationInput | AutoBlogPostOrderByWithRelationInput[]
    cursor?: AutoBlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoBlogPostScalarFieldEnum | AutoBlogPostScalarFieldEnum[]
  }

  /**
   * Site.contentSchedules
   */
  export type Site$contentSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    where?: ContentScheduleWhereInput
    orderBy?: ContentScheduleOrderByWithRelationInput | ContentScheduleOrderByWithRelationInput[]
    cursor?: ContentScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScheduleScalarFieldEnum | ContentScheduleScalarFieldEnum[]
  }

  /**
   * Site.quizzes
   */
  export type Site$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    where?: InteractiveQuizWhereInput
    orderBy?: InteractiveQuizOrderByWithRelationInput | InteractiveQuizOrderByWithRelationInput[]
    cursor?: InteractiveQuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractiveQuizScalarFieldEnum | InteractiveQuizScalarFieldEnum[]
  }

  /**
   * Site.priceAlerts
   */
  export type Site$priceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    where?: PriceAlertWhereInput
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    cursor?: PriceAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * Site.productCategories
   */
  export type Site$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Site.customFields
   */
  export type Site$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    where?: ProductCustomFieldWhereInput
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    cursor?: ProductCustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCustomFieldScalarFieldEnum | ProductCustomFieldScalarFieldEnum[]
  }

  /**
   * Site.content
   */
  export type Site$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    where?: SiteContentWhereInput
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    cursor?: SiteContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteContentScalarFieldEnum | SiteContentScalarFieldEnum[]
  }

  /**
   * Site.media
   */
  export type Site$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    where?: SiteMediaWhereInput
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    cursor?: SiteMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * Site.products
   */
  export type Site$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    where?: SiteProductWhereInput
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    cursor?: SiteProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * Site.customNiche
   */
  export type Site$customNicheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    where?: CustomNicheWhereInput
  }

  /**
   * Site without action
   */
  export type SiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
  }


  /**
   * Model SiteContent
   */

  export type AggregateSiteContent = {
    _count: SiteContentCountAggregateOutputType | null
    _min: SiteContentMinAggregateOutputType | null
    _max: SiteContentMaxAggregateOutputType | null
  }

  export type SiteContentMinAggregateOutputType = {
    siteId: string | null
    contentId: string | null
  }

  export type SiteContentMaxAggregateOutputType = {
    siteId: string | null
    contentId: string | null
  }

  export type SiteContentCountAggregateOutputType = {
    siteId: number
    contentId: number
    _all: number
  }


  export type SiteContentMinAggregateInputType = {
    siteId?: true
    contentId?: true
  }

  export type SiteContentMaxAggregateInputType = {
    siteId?: true
    contentId?: true
  }

  export type SiteContentCountAggregateInputType = {
    siteId?: true
    contentId?: true
    _all?: true
  }

  export type SiteContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteContent to aggregate.
     */
    where?: SiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteContents to fetch.
     */
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteContents
    **/
    _count?: true | SiteContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteContentMaxAggregateInputType
  }

  export type GetSiteContentAggregateType<T extends SiteContentAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteContent[P]>
      : GetScalarType<T[P], AggregateSiteContent[P]>
  }




  export type SiteContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteContentWhereInput
    orderBy?: SiteContentOrderByWithAggregationInput | SiteContentOrderByWithAggregationInput[]
    by: SiteContentScalarFieldEnum[] | SiteContentScalarFieldEnum
    having?: SiteContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteContentCountAggregateInputType | true
    _min?: SiteContentMinAggregateInputType
    _max?: SiteContentMaxAggregateInputType
  }

  export type SiteContentGroupByOutputType = {
    siteId: string
    contentId: string
    _count: SiteContentCountAggregateOutputType | null
    _min: SiteContentMinAggregateOutputType | null
    _max: SiteContentMaxAggregateOutputType | null
  }

  type GetSiteContentGroupByPayload<T extends SiteContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteContentGroupByOutputType[P]>
            : GetScalarType<T[P], SiteContentGroupByOutputType[P]>
        }
      >
    >


  export type SiteContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteContent"]>

  export type SiteContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteContent"]>

  export type SiteContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteContent"]>

  export type SiteContentSelectScalar = {
    siteId?: boolean
    contentId?: boolean
  }

  export type SiteContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"siteId" | "contentId", ExtArgs["result"]["siteContent"]>
  export type SiteContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $SiteContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteContent"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      siteId: string
      contentId: string
    }, ExtArgs["result"]["siteContent"]>
    composites: {}
  }

  type SiteContentGetPayload<S extends boolean | null | undefined | SiteContentDefaultArgs> = $Result.GetResult<Prisma.$SiteContentPayload, S>

  type SiteContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteContentCountAggregateInputType | true
    }

  export interface SiteContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteContent'], meta: { name: 'SiteContent' } }
    /**
     * Find zero or one SiteContent that matches the filter.
     * @param {SiteContentFindUniqueArgs} args - Arguments to find a SiteContent
     * @example
     * // Get one SiteContent
     * const siteContent = await prisma.siteContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteContentFindUniqueArgs>(args: SelectSubset<T, SiteContentFindUniqueArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteContentFindUniqueOrThrowArgs} args - Arguments to find a SiteContent
     * @example
     * // Get one SiteContent
     * const siteContent = await prisma.siteContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteContentFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentFindFirstArgs} args - Arguments to find a SiteContent
     * @example
     * // Get one SiteContent
     * const siteContent = await prisma.siteContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteContentFindFirstArgs>(args?: SelectSubset<T, SiteContentFindFirstArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentFindFirstOrThrowArgs} args - Arguments to find a SiteContent
     * @example
     * // Get one SiteContent
     * const siteContent = await prisma.siteContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteContentFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteContents
     * const siteContents = await prisma.siteContent.findMany()
     * 
     * // Get first 10 SiteContents
     * const siteContents = await prisma.siteContent.findMany({ take: 10 })
     * 
     * // Only select the `siteId`
     * const siteContentWithSiteIdOnly = await prisma.siteContent.findMany({ select: { siteId: true } })
     * 
     */
    findMany<T extends SiteContentFindManyArgs>(args?: SelectSubset<T, SiteContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteContent.
     * @param {SiteContentCreateArgs} args - Arguments to create a SiteContent.
     * @example
     * // Create one SiteContent
     * const SiteContent = await prisma.siteContent.create({
     *   data: {
     *     // ... data to create a SiteContent
     *   }
     * })
     * 
     */
    create<T extends SiteContentCreateArgs>(args: SelectSubset<T, SiteContentCreateArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteContents.
     * @param {SiteContentCreateManyArgs} args - Arguments to create many SiteContents.
     * @example
     * // Create many SiteContents
     * const siteContent = await prisma.siteContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteContentCreateManyArgs>(args?: SelectSubset<T, SiteContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteContents and returns the data saved in the database.
     * @param {SiteContentCreateManyAndReturnArgs} args - Arguments to create many SiteContents.
     * @example
     * // Create many SiteContents
     * const siteContent = await prisma.siteContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteContents and only return the `siteId`
     * const siteContentWithSiteIdOnly = await prisma.siteContent.createManyAndReturn({
     *   select: { siteId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteContentCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteContent.
     * @param {SiteContentDeleteArgs} args - Arguments to delete one SiteContent.
     * @example
     * // Delete one SiteContent
     * const SiteContent = await prisma.siteContent.delete({
     *   where: {
     *     // ... filter to delete one SiteContent
     *   }
     * })
     * 
     */
    delete<T extends SiteContentDeleteArgs>(args: SelectSubset<T, SiteContentDeleteArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteContent.
     * @param {SiteContentUpdateArgs} args - Arguments to update one SiteContent.
     * @example
     * // Update one SiteContent
     * const siteContent = await prisma.siteContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteContentUpdateArgs>(args: SelectSubset<T, SiteContentUpdateArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteContents.
     * @param {SiteContentDeleteManyArgs} args - Arguments to filter SiteContents to delete.
     * @example
     * // Delete a few SiteContents
     * const { count } = await prisma.siteContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteContentDeleteManyArgs>(args?: SelectSubset<T, SiteContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteContents
     * const siteContent = await prisma.siteContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteContentUpdateManyArgs>(args: SelectSubset<T, SiteContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteContents and returns the data updated in the database.
     * @param {SiteContentUpdateManyAndReturnArgs} args - Arguments to update many SiteContents.
     * @example
     * // Update many SiteContents
     * const siteContent = await prisma.siteContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteContents and only return the `siteId`
     * const siteContentWithSiteIdOnly = await prisma.siteContent.updateManyAndReturn({
     *   select: { siteId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteContentUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteContent.
     * @param {SiteContentUpsertArgs} args - Arguments to update or create a SiteContent.
     * @example
     * // Update or create a SiteContent
     * const siteContent = await prisma.siteContent.upsert({
     *   create: {
     *     // ... data to create a SiteContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteContent we want to update
     *   }
     * })
     */
    upsert<T extends SiteContentUpsertArgs>(args: SelectSubset<T, SiteContentUpsertArgs<ExtArgs>>): Prisma__SiteContentClient<$Result.GetResult<Prisma.$SiteContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentCountArgs} args - Arguments to filter SiteContents to count.
     * @example
     * // Count the number of SiteContents
     * const count = await prisma.siteContent.count({
     *   where: {
     *     // ... the filter for the SiteContents we want to count
     *   }
     * })
    **/
    count<T extends SiteContentCountArgs>(
      args?: Subset<T, SiteContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteContentAggregateArgs>(args: Subset<T, SiteContentAggregateArgs>): Prisma.PrismaPromise<GetSiteContentAggregateType<T>>

    /**
     * Group by SiteContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteContentGroupByArgs['orderBy'] }
        : { orderBy?: SiteContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteContent model
   */
  readonly fields: SiteContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteContent model
   */
  interface SiteContentFieldRefs {
    readonly siteId: FieldRef<"SiteContent", 'String'>
    readonly contentId: FieldRef<"SiteContent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SiteContent findUnique
   */
  export type SiteContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter, which SiteContent to fetch.
     */
    where: SiteContentWhereUniqueInput
  }

  /**
   * SiteContent findUniqueOrThrow
   */
  export type SiteContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter, which SiteContent to fetch.
     */
    where: SiteContentWhereUniqueInput
  }

  /**
   * SiteContent findFirst
   */
  export type SiteContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter, which SiteContent to fetch.
     */
    where?: SiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteContents to fetch.
     */
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteContents.
     */
    cursor?: SiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteContents.
     */
    distinct?: SiteContentScalarFieldEnum | SiteContentScalarFieldEnum[]
  }

  /**
   * SiteContent findFirstOrThrow
   */
  export type SiteContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter, which SiteContent to fetch.
     */
    where?: SiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteContents to fetch.
     */
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteContents.
     */
    cursor?: SiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteContents.
     */
    distinct?: SiteContentScalarFieldEnum | SiteContentScalarFieldEnum[]
  }

  /**
   * SiteContent findMany
   */
  export type SiteContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter, which SiteContents to fetch.
     */
    where?: SiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteContents to fetch.
     */
    orderBy?: SiteContentOrderByWithRelationInput | SiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteContents.
     */
    cursor?: SiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteContents.
     */
    skip?: number
    distinct?: SiteContentScalarFieldEnum | SiteContentScalarFieldEnum[]
  }

  /**
   * SiteContent create
   */
  export type SiteContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteContent.
     */
    data: XOR<SiteContentCreateInput, SiteContentUncheckedCreateInput>
  }

  /**
   * SiteContent createMany
   */
  export type SiteContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteContents.
     */
    data: SiteContentCreateManyInput | SiteContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteContent createManyAndReturn
   */
  export type SiteContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * The data used to create many SiteContents.
     */
    data: SiteContentCreateManyInput | SiteContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteContent update
   */
  export type SiteContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteContent.
     */
    data: XOR<SiteContentUpdateInput, SiteContentUncheckedUpdateInput>
    /**
     * Choose, which SiteContent to update.
     */
    where: SiteContentWhereUniqueInput
  }

  /**
   * SiteContent updateMany
   */
  export type SiteContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteContents.
     */
    data: XOR<SiteContentUpdateManyMutationInput, SiteContentUncheckedUpdateManyInput>
    /**
     * Filter which SiteContents to update
     */
    where?: SiteContentWhereInput
    /**
     * Limit how many SiteContents to update.
     */
    limit?: number
  }

  /**
   * SiteContent updateManyAndReturn
   */
  export type SiteContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * The data used to update SiteContents.
     */
    data: XOR<SiteContentUpdateManyMutationInput, SiteContentUncheckedUpdateManyInput>
    /**
     * Filter which SiteContents to update
     */
    where?: SiteContentWhereInput
    /**
     * Limit how many SiteContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteContent upsert
   */
  export type SiteContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteContent to update in case it exists.
     */
    where: SiteContentWhereUniqueInput
    /**
     * In case the SiteContent found by the `where` argument doesn't exist, create a new SiteContent with this data.
     */
    create: XOR<SiteContentCreateInput, SiteContentUncheckedCreateInput>
    /**
     * In case the SiteContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteContentUpdateInput, SiteContentUncheckedUpdateInput>
  }

  /**
   * SiteContent delete
   */
  export type SiteContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
    /**
     * Filter which SiteContent to delete.
     */
    where: SiteContentWhereUniqueInput
  }

  /**
   * SiteContent deleteMany
   */
  export type SiteContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteContents to delete
     */
    where?: SiteContentWhereInput
    /**
     * Limit how many SiteContents to delete.
     */
    limit?: number
  }

  /**
   * SiteContent without action
   */
  export type SiteContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteContent
     */
    select?: SiteContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteContent
     */
    omit?: SiteContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteContentInclude<ExtArgs> | null
  }


  /**
   * Model MediaAsset
   */

  export type AggregateMediaAsset = {
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  export type MediaAssetAvgAggregateOutputType = {
    size: number | null
  }

  export type MediaAssetSumAggregateOutputType = {
    size: number | null
  }

  export type MediaAssetMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    altText: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAssetAvgAggregateInputType = {
    size?: true
  }

  export type MediaAssetSumAggregateInputType = {
    size?: true
  }

  export type MediaAssetMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAsset to aggregate.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAssets
    **/
    _count?: true | MediaAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAssetMaxAggregateInputType
  }

  export type GetMediaAssetAggregateType<T extends MediaAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAsset[P]>
      : GetScalarType<T[P], AggregateMediaAsset[P]>
  }




  export type MediaAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithAggregationInput | MediaAssetOrderByWithAggregationInput[]
    by: MediaAssetScalarFieldEnum[] | MediaAssetScalarFieldEnum
    having?: MediaAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAssetCountAggregateInputType | true
    _avg?: MediaAssetAvgAggregateInputType
    _sum?: MediaAssetSumAggregateInputType
    _min?: MediaAssetMinAggregateInputType
    _max?: MediaAssetMaxAggregateInputType
  }

  export type MediaAssetGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText: string | null
    metadata: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  type GetMediaAssetGroupByPayload<T extends MediaAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
        }
      >
    >


  export type MediaAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteMedia?: boolean | MediaAsset$siteMediaArgs<ExtArgs>
    _count?: boolean | MediaAssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "url" | "altText" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaAsset"]>
  export type MediaAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteMedia?: boolean | MediaAsset$siteMediaArgs<ExtArgs>
    _count?: boolean | MediaAssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAsset"
    objects: {
      siteMedia: Prisma.$SiteMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      altText: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["mediaAsset"]>
    composites: {}
  }

  type MediaAssetGetPayload<S extends boolean | null | undefined | MediaAssetDefaultArgs> = $Result.GetResult<Prisma.$MediaAssetPayload, S>

  type MediaAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaAssetCountAggregateInputType | true
    }

  export interface MediaAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAsset'], meta: { name: 'MediaAsset' } }
    /**
     * Find zero or one MediaAsset that matches the filter.
     * @param {MediaAssetFindUniqueArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAssetFindUniqueArgs>(args: SelectSubset<T, MediaAssetFindUniqueArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaAssetFindUniqueOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAssetFindFirstArgs>(args?: SelectSubset<T, MediaAssetFindFirstArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany()
     * 
     * // Get first 10 MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAssetFindManyArgs>(args?: SelectSubset<T, MediaAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaAsset.
     * @param {MediaAssetCreateArgs} args - Arguments to create a MediaAsset.
     * @example
     * // Create one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.create({
     *   data: {
     *     // ... data to create a MediaAsset
     *   }
     * })
     * 
     */
    create<T extends MediaAssetCreateArgs>(args: SelectSubset<T, MediaAssetCreateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaAssets.
     * @param {MediaAssetCreateManyArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAssetCreateManyArgs>(args?: SelectSubset<T, MediaAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAssets and returns the data saved in the database.
     * @param {MediaAssetCreateManyAndReturnArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaAsset.
     * @param {MediaAssetDeleteArgs} args - Arguments to delete one MediaAsset.
     * @example
     * // Delete one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.delete({
     *   where: {
     *     // ... filter to delete one MediaAsset
     *   }
     * })
     * 
     */
    delete<T extends MediaAssetDeleteArgs>(args: SelectSubset<T, MediaAssetDeleteArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaAsset.
     * @param {MediaAssetUpdateArgs} args - Arguments to update one MediaAsset.
     * @example
     * // Update one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAssetUpdateArgs>(args: SelectSubset<T, MediaAssetUpdateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaAssets.
     * @param {MediaAssetDeleteManyArgs} args - Arguments to filter MediaAssets to delete.
     * @example
     * // Delete a few MediaAssets
     * const { count } = await prisma.mediaAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAssetDeleteManyArgs>(args?: SelectSubset<T, MediaAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAssetUpdateManyArgs>(args: SelectSubset<T, MediaAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets and returns the data updated in the database.
     * @param {MediaAssetUpdateManyAndReturnArgs} args - Arguments to update many MediaAssets.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaAsset.
     * @param {MediaAssetUpsertArgs} args - Arguments to update or create a MediaAsset.
     * @example
     * // Update or create a MediaAsset
     * const mediaAsset = await prisma.mediaAsset.upsert({
     *   create: {
     *     // ... data to create a MediaAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAsset we want to update
     *   }
     * })
     */
    upsert<T extends MediaAssetUpsertArgs>(args: SelectSubset<T, MediaAssetUpsertArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetCountArgs} args - Arguments to filter MediaAssets to count.
     * @example
     * // Count the number of MediaAssets
     * const count = await prisma.mediaAsset.count({
     *   where: {
     *     // ... the filter for the MediaAssets we want to count
     *   }
     * })
    **/
    count<T extends MediaAssetCountArgs>(
      args?: Subset<T, MediaAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAssetAggregateArgs>(args: Subset<T, MediaAssetAggregateArgs>): Prisma.PrismaPromise<GetMediaAssetAggregateType<T>>

    /**
     * Group by MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAssetGroupByArgs['orderBy'] }
        : { orderBy?: MediaAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAsset model
   */
  readonly fields: MediaAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    siteMedia<T extends MediaAsset$siteMediaArgs<ExtArgs> = {}>(args?: Subset<T, MediaAsset$siteMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAsset model
   */
  interface MediaAssetFieldRefs {
    readonly id: FieldRef<"MediaAsset", 'String'>
    readonly filename: FieldRef<"MediaAsset", 'String'>
    readonly originalName: FieldRef<"MediaAsset", 'String'>
    readonly mimeType: FieldRef<"MediaAsset", 'String'>
    readonly size: FieldRef<"MediaAsset", 'Int'>
    readonly url: FieldRef<"MediaAsset", 'String'>
    readonly altText: FieldRef<"MediaAsset", 'String'>
    readonly metadata: FieldRef<"MediaAsset", 'Json'>
    readonly createdAt: FieldRef<"MediaAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaAsset findUnique
   */
  export type MediaAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findUniqueOrThrow
   */
  export type MediaAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findFirst
   */
  export type MediaAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findFirstOrThrow
   */
  export type MediaAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findMany
   */
  export type MediaAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAssets to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset create
   */
  export type MediaAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAsset.
     */
    data: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
  }

  /**
   * MediaAsset createMany
   */
  export type MediaAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset createManyAndReturn
   */
  export type MediaAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset update
   */
  export type MediaAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAsset.
     */
    data: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
    /**
     * Choose, which MediaAsset to update.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset updateMany
   */
  export type MediaAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
  }

  /**
   * MediaAsset updateManyAndReturn
   */
  export type MediaAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
  }

  /**
   * MediaAsset upsert
   */
  export type MediaAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAsset to update in case it exists.
     */
    where: MediaAssetWhereUniqueInput
    /**
     * In case the MediaAsset found by the `where` argument doesn't exist, create a new MediaAsset with this data.
     */
    create: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
    /**
     * In case the MediaAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
  }

  /**
   * MediaAsset delete
   */
  export type MediaAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter which MediaAsset to delete.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset deleteMany
   */
  export type MediaAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAssets to delete
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to delete.
     */
    limit?: number
  }

  /**
   * MediaAsset.siteMedia
   */
  export type MediaAsset$siteMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    where?: SiteMediaWhereInput
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    cursor?: SiteMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * MediaAsset without action
   */
  export type MediaAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
  }


  /**
   * Model SiteMedia
   */

  export type AggregateSiteMedia = {
    _count: SiteMediaCountAggregateOutputType | null
    _min: SiteMediaMinAggregateOutputType | null
    _max: SiteMediaMaxAggregateOutputType | null
  }

  export type SiteMediaMinAggregateOutputType = {
    siteId: string | null
    contentId: string | null
    mediaAssetId: string | null
  }

  export type SiteMediaMaxAggregateOutputType = {
    siteId: string | null
    contentId: string | null
    mediaAssetId: string | null
  }

  export type SiteMediaCountAggregateOutputType = {
    siteId: number
    contentId: number
    mediaAssetId: number
    _all: number
  }


  export type SiteMediaMinAggregateInputType = {
    siteId?: true
    contentId?: true
    mediaAssetId?: true
  }

  export type SiteMediaMaxAggregateInputType = {
    siteId?: true
    contentId?: true
    mediaAssetId?: true
  }

  export type SiteMediaCountAggregateInputType = {
    siteId?: true
    contentId?: true
    mediaAssetId?: true
    _all?: true
  }

  export type SiteMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteMedia to aggregate.
     */
    where?: SiteMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteMedias to fetch.
     */
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteMedias
    **/
    _count?: true | SiteMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMediaMaxAggregateInputType
  }

  export type GetSiteMediaAggregateType<T extends SiteMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteMedia[P]>
      : GetScalarType<T[P], AggregateSiteMedia[P]>
  }




  export type SiteMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteMediaWhereInput
    orderBy?: SiteMediaOrderByWithAggregationInput | SiteMediaOrderByWithAggregationInput[]
    by: SiteMediaScalarFieldEnum[] | SiteMediaScalarFieldEnum
    having?: SiteMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteMediaCountAggregateInputType | true
    _min?: SiteMediaMinAggregateInputType
    _max?: SiteMediaMaxAggregateInputType
  }

  export type SiteMediaGroupByOutputType = {
    siteId: string
    contentId: string
    mediaAssetId: string
    _count: SiteMediaCountAggregateOutputType | null
    _min: SiteMediaMinAggregateOutputType | null
    _max: SiteMediaMaxAggregateOutputType | null
  }

  type GetSiteMediaGroupByPayload<T extends SiteMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteMediaGroupByOutputType[P]>
            : GetScalarType<T[P], SiteMediaGroupByOutputType[P]>
        }
      >
    >


  export type SiteMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    mediaAssetId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteMedia"]>

  export type SiteMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    mediaAssetId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteMedia"]>

  export type SiteMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    contentId?: boolean
    mediaAssetId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteMedia"]>

  export type SiteMediaSelectScalar = {
    siteId?: boolean
    contentId?: boolean
    mediaAssetId?: boolean
  }

  export type SiteMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"siteId" | "contentId" | "mediaAssetId", ExtArgs["result"]["siteMedia"]>
  export type SiteMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $SiteMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteMedia"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      mediaAsset: Prisma.$MediaAssetPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      siteId: string
      contentId: string
      mediaAssetId: string
    }, ExtArgs["result"]["siteMedia"]>
    composites: {}
  }

  type SiteMediaGetPayload<S extends boolean | null | undefined | SiteMediaDefaultArgs> = $Result.GetResult<Prisma.$SiteMediaPayload, S>

  type SiteMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteMediaCountAggregateInputType | true
    }

  export interface SiteMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteMedia'], meta: { name: 'SiteMedia' } }
    /**
     * Find zero or one SiteMedia that matches the filter.
     * @param {SiteMediaFindUniqueArgs} args - Arguments to find a SiteMedia
     * @example
     * // Get one SiteMedia
     * const siteMedia = await prisma.siteMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteMediaFindUniqueArgs>(args: SelectSubset<T, SiteMediaFindUniqueArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteMediaFindUniqueOrThrowArgs} args - Arguments to find a SiteMedia
     * @example
     * // Get one SiteMedia
     * const siteMedia = await prisma.siteMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaFindFirstArgs} args - Arguments to find a SiteMedia
     * @example
     * // Get one SiteMedia
     * const siteMedia = await prisma.siteMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteMediaFindFirstArgs>(args?: SelectSubset<T, SiteMediaFindFirstArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaFindFirstOrThrowArgs} args - Arguments to find a SiteMedia
     * @example
     * // Get one SiteMedia
     * const siteMedia = await prisma.siteMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteMedias
     * const siteMedias = await prisma.siteMedia.findMany()
     * 
     * // Get first 10 SiteMedias
     * const siteMedias = await prisma.siteMedia.findMany({ take: 10 })
     * 
     * // Only select the `siteId`
     * const siteMediaWithSiteIdOnly = await prisma.siteMedia.findMany({ select: { siteId: true } })
     * 
     */
    findMany<T extends SiteMediaFindManyArgs>(args?: SelectSubset<T, SiteMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteMedia.
     * @param {SiteMediaCreateArgs} args - Arguments to create a SiteMedia.
     * @example
     * // Create one SiteMedia
     * const SiteMedia = await prisma.siteMedia.create({
     *   data: {
     *     // ... data to create a SiteMedia
     *   }
     * })
     * 
     */
    create<T extends SiteMediaCreateArgs>(args: SelectSubset<T, SiteMediaCreateArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteMedias.
     * @param {SiteMediaCreateManyArgs} args - Arguments to create many SiteMedias.
     * @example
     * // Create many SiteMedias
     * const siteMedia = await prisma.siteMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteMediaCreateManyArgs>(args?: SelectSubset<T, SiteMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteMedias and returns the data saved in the database.
     * @param {SiteMediaCreateManyAndReturnArgs} args - Arguments to create many SiteMedias.
     * @example
     * // Create many SiteMedias
     * const siteMedia = await prisma.siteMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteMedias and only return the `siteId`
     * const siteMediaWithSiteIdOnly = await prisma.siteMedia.createManyAndReturn({
     *   select: { siteId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteMedia.
     * @param {SiteMediaDeleteArgs} args - Arguments to delete one SiteMedia.
     * @example
     * // Delete one SiteMedia
     * const SiteMedia = await prisma.siteMedia.delete({
     *   where: {
     *     // ... filter to delete one SiteMedia
     *   }
     * })
     * 
     */
    delete<T extends SiteMediaDeleteArgs>(args: SelectSubset<T, SiteMediaDeleteArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteMedia.
     * @param {SiteMediaUpdateArgs} args - Arguments to update one SiteMedia.
     * @example
     * // Update one SiteMedia
     * const siteMedia = await prisma.siteMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteMediaUpdateArgs>(args: SelectSubset<T, SiteMediaUpdateArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteMedias.
     * @param {SiteMediaDeleteManyArgs} args - Arguments to filter SiteMedias to delete.
     * @example
     * // Delete a few SiteMedias
     * const { count } = await prisma.siteMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteMediaDeleteManyArgs>(args?: SelectSubset<T, SiteMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteMedias
     * const siteMedia = await prisma.siteMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteMediaUpdateManyArgs>(args: SelectSubset<T, SiteMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteMedias and returns the data updated in the database.
     * @param {SiteMediaUpdateManyAndReturnArgs} args - Arguments to update many SiteMedias.
     * @example
     * // Update many SiteMedias
     * const siteMedia = await prisma.siteMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteMedias and only return the `siteId`
     * const siteMediaWithSiteIdOnly = await prisma.siteMedia.updateManyAndReturn({
     *   select: { siteId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteMedia.
     * @param {SiteMediaUpsertArgs} args - Arguments to update or create a SiteMedia.
     * @example
     * // Update or create a SiteMedia
     * const siteMedia = await prisma.siteMedia.upsert({
     *   create: {
     *     // ... data to create a SiteMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteMedia we want to update
     *   }
     * })
     */
    upsert<T extends SiteMediaUpsertArgs>(args: SelectSubset<T, SiteMediaUpsertArgs<ExtArgs>>): Prisma__SiteMediaClient<$Result.GetResult<Prisma.$SiteMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaCountArgs} args - Arguments to filter SiteMedias to count.
     * @example
     * // Count the number of SiteMedias
     * const count = await prisma.siteMedia.count({
     *   where: {
     *     // ... the filter for the SiteMedias we want to count
     *   }
     * })
    **/
    count<T extends SiteMediaCountArgs>(
      args?: Subset<T, SiteMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteMediaAggregateArgs>(args: Subset<T, SiteMediaAggregateArgs>): Prisma.PrismaPromise<GetSiteMediaAggregateType<T>>

    /**
     * Group by SiteMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteMediaGroupByArgs['orderBy'] }
        : { orderBy?: SiteMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteMedia model
   */
  readonly fields: SiteMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mediaAsset<T extends MediaAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaAssetDefaultArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteMedia model
   */
  interface SiteMediaFieldRefs {
    readonly siteId: FieldRef<"SiteMedia", 'String'>
    readonly contentId: FieldRef<"SiteMedia", 'String'>
    readonly mediaAssetId: FieldRef<"SiteMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SiteMedia findUnique
   */
  export type SiteMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter, which SiteMedia to fetch.
     */
    where: SiteMediaWhereUniqueInput
  }

  /**
   * SiteMedia findUniqueOrThrow
   */
  export type SiteMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter, which SiteMedia to fetch.
     */
    where: SiteMediaWhereUniqueInput
  }

  /**
   * SiteMedia findFirst
   */
  export type SiteMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter, which SiteMedia to fetch.
     */
    where?: SiteMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteMedias to fetch.
     */
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteMedias.
     */
    cursor?: SiteMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteMedias.
     */
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * SiteMedia findFirstOrThrow
   */
  export type SiteMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter, which SiteMedia to fetch.
     */
    where?: SiteMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteMedias to fetch.
     */
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteMedias.
     */
    cursor?: SiteMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteMedias.
     */
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * SiteMedia findMany
   */
  export type SiteMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter, which SiteMedias to fetch.
     */
    where?: SiteMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteMedias to fetch.
     */
    orderBy?: SiteMediaOrderByWithRelationInput | SiteMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteMedias.
     */
    cursor?: SiteMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteMedias.
     */
    skip?: number
    distinct?: SiteMediaScalarFieldEnum | SiteMediaScalarFieldEnum[]
  }

  /**
   * SiteMedia create
   */
  export type SiteMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteMedia.
     */
    data: XOR<SiteMediaCreateInput, SiteMediaUncheckedCreateInput>
  }

  /**
   * SiteMedia createMany
   */
  export type SiteMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteMedias.
     */
    data: SiteMediaCreateManyInput | SiteMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteMedia createManyAndReturn
   */
  export type SiteMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * The data used to create many SiteMedias.
     */
    data: SiteMediaCreateManyInput | SiteMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteMedia update
   */
  export type SiteMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteMedia.
     */
    data: XOR<SiteMediaUpdateInput, SiteMediaUncheckedUpdateInput>
    /**
     * Choose, which SiteMedia to update.
     */
    where: SiteMediaWhereUniqueInput
  }

  /**
   * SiteMedia updateMany
   */
  export type SiteMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteMedias.
     */
    data: XOR<SiteMediaUpdateManyMutationInput, SiteMediaUncheckedUpdateManyInput>
    /**
     * Filter which SiteMedias to update
     */
    where?: SiteMediaWhereInput
    /**
     * Limit how many SiteMedias to update.
     */
    limit?: number
  }

  /**
   * SiteMedia updateManyAndReturn
   */
  export type SiteMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * The data used to update SiteMedias.
     */
    data: XOR<SiteMediaUpdateManyMutationInput, SiteMediaUncheckedUpdateManyInput>
    /**
     * Filter which SiteMedias to update
     */
    where?: SiteMediaWhereInput
    /**
     * Limit how many SiteMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteMedia upsert
   */
  export type SiteMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteMedia to update in case it exists.
     */
    where: SiteMediaWhereUniqueInput
    /**
     * In case the SiteMedia found by the `where` argument doesn't exist, create a new SiteMedia with this data.
     */
    create: XOR<SiteMediaCreateInput, SiteMediaUncheckedCreateInput>
    /**
     * In case the SiteMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteMediaUpdateInput, SiteMediaUncheckedUpdateInput>
  }

  /**
   * SiteMedia delete
   */
  export type SiteMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
    /**
     * Filter which SiteMedia to delete.
     */
    where: SiteMediaWhereUniqueInput
  }

  /**
   * SiteMedia deleteMany
   */
  export type SiteMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteMedias to delete
     */
    where?: SiteMediaWhereInput
    /**
     * Limit how many SiteMedias to delete.
     */
    limit?: number
  }

  /**
   * SiteMedia without action
   */
  export type SiteMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteMedia
     */
    select?: SiteMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteMedia
     */
    omit?: SiteMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteMediaInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    manufacturer: string | null
    basePrice: Decimal | null
    mainImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    manufacturer: string | null
    basePrice: Decimal | null
    mainImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    manufacturer: number
    basePrice: number
    mainImageUrl: number
    specifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    basePrice?: true
  }

  export type ProductSumAggregateInputType = {
    basePrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    manufacturer?: true
    basePrice?: true
    mainImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    manufacturer?: true
    basePrice?: true
    mainImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    manufacturer?: true
    basePrice?: true
    mainImageUrl?: true
    specifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    manufacturer: string | null
    basePrice: Decimal
    mainImageUrl: string | null
    specifications: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    manufacturer?: boolean
    basePrice?: boolean
    mainImageUrl?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliateLinks?: boolean | Product$affiliateLinksArgs<ExtArgs>
    customFields?: boolean | Product$customFieldsArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    siteProducts?: boolean | Product$siteProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    manufacturer?: boolean
    basePrice?: boolean
    mainImageUrl?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    manufacturer?: boolean
    basePrice?: boolean
    mainImageUrl?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    manufacturer?: boolean
    basePrice?: boolean
    mainImageUrl?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "manufacturer" | "basePrice" | "mainImageUrl" | "specifications" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | Product$affiliateLinksArgs<ExtArgs>
    customFields?: boolean | Product$customFieldsArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    siteProducts?: boolean | Product$siteProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      affiliateLinks: Prisma.$AffiliateLinkPayload<ExtArgs>[]
      customFields: Prisma.$ProductCustomFieldPayload<ExtArgs>[]
      priceHistory: Prisma.$ProductPriceHistoryPayload<ExtArgs>[]
      siteProducts: Prisma.$SiteProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      manufacturer: string | null
      basePrice: Prisma.Decimal
      mainImageUrl: string | null
      specifications: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateLinks<T extends Product$affiliateLinksArgs<ExtArgs> = {}>(args?: Subset<T, Product$affiliateLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customFields<T extends Product$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Product$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceHistory<T extends Product$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteProducts<T extends Product$siteProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$siteProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly manufacturer: FieldRef<"Product", 'String'>
    readonly basePrice: FieldRef<"Product", 'Decimal'>
    readonly mainImageUrl: FieldRef<"Product", 'String'>
    readonly specifications: FieldRef<"Product", 'Json'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.affiliateLinks
   */
  export type Product$affiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    cursor?: AffiliateLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * Product.customFields
   */
  export type Product$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    where?: ProductCustomFieldWhereInput
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    cursor?: ProductCustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCustomFieldScalarFieldEnum | ProductCustomFieldScalarFieldEnum[]
  }

  /**
   * Product.priceHistory
   */
  export type Product$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    where?: ProductPriceHistoryWhereInput
    orderBy?: ProductPriceHistoryOrderByWithRelationInput | ProductPriceHistoryOrderByWithRelationInput[]
    cursor?: ProductPriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPriceHistoryScalarFieldEnum | ProductPriceHistoryScalarFieldEnum[]
  }

  /**
   * Product.siteProducts
   */
  export type Product$siteProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    where?: SiteProductWhereInput
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    cursor?: SiteProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model SiteProduct
   */

  export type AggregateSiteProduct = {
    _count: SiteProductCountAggregateOutputType | null
    _avg: SiteProductAvgAggregateOutputType | null
    _sum: SiteProductSumAggregateOutputType | null
    _min: SiteProductMinAggregateOutputType | null
    _max: SiteProductMaxAggregateOutputType | null
  }

  export type SiteProductAvgAggregateOutputType = {
    price: Decimal | null
    discount: Decimal | null
  }

  export type SiteProductSumAggregateOutputType = {
    price: Decimal | null
    discount: Decimal | null
  }

  export type SiteProductMinAggregateOutputType = {
    siteId: string | null
    productId: string | null
    price: Decimal | null
    discount: Decimal | null
    inStock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type SiteProductMaxAggregateOutputType = {
    siteId: string | null
    productId: string | null
    price: Decimal | null
    discount: Decimal | null
    inStock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type SiteProductCountAggregateOutputType = {
    siteId: number
    productId: number
    price: number
    discount: number
    inStock: number
    createdAt: number
    updatedAt: number
    categoryId: number
    _all: number
  }


  export type SiteProductAvgAggregateInputType = {
    price?: true
    discount?: true
  }

  export type SiteProductSumAggregateInputType = {
    price?: true
    discount?: true
  }

  export type SiteProductMinAggregateInputType = {
    siteId?: true
    productId?: true
    price?: true
    discount?: true
    inStock?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type SiteProductMaxAggregateInputType = {
    siteId?: true
    productId?: true
    price?: true
    discount?: true
    inStock?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type SiteProductCountAggregateInputType = {
    siteId?: true
    productId?: true
    price?: true
    discount?: true
    inStock?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    _all?: true
  }

  export type SiteProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteProduct to aggregate.
     */
    where?: SiteProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteProducts to fetch.
     */
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteProducts
    **/
    _count?: true | SiteProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteProductMaxAggregateInputType
  }

  export type GetSiteProductAggregateType<T extends SiteProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteProduct[P]>
      : GetScalarType<T[P], AggregateSiteProduct[P]>
  }




  export type SiteProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteProductWhereInput
    orderBy?: SiteProductOrderByWithAggregationInput | SiteProductOrderByWithAggregationInput[]
    by: SiteProductScalarFieldEnum[] | SiteProductScalarFieldEnum
    having?: SiteProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteProductCountAggregateInputType | true
    _avg?: SiteProductAvgAggregateInputType
    _sum?: SiteProductSumAggregateInputType
    _min?: SiteProductMinAggregateInputType
    _max?: SiteProductMaxAggregateInputType
  }

  export type SiteProductGroupByOutputType = {
    siteId: string
    productId: string
    price: Decimal
    discount: Decimal | null
    inStock: boolean
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
    _count: SiteProductCountAggregateOutputType | null
    _avg: SiteProductAvgAggregateOutputType | null
    _sum: SiteProductSumAggregateOutputType | null
    _min: SiteProductMinAggregateOutputType | null
    _max: SiteProductMaxAggregateOutputType | null
  }

  type GetSiteProductGroupByPayload<T extends SiteProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteProductGroupByOutputType[P]>
            : GetScalarType<T[P], SiteProductGroupByOutputType[P]>
        }
      >
    >


  export type SiteProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    productId?: boolean
    price?: boolean
    discount?: boolean
    inStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteProduct"]>

  export type SiteProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    productId?: boolean
    price?: boolean
    discount?: boolean
    inStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteProduct"]>

  export type SiteProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteId?: boolean
    productId?: boolean
    price?: boolean
    discount?: boolean
    inStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteProduct"]>

  export type SiteProductSelectScalar = {
    siteId?: boolean
    productId?: boolean
    price?: boolean
    discount?: boolean
    inStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
  }

  export type SiteProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"siteId" | "productId" | "price" | "discount" | "inStock" | "createdAt" | "updatedAt" | "categoryId", ExtArgs["result"]["siteProduct"]>
  export type SiteProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SiteProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SiteProduct$categoryArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $SiteProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteProduct"
    objects: {
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      siteId: string
      productId: string
      price: Prisma.Decimal
      discount: Prisma.Decimal | null
      inStock: boolean
      createdAt: Date | null
      updatedAt: Date | null
      categoryId: string | null
    }, ExtArgs["result"]["siteProduct"]>
    composites: {}
  }

  type SiteProductGetPayload<S extends boolean | null | undefined | SiteProductDefaultArgs> = $Result.GetResult<Prisma.$SiteProductPayload, S>

  type SiteProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteProductCountAggregateInputType | true
    }

  export interface SiteProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteProduct'], meta: { name: 'SiteProduct' } }
    /**
     * Find zero or one SiteProduct that matches the filter.
     * @param {SiteProductFindUniqueArgs} args - Arguments to find a SiteProduct
     * @example
     * // Get one SiteProduct
     * const siteProduct = await prisma.siteProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteProductFindUniqueArgs>(args: SelectSubset<T, SiteProductFindUniqueArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteProductFindUniqueOrThrowArgs} args - Arguments to find a SiteProduct
     * @example
     * // Get one SiteProduct
     * const siteProduct = await prisma.siteProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductFindFirstArgs} args - Arguments to find a SiteProduct
     * @example
     * // Get one SiteProduct
     * const siteProduct = await prisma.siteProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteProductFindFirstArgs>(args?: SelectSubset<T, SiteProductFindFirstArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductFindFirstOrThrowArgs} args - Arguments to find a SiteProduct
     * @example
     * // Get one SiteProduct
     * const siteProduct = await prisma.siteProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteProducts
     * const siteProducts = await prisma.siteProduct.findMany()
     * 
     * // Get first 10 SiteProducts
     * const siteProducts = await prisma.siteProduct.findMany({ take: 10 })
     * 
     * // Only select the `siteId`
     * const siteProductWithSiteIdOnly = await prisma.siteProduct.findMany({ select: { siteId: true } })
     * 
     */
    findMany<T extends SiteProductFindManyArgs>(args?: SelectSubset<T, SiteProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteProduct.
     * @param {SiteProductCreateArgs} args - Arguments to create a SiteProduct.
     * @example
     * // Create one SiteProduct
     * const SiteProduct = await prisma.siteProduct.create({
     *   data: {
     *     // ... data to create a SiteProduct
     *   }
     * })
     * 
     */
    create<T extends SiteProductCreateArgs>(args: SelectSubset<T, SiteProductCreateArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteProducts.
     * @param {SiteProductCreateManyArgs} args - Arguments to create many SiteProducts.
     * @example
     * // Create many SiteProducts
     * const siteProduct = await prisma.siteProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteProductCreateManyArgs>(args?: SelectSubset<T, SiteProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteProducts and returns the data saved in the database.
     * @param {SiteProductCreateManyAndReturnArgs} args - Arguments to create many SiteProducts.
     * @example
     * // Create many SiteProducts
     * const siteProduct = await prisma.siteProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteProducts and only return the `siteId`
     * const siteProductWithSiteIdOnly = await prisma.siteProduct.createManyAndReturn({
     *   select: { siteId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteProduct.
     * @param {SiteProductDeleteArgs} args - Arguments to delete one SiteProduct.
     * @example
     * // Delete one SiteProduct
     * const SiteProduct = await prisma.siteProduct.delete({
     *   where: {
     *     // ... filter to delete one SiteProduct
     *   }
     * })
     * 
     */
    delete<T extends SiteProductDeleteArgs>(args: SelectSubset<T, SiteProductDeleteArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteProduct.
     * @param {SiteProductUpdateArgs} args - Arguments to update one SiteProduct.
     * @example
     * // Update one SiteProduct
     * const siteProduct = await prisma.siteProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteProductUpdateArgs>(args: SelectSubset<T, SiteProductUpdateArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteProducts.
     * @param {SiteProductDeleteManyArgs} args - Arguments to filter SiteProducts to delete.
     * @example
     * // Delete a few SiteProducts
     * const { count } = await prisma.siteProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteProductDeleteManyArgs>(args?: SelectSubset<T, SiteProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteProducts
     * const siteProduct = await prisma.siteProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteProductUpdateManyArgs>(args: SelectSubset<T, SiteProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteProducts and returns the data updated in the database.
     * @param {SiteProductUpdateManyAndReturnArgs} args - Arguments to update many SiteProducts.
     * @example
     * // Update many SiteProducts
     * const siteProduct = await prisma.siteProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteProducts and only return the `siteId`
     * const siteProductWithSiteIdOnly = await prisma.siteProduct.updateManyAndReturn({
     *   select: { siteId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteProduct.
     * @param {SiteProductUpsertArgs} args - Arguments to update or create a SiteProduct.
     * @example
     * // Update or create a SiteProduct
     * const siteProduct = await prisma.siteProduct.upsert({
     *   create: {
     *     // ... data to create a SiteProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteProduct we want to update
     *   }
     * })
     */
    upsert<T extends SiteProductUpsertArgs>(args: SelectSubset<T, SiteProductUpsertArgs<ExtArgs>>): Prisma__SiteProductClient<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductCountArgs} args - Arguments to filter SiteProducts to count.
     * @example
     * // Count the number of SiteProducts
     * const count = await prisma.siteProduct.count({
     *   where: {
     *     // ... the filter for the SiteProducts we want to count
     *   }
     * })
    **/
    count<T extends SiteProductCountArgs>(
      args?: Subset<T, SiteProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteProductAggregateArgs>(args: Subset<T, SiteProductAggregateArgs>): Prisma.PrismaPromise<GetSiteProductAggregateType<T>>

    /**
     * Group by SiteProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteProductGroupByArgs['orderBy'] }
        : { orderBy?: SiteProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteProduct model
   */
  readonly fields: SiteProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends SiteProduct$categoryArgs<ExtArgs> = {}>(args?: Subset<T, SiteProduct$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteProduct model
   */
  interface SiteProductFieldRefs {
    readonly siteId: FieldRef<"SiteProduct", 'String'>
    readonly productId: FieldRef<"SiteProduct", 'String'>
    readonly price: FieldRef<"SiteProduct", 'Decimal'>
    readonly discount: FieldRef<"SiteProduct", 'Decimal'>
    readonly inStock: FieldRef<"SiteProduct", 'Boolean'>
    readonly createdAt: FieldRef<"SiteProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteProduct", 'DateTime'>
    readonly categoryId: FieldRef<"SiteProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SiteProduct findUnique
   */
  export type SiteProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter, which SiteProduct to fetch.
     */
    where: SiteProductWhereUniqueInput
  }

  /**
   * SiteProduct findUniqueOrThrow
   */
  export type SiteProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter, which SiteProduct to fetch.
     */
    where: SiteProductWhereUniqueInput
  }

  /**
   * SiteProduct findFirst
   */
  export type SiteProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter, which SiteProduct to fetch.
     */
    where?: SiteProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteProducts to fetch.
     */
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteProducts.
     */
    cursor?: SiteProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteProducts.
     */
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * SiteProduct findFirstOrThrow
   */
  export type SiteProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter, which SiteProduct to fetch.
     */
    where?: SiteProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteProducts to fetch.
     */
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteProducts.
     */
    cursor?: SiteProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteProducts.
     */
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * SiteProduct findMany
   */
  export type SiteProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter, which SiteProducts to fetch.
     */
    where?: SiteProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteProducts to fetch.
     */
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteProducts.
     */
    cursor?: SiteProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteProducts.
     */
    skip?: number
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * SiteProduct create
   */
  export type SiteProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteProduct.
     */
    data: XOR<SiteProductCreateInput, SiteProductUncheckedCreateInput>
  }

  /**
   * SiteProduct createMany
   */
  export type SiteProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteProducts.
     */
    data: SiteProductCreateManyInput | SiteProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteProduct createManyAndReturn
   */
  export type SiteProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * The data used to create many SiteProducts.
     */
    data: SiteProductCreateManyInput | SiteProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteProduct update
   */
  export type SiteProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteProduct.
     */
    data: XOR<SiteProductUpdateInput, SiteProductUncheckedUpdateInput>
    /**
     * Choose, which SiteProduct to update.
     */
    where: SiteProductWhereUniqueInput
  }

  /**
   * SiteProduct updateMany
   */
  export type SiteProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteProducts.
     */
    data: XOR<SiteProductUpdateManyMutationInput, SiteProductUncheckedUpdateManyInput>
    /**
     * Filter which SiteProducts to update
     */
    where?: SiteProductWhereInput
    /**
     * Limit how many SiteProducts to update.
     */
    limit?: number
  }

  /**
   * SiteProduct updateManyAndReturn
   */
  export type SiteProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * The data used to update SiteProducts.
     */
    data: XOR<SiteProductUpdateManyMutationInput, SiteProductUncheckedUpdateManyInput>
    /**
     * Filter which SiteProducts to update
     */
    where?: SiteProductWhereInput
    /**
     * Limit how many SiteProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteProduct upsert
   */
  export type SiteProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteProduct to update in case it exists.
     */
    where: SiteProductWhereUniqueInput
    /**
     * In case the SiteProduct found by the `where` argument doesn't exist, create a new SiteProduct with this data.
     */
    create: XOR<SiteProductCreateInput, SiteProductUncheckedCreateInput>
    /**
     * In case the SiteProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteProductUpdateInput, SiteProductUncheckedUpdateInput>
  }

  /**
   * SiteProduct delete
   */
  export type SiteProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    /**
     * Filter which SiteProduct to delete.
     */
    where: SiteProductWhereUniqueInput
  }

  /**
   * SiteProduct deleteMany
   */
  export type SiteProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteProducts to delete
     */
    where?: SiteProductWhereInput
    /**
     * Limit how many SiteProducts to delete.
     */
    limit?: number
  }

  /**
   * SiteProduct.category
   */
  export type SiteProduct$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * SiteProduct without action
   */
  export type SiteProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductCustomField
   */

  export type AggregateProductCustomField = {
    _count: ProductCustomFieldCountAggregateOutputType | null
    _avg: ProductCustomFieldAvgAggregateOutputType | null
    _sum: ProductCustomFieldSumAggregateOutputType | null
    _min: ProductCustomFieldMinAggregateOutputType | null
    _max: ProductCustomFieldMaxAggregateOutputType | null
  }

  export type ProductCustomFieldAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProductCustomFieldSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProductCustomFieldMinAggregateOutputType = {
    id: string | null
    productId: string | null
    siteId: string | null
    fieldName: string | null
    fieldType: string | null
    fieldValue: string | null
    displayOrder: number | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCustomFieldMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    siteId: string | null
    fieldName: string | null
    fieldType: string | null
    fieldValue: string | null
    displayOrder: number | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCustomFieldCountAggregateOutputType = {
    id: number
    productId: number
    siteId: number
    fieldName: number
    fieldType: number
    fieldValue: number
    displayOrder: number
    isRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCustomFieldAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ProductCustomFieldSumAggregateInputType = {
    displayOrder?: true
  }

  export type ProductCustomFieldMinAggregateInputType = {
    id?: true
    productId?: true
    siteId?: true
    fieldName?: true
    fieldType?: true
    fieldValue?: true
    displayOrder?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCustomFieldMaxAggregateInputType = {
    id?: true
    productId?: true
    siteId?: true
    fieldName?: true
    fieldType?: true
    fieldValue?: true
    displayOrder?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCustomFieldCountAggregateInputType = {
    id?: true
    productId?: true
    siteId?: true
    fieldName?: true
    fieldType?: true
    fieldValue?: true
    displayOrder?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCustomField to aggregate.
     */
    where?: ProductCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomFields to fetch.
     */
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCustomFields
    **/
    _count?: true | ProductCustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCustomFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCustomFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCustomFieldMaxAggregateInputType
  }

  export type GetProductCustomFieldAggregateType<T extends ProductCustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCustomField[P]>
      : GetScalarType<T[P], AggregateProductCustomField[P]>
  }




  export type ProductCustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCustomFieldWhereInput
    orderBy?: ProductCustomFieldOrderByWithAggregationInput | ProductCustomFieldOrderByWithAggregationInput[]
    by: ProductCustomFieldScalarFieldEnum[] | ProductCustomFieldScalarFieldEnum
    having?: ProductCustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCustomFieldCountAggregateInputType | true
    _avg?: ProductCustomFieldAvgAggregateInputType
    _sum?: ProductCustomFieldSumAggregateInputType
    _min?: ProductCustomFieldMinAggregateInputType
    _max?: ProductCustomFieldMaxAggregateInputType
  }

  export type ProductCustomFieldGroupByOutputType = {
    id: string
    productId: string
    siteId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder: number
    isRequired: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProductCustomFieldCountAggregateOutputType | null
    _avg: ProductCustomFieldAvgAggregateOutputType | null
    _sum: ProductCustomFieldSumAggregateOutputType | null
    _min: ProductCustomFieldMinAggregateOutputType | null
    _max: ProductCustomFieldMaxAggregateOutputType | null
  }

  type GetProductCustomFieldGroupByPayload<T extends ProductCustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type ProductCustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    siteId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    fieldValue?: boolean
    displayOrder?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCustomField"]>

  export type ProductCustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    siteId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    fieldValue?: boolean
    displayOrder?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCustomField"]>

  export type ProductCustomFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    siteId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    fieldValue?: boolean
    displayOrder?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCustomField"]>

  export type ProductCustomFieldSelectScalar = {
    id?: boolean
    productId?: boolean
    siteId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    fieldValue?: boolean
    displayOrder?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "siteId" | "fieldName" | "fieldType" | "fieldValue" | "displayOrder" | "isRequired" | "createdAt" | "updatedAt", ExtArgs["result"]["productCustomField"]>
  export type ProductCustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type ProductCustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type ProductCustomFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $ProductCustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCustomField"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      siteId: string
      fieldName: string
      fieldType: string
      fieldValue: string
      displayOrder: number
      isRequired: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["productCustomField"]>
    composites: {}
  }

  type ProductCustomFieldGetPayload<S extends boolean | null | undefined | ProductCustomFieldDefaultArgs> = $Result.GetResult<Prisma.$ProductCustomFieldPayload, S>

  type ProductCustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCustomFieldCountAggregateInputType | true
    }

  export interface ProductCustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCustomField'], meta: { name: 'ProductCustomField' } }
    /**
     * Find zero or one ProductCustomField that matches the filter.
     * @param {ProductCustomFieldFindUniqueArgs} args - Arguments to find a ProductCustomField
     * @example
     * // Get one ProductCustomField
     * const productCustomField = await prisma.productCustomField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCustomFieldFindUniqueArgs>(args: SelectSubset<T, ProductCustomFieldFindUniqueArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCustomFieldFindUniqueOrThrowArgs} args - Arguments to find a ProductCustomField
     * @example
     * // Get one ProductCustomField
     * const productCustomField = await prisma.productCustomField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldFindFirstArgs} args - Arguments to find a ProductCustomField
     * @example
     * // Get one ProductCustomField
     * const productCustomField = await prisma.productCustomField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCustomFieldFindFirstArgs>(args?: SelectSubset<T, ProductCustomFieldFindFirstArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldFindFirstOrThrowArgs} args - Arguments to find a ProductCustomField
     * @example
     * // Get one ProductCustomField
     * const productCustomField = await prisma.productCustomField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCustomFields
     * const productCustomFields = await prisma.productCustomField.findMany()
     * 
     * // Get first 10 ProductCustomFields
     * const productCustomFields = await prisma.productCustomField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCustomFieldWithIdOnly = await prisma.productCustomField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCustomFieldFindManyArgs>(args?: SelectSubset<T, ProductCustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCustomField.
     * @param {ProductCustomFieldCreateArgs} args - Arguments to create a ProductCustomField.
     * @example
     * // Create one ProductCustomField
     * const ProductCustomField = await prisma.productCustomField.create({
     *   data: {
     *     // ... data to create a ProductCustomField
     *   }
     * })
     * 
     */
    create<T extends ProductCustomFieldCreateArgs>(args: SelectSubset<T, ProductCustomFieldCreateArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCustomFields.
     * @param {ProductCustomFieldCreateManyArgs} args - Arguments to create many ProductCustomFields.
     * @example
     * // Create many ProductCustomFields
     * const productCustomField = await prisma.productCustomField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCustomFieldCreateManyArgs>(args?: SelectSubset<T, ProductCustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCustomFields and returns the data saved in the database.
     * @param {ProductCustomFieldCreateManyAndReturnArgs} args - Arguments to create many ProductCustomFields.
     * @example
     * // Create many ProductCustomFields
     * const productCustomField = await prisma.productCustomField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCustomFields and only return the `id`
     * const productCustomFieldWithIdOnly = await prisma.productCustomField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCustomField.
     * @param {ProductCustomFieldDeleteArgs} args - Arguments to delete one ProductCustomField.
     * @example
     * // Delete one ProductCustomField
     * const ProductCustomField = await prisma.productCustomField.delete({
     *   where: {
     *     // ... filter to delete one ProductCustomField
     *   }
     * })
     * 
     */
    delete<T extends ProductCustomFieldDeleteArgs>(args: SelectSubset<T, ProductCustomFieldDeleteArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCustomField.
     * @param {ProductCustomFieldUpdateArgs} args - Arguments to update one ProductCustomField.
     * @example
     * // Update one ProductCustomField
     * const productCustomField = await prisma.productCustomField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCustomFieldUpdateArgs>(args: SelectSubset<T, ProductCustomFieldUpdateArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCustomFields.
     * @param {ProductCustomFieldDeleteManyArgs} args - Arguments to filter ProductCustomFields to delete.
     * @example
     * // Delete a few ProductCustomFields
     * const { count } = await prisma.productCustomField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCustomFieldDeleteManyArgs>(args?: SelectSubset<T, ProductCustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCustomFields
     * const productCustomField = await prisma.productCustomField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCustomFieldUpdateManyArgs>(args: SelectSubset<T, ProductCustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCustomFields and returns the data updated in the database.
     * @param {ProductCustomFieldUpdateManyAndReturnArgs} args - Arguments to update many ProductCustomFields.
     * @example
     * // Update many ProductCustomFields
     * const productCustomField = await prisma.productCustomField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCustomFields and only return the `id`
     * const productCustomFieldWithIdOnly = await prisma.productCustomField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCustomFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCustomFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCustomField.
     * @param {ProductCustomFieldUpsertArgs} args - Arguments to update or create a ProductCustomField.
     * @example
     * // Update or create a ProductCustomField
     * const productCustomField = await prisma.productCustomField.upsert({
     *   create: {
     *     // ... data to create a ProductCustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCustomField we want to update
     *   }
     * })
     */
    upsert<T extends ProductCustomFieldUpsertArgs>(args: SelectSubset<T, ProductCustomFieldUpsertArgs<ExtArgs>>): Prisma__ProductCustomFieldClient<$Result.GetResult<Prisma.$ProductCustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldCountArgs} args - Arguments to filter ProductCustomFields to count.
     * @example
     * // Count the number of ProductCustomFields
     * const count = await prisma.productCustomField.count({
     *   where: {
     *     // ... the filter for the ProductCustomFields we want to count
     *   }
     * })
    **/
    count<T extends ProductCustomFieldCountArgs>(
      args?: Subset<T, ProductCustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCustomFieldAggregateArgs>(args: Subset<T, ProductCustomFieldAggregateArgs>): Prisma.PrismaPromise<GetProductCustomFieldAggregateType<T>>

    /**
     * Group by ProductCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: ProductCustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCustomField model
   */
  readonly fields: ProductCustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCustomField model
   */
  interface ProductCustomFieldFieldRefs {
    readonly id: FieldRef<"ProductCustomField", 'String'>
    readonly productId: FieldRef<"ProductCustomField", 'String'>
    readonly siteId: FieldRef<"ProductCustomField", 'String'>
    readonly fieldName: FieldRef<"ProductCustomField", 'String'>
    readonly fieldType: FieldRef<"ProductCustomField", 'String'>
    readonly fieldValue: FieldRef<"ProductCustomField", 'String'>
    readonly displayOrder: FieldRef<"ProductCustomField", 'Int'>
    readonly isRequired: FieldRef<"ProductCustomField", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCustomField", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCustomField findUnique
   */
  export type ProductCustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomField to fetch.
     */
    where: ProductCustomFieldWhereUniqueInput
  }

  /**
   * ProductCustomField findUniqueOrThrow
   */
  export type ProductCustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomField to fetch.
     */
    where: ProductCustomFieldWhereUniqueInput
  }

  /**
   * ProductCustomField findFirst
   */
  export type ProductCustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomField to fetch.
     */
    where?: ProductCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomFields to fetch.
     */
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCustomFields.
     */
    cursor?: ProductCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCustomFields.
     */
    distinct?: ProductCustomFieldScalarFieldEnum | ProductCustomFieldScalarFieldEnum[]
  }

  /**
   * ProductCustomField findFirstOrThrow
   */
  export type ProductCustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomField to fetch.
     */
    where?: ProductCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomFields to fetch.
     */
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCustomFields.
     */
    cursor?: ProductCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCustomFields.
     */
    distinct?: ProductCustomFieldScalarFieldEnum | ProductCustomFieldScalarFieldEnum[]
  }

  /**
   * ProductCustomField findMany
   */
  export type ProductCustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomFields to fetch.
     */
    where?: ProductCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomFields to fetch.
     */
    orderBy?: ProductCustomFieldOrderByWithRelationInput | ProductCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCustomFields.
     */
    cursor?: ProductCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomFields.
     */
    skip?: number
    distinct?: ProductCustomFieldScalarFieldEnum | ProductCustomFieldScalarFieldEnum[]
  }

  /**
   * ProductCustomField create
   */
  export type ProductCustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCustomField.
     */
    data: XOR<ProductCustomFieldCreateInput, ProductCustomFieldUncheckedCreateInput>
  }

  /**
   * ProductCustomField createMany
   */
  export type ProductCustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCustomFields.
     */
    data: ProductCustomFieldCreateManyInput | ProductCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCustomField createManyAndReturn
   */
  export type ProductCustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCustomFields.
     */
    data: ProductCustomFieldCreateManyInput | ProductCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCustomField update
   */
  export type ProductCustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCustomField.
     */
    data: XOR<ProductCustomFieldUpdateInput, ProductCustomFieldUncheckedUpdateInput>
    /**
     * Choose, which ProductCustomField to update.
     */
    where: ProductCustomFieldWhereUniqueInput
  }

  /**
   * ProductCustomField updateMany
   */
  export type ProductCustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCustomFields.
     */
    data: XOR<ProductCustomFieldUpdateManyMutationInput, ProductCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which ProductCustomFields to update
     */
    where?: ProductCustomFieldWhereInput
    /**
     * Limit how many ProductCustomFields to update.
     */
    limit?: number
  }

  /**
   * ProductCustomField updateManyAndReturn
   */
  export type ProductCustomFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to update ProductCustomFields.
     */
    data: XOR<ProductCustomFieldUpdateManyMutationInput, ProductCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which ProductCustomFields to update
     */
    where?: ProductCustomFieldWhereInput
    /**
     * Limit how many ProductCustomFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCustomField upsert
   */
  export type ProductCustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCustomField to update in case it exists.
     */
    where: ProductCustomFieldWhereUniqueInput
    /**
     * In case the ProductCustomField found by the `where` argument doesn't exist, create a new ProductCustomField with this data.
     */
    create: XOR<ProductCustomFieldCreateInput, ProductCustomFieldUncheckedCreateInput>
    /**
     * In case the ProductCustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCustomFieldUpdateInput, ProductCustomFieldUncheckedUpdateInput>
  }

  /**
   * ProductCustomField delete
   */
  export type ProductCustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
    /**
     * Filter which ProductCustomField to delete.
     */
    where: ProductCustomFieldWhereUniqueInput
  }

  /**
   * ProductCustomField deleteMany
   */
  export type ProductCustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCustomFields to delete
     */
    where?: ProductCustomFieldWhereInput
    /**
     * Limit how many ProductCustomFields to delete.
     */
    limit?: number
  }

  /**
   * ProductCustomField without action
   */
  export type ProductCustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomField
     */
    select?: ProductCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCustomField
     */
    omit?: ProductCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model ProductPriceHistory
   */

  export type AggregateProductPriceHistory = {
    _count: ProductPriceHistoryCountAggregateOutputType | null
    _avg: ProductPriceHistoryAvgAggregateOutputType | null
    _sum: ProductPriceHistorySumAggregateOutputType | null
    _min: ProductPriceHistoryMinAggregateOutputType | null
    _max: ProductPriceHistoryMaxAggregateOutputType | null
  }

  export type ProductPriceHistoryAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ProductPriceHistorySumAggregateOutputType = {
    price: Decimal | null
  }

  export type ProductPriceHistoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    price: Decimal | null
    currency: string | null
    source: string | null
    recordedAt: Date | null
  }

  export type ProductPriceHistoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    price: Decimal | null
    currency: string | null
    source: string | null
    recordedAt: Date | null
  }

  export type ProductPriceHistoryCountAggregateOutputType = {
    id: number
    productId: number
    price: number
    currency: number
    source: number
    recordedAt: number
    _all: number
  }


  export type ProductPriceHistoryAvgAggregateInputType = {
    price?: true
  }

  export type ProductPriceHistorySumAggregateInputType = {
    price?: true
  }

  export type ProductPriceHistoryMinAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    currency?: true
    source?: true
    recordedAt?: true
  }

  export type ProductPriceHistoryMaxAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    currency?: true
    source?: true
    recordedAt?: true
  }

  export type ProductPriceHistoryCountAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    currency?: true
    source?: true
    recordedAt?: true
    _all?: true
  }

  export type ProductPriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPriceHistory to aggregate.
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPriceHistories to fetch.
     */
    orderBy?: ProductPriceHistoryOrderByWithRelationInput | ProductPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPriceHistories
    **/
    _count?: true | ProductPriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductPriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductPriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPriceHistoryMaxAggregateInputType
  }

  export type GetProductPriceHistoryAggregateType<T extends ProductPriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPriceHistory[P]>
      : GetScalarType<T[P], AggregateProductPriceHistory[P]>
  }




  export type ProductPriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPriceHistoryWhereInput
    orderBy?: ProductPriceHistoryOrderByWithAggregationInput | ProductPriceHistoryOrderByWithAggregationInput[]
    by: ProductPriceHistoryScalarFieldEnum[] | ProductPriceHistoryScalarFieldEnum
    having?: ProductPriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPriceHistoryCountAggregateInputType | true
    _avg?: ProductPriceHistoryAvgAggregateInputType
    _sum?: ProductPriceHistorySumAggregateInputType
    _min?: ProductPriceHistoryMinAggregateInputType
    _max?: ProductPriceHistoryMaxAggregateInputType
  }

  export type ProductPriceHistoryGroupByOutputType = {
    id: string
    productId: string
    price: Decimal
    currency: string
    source: string
    recordedAt: Date | null
    _count: ProductPriceHistoryCountAggregateOutputType | null
    _avg: ProductPriceHistoryAvgAggregateOutputType | null
    _sum: ProductPriceHistorySumAggregateOutputType | null
    _min: ProductPriceHistoryMinAggregateOutputType | null
    _max: ProductPriceHistoryMaxAggregateOutputType | null
  }

  type GetProductPriceHistoryGroupByPayload<T extends ProductPriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductPriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    currency?: boolean
    source?: boolean
    recordedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPriceHistory"]>

  export type ProductPriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    currency?: boolean
    source?: boolean
    recordedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPriceHistory"]>

  export type ProductPriceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    currency?: boolean
    source?: boolean
    recordedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPriceHistory"]>

  export type ProductPriceHistorySelectScalar = {
    id?: boolean
    productId?: boolean
    price?: boolean
    currency?: boolean
    source?: boolean
    recordedAt?: boolean
  }

  export type ProductPriceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "price" | "currency" | "source" | "recordedAt", ExtArgs["result"]["productPriceHistory"]>
  export type ProductPriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPriceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductPriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPriceHistory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      price: Prisma.Decimal
      currency: string
      source: string
      recordedAt: Date | null
    }, ExtArgs["result"]["productPriceHistory"]>
    composites: {}
  }

  type ProductPriceHistoryGetPayload<S extends boolean | null | undefined | ProductPriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$ProductPriceHistoryPayload, S>

  type ProductPriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductPriceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductPriceHistoryCountAggregateInputType | true
    }

  export interface ProductPriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPriceHistory'], meta: { name: 'ProductPriceHistory' } }
    /**
     * Find zero or one ProductPriceHistory that matches the filter.
     * @param {ProductPriceHistoryFindUniqueArgs} args - Arguments to find a ProductPriceHistory
     * @example
     * // Get one ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPriceHistoryFindUniqueArgs>(args: SelectSubset<T, ProductPriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductPriceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductPriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a ProductPriceHistory
     * @example
     * // Get one ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryFindFirstArgs} args - Arguments to find a ProductPriceHistory
     * @example
     * // Get one ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPriceHistoryFindFirstArgs>(args?: SelectSubset<T, ProductPriceHistoryFindFirstArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryFindFirstOrThrowArgs} args - Arguments to find a ProductPriceHistory
     * @example
     * // Get one ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductPriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPriceHistories
     * const productPriceHistories = await prisma.productPriceHistory.findMany()
     * 
     * // Get first 10 ProductPriceHistories
     * const productPriceHistories = await prisma.productPriceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPriceHistoryWithIdOnly = await prisma.productPriceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPriceHistoryFindManyArgs>(args?: SelectSubset<T, ProductPriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductPriceHistory.
     * @param {ProductPriceHistoryCreateArgs} args - Arguments to create a ProductPriceHistory.
     * @example
     * // Create one ProductPriceHistory
     * const ProductPriceHistory = await prisma.productPriceHistory.create({
     *   data: {
     *     // ... data to create a ProductPriceHistory
     *   }
     * })
     * 
     */
    create<T extends ProductPriceHistoryCreateArgs>(args: SelectSubset<T, ProductPriceHistoryCreateArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductPriceHistories.
     * @param {ProductPriceHistoryCreateManyArgs} args - Arguments to create many ProductPriceHistories.
     * @example
     * // Create many ProductPriceHistories
     * const productPriceHistory = await prisma.productPriceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPriceHistoryCreateManyArgs>(args?: SelectSubset<T, ProductPriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPriceHistories and returns the data saved in the database.
     * @param {ProductPriceHistoryCreateManyAndReturnArgs} args - Arguments to create many ProductPriceHistories.
     * @example
     * // Create many ProductPriceHistories
     * const productPriceHistory = await prisma.productPriceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPriceHistories and only return the `id`
     * const productPriceHistoryWithIdOnly = await prisma.productPriceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductPriceHistory.
     * @param {ProductPriceHistoryDeleteArgs} args - Arguments to delete one ProductPriceHistory.
     * @example
     * // Delete one ProductPriceHistory
     * const ProductPriceHistory = await prisma.productPriceHistory.delete({
     *   where: {
     *     // ... filter to delete one ProductPriceHistory
     *   }
     * })
     * 
     */
    delete<T extends ProductPriceHistoryDeleteArgs>(args: SelectSubset<T, ProductPriceHistoryDeleteArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductPriceHistory.
     * @param {ProductPriceHistoryUpdateArgs} args - Arguments to update one ProductPriceHistory.
     * @example
     * // Update one ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPriceHistoryUpdateArgs>(args: SelectSubset<T, ProductPriceHistoryUpdateArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductPriceHistories.
     * @param {ProductPriceHistoryDeleteManyArgs} args - Arguments to filter ProductPriceHistories to delete.
     * @example
     * // Delete a few ProductPriceHistories
     * const { count } = await prisma.productPriceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPriceHistoryDeleteManyArgs>(args?: SelectSubset<T, ProductPriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPriceHistories
     * const productPriceHistory = await prisma.productPriceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPriceHistoryUpdateManyArgs>(args: SelectSubset<T, ProductPriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPriceHistories and returns the data updated in the database.
     * @param {ProductPriceHistoryUpdateManyAndReturnArgs} args - Arguments to update many ProductPriceHistories.
     * @example
     * // Update many ProductPriceHistories
     * const productPriceHistory = await prisma.productPriceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductPriceHistories and only return the `id`
     * const productPriceHistoryWithIdOnly = await prisma.productPriceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductPriceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductPriceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductPriceHistory.
     * @param {ProductPriceHistoryUpsertArgs} args - Arguments to update or create a ProductPriceHistory.
     * @example
     * // Update or create a ProductPriceHistory
     * const productPriceHistory = await prisma.productPriceHistory.upsert({
     *   create: {
     *     // ... data to create a ProductPriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends ProductPriceHistoryUpsertArgs>(args: SelectSubset<T, ProductPriceHistoryUpsertArgs<ExtArgs>>): Prisma__ProductPriceHistoryClient<$Result.GetResult<Prisma.$ProductPriceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductPriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryCountArgs} args - Arguments to filter ProductPriceHistories to count.
     * @example
     * // Count the number of ProductPriceHistories
     * const count = await prisma.productPriceHistory.count({
     *   where: {
     *     // ... the filter for the ProductPriceHistories we want to count
     *   }
     * })
    **/
    count<T extends ProductPriceHistoryCountArgs>(
      args?: Subset<T, ProductPriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPriceHistoryAggregateArgs>(args: Subset<T, ProductPriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetProductPriceHistoryAggregateType<T>>

    /**
     * Group by ProductPriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductPriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPriceHistory model
   */
  readonly fields: ProductPriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPriceHistory model
   */
  interface ProductPriceHistoryFieldRefs {
    readonly id: FieldRef<"ProductPriceHistory", 'String'>
    readonly productId: FieldRef<"ProductPriceHistory", 'String'>
    readonly price: FieldRef<"ProductPriceHistory", 'Decimal'>
    readonly currency: FieldRef<"ProductPriceHistory", 'String'>
    readonly source: FieldRef<"ProductPriceHistory", 'String'>
    readonly recordedAt: FieldRef<"ProductPriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPriceHistory findUnique
   */
  export type ProductPriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductPriceHistory to fetch.
     */
    where: ProductPriceHistoryWhereUniqueInput
  }

  /**
   * ProductPriceHistory findUniqueOrThrow
   */
  export type ProductPriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductPriceHistory to fetch.
     */
    where: ProductPriceHistoryWhereUniqueInput
  }

  /**
   * ProductPriceHistory findFirst
   */
  export type ProductPriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductPriceHistory to fetch.
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPriceHistories to fetch.
     */
    orderBy?: ProductPriceHistoryOrderByWithRelationInput | ProductPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPriceHistories.
     */
    cursor?: ProductPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPriceHistories.
     */
    distinct?: ProductPriceHistoryScalarFieldEnum | ProductPriceHistoryScalarFieldEnum[]
  }

  /**
   * ProductPriceHistory findFirstOrThrow
   */
  export type ProductPriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductPriceHistory to fetch.
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPriceHistories to fetch.
     */
    orderBy?: ProductPriceHistoryOrderByWithRelationInput | ProductPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPriceHistories.
     */
    cursor?: ProductPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPriceHistories.
     */
    distinct?: ProductPriceHistoryScalarFieldEnum | ProductPriceHistoryScalarFieldEnum[]
  }

  /**
   * ProductPriceHistory findMany
   */
  export type ProductPriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductPriceHistories to fetch.
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPriceHistories to fetch.
     */
    orderBy?: ProductPriceHistoryOrderByWithRelationInput | ProductPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPriceHistories.
     */
    cursor?: ProductPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPriceHistories.
     */
    skip?: number
    distinct?: ProductPriceHistoryScalarFieldEnum | ProductPriceHistoryScalarFieldEnum[]
  }

  /**
   * ProductPriceHistory create
   */
  export type ProductPriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPriceHistory.
     */
    data: XOR<ProductPriceHistoryCreateInput, ProductPriceHistoryUncheckedCreateInput>
  }

  /**
   * ProductPriceHistory createMany
   */
  export type ProductPriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPriceHistories.
     */
    data: ProductPriceHistoryCreateManyInput | ProductPriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPriceHistory createManyAndReturn
   */
  export type ProductPriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductPriceHistories.
     */
    data: ProductPriceHistoryCreateManyInput | ProductPriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPriceHistory update
   */
  export type ProductPriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPriceHistory.
     */
    data: XOR<ProductPriceHistoryUpdateInput, ProductPriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which ProductPriceHistory to update.
     */
    where: ProductPriceHistoryWhereUniqueInput
  }

  /**
   * ProductPriceHistory updateMany
   */
  export type ProductPriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPriceHistories.
     */
    data: XOR<ProductPriceHistoryUpdateManyMutationInput, ProductPriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductPriceHistories to update
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * Limit how many ProductPriceHistories to update.
     */
    limit?: number
  }

  /**
   * ProductPriceHistory updateManyAndReturn
   */
  export type ProductPriceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductPriceHistories.
     */
    data: XOR<ProductPriceHistoryUpdateManyMutationInput, ProductPriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductPriceHistories to update
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * Limit how many ProductPriceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPriceHistory upsert
   */
  export type ProductPriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPriceHistory to update in case it exists.
     */
    where: ProductPriceHistoryWhereUniqueInput
    /**
     * In case the ProductPriceHistory found by the `where` argument doesn't exist, create a new ProductPriceHistory with this data.
     */
    create: XOR<ProductPriceHistoryCreateInput, ProductPriceHistoryUncheckedCreateInput>
    /**
     * In case the ProductPriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPriceHistoryUpdateInput, ProductPriceHistoryUncheckedUpdateInput>
  }

  /**
   * ProductPriceHistory delete
   */
  export type ProductPriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which ProductPriceHistory to delete.
     */
    where: ProductPriceHistoryWhereUniqueInput
  }

  /**
   * ProductPriceHistory deleteMany
   */
  export type ProductPriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPriceHistories to delete
     */
    where?: ProductPriceHistoryWhereInput
    /**
     * Limit how many ProductPriceHistories to delete.
     */
    limit?: number
  }

  /**
   * ProductPriceHistory without action
   */
  export type ProductPriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPriceHistory
     */
    select?: ProductPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPriceHistory
     */
    omit?: ProductPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PriceAlert
   */

  export type AggregatePriceAlert = {
    _count: PriceAlertCountAggregateOutputType | null
    _avg: PriceAlertAvgAggregateOutputType | null
    _sum: PriceAlertSumAggregateOutputType | null
    _min: PriceAlertMinAggregateOutputType | null
    _max: PriceAlertMaxAggregateOutputType | null
  }

  export type PriceAlertAvgAggregateOutputType = {
    threshold: Decimal | null
  }

  export type PriceAlertSumAggregateOutputType = {
    threshold: Decimal | null
  }

  export type PriceAlertMinAggregateOutputType = {
    id: string | null
    siteId: string | null
    productId: string | null
    alertType: string | null
    threshold: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    triggeredAt: Date | null
  }

  export type PriceAlertMaxAggregateOutputType = {
    id: string | null
    siteId: string | null
    productId: string | null
    alertType: string | null
    threshold: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    triggeredAt: Date | null
  }

  export type PriceAlertCountAggregateOutputType = {
    id: number
    siteId: number
    productId: number
    alertType: number
    threshold: number
    isActive: number
    createdAt: number
    triggeredAt: number
    _all: number
  }


  export type PriceAlertAvgAggregateInputType = {
    threshold?: true
  }

  export type PriceAlertSumAggregateInputType = {
    threshold?: true
  }

  export type PriceAlertMinAggregateInputType = {
    id?: true
    siteId?: true
    productId?: true
    alertType?: true
    threshold?: true
    isActive?: true
    createdAt?: true
    triggeredAt?: true
  }

  export type PriceAlertMaxAggregateInputType = {
    id?: true
    siteId?: true
    productId?: true
    alertType?: true
    threshold?: true
    isActive?: true
    createdAt?: true
    triggeredAt?: true
  }

  export type PriceAlertCountAggregateInputType = {
    id?: true
    siteId?: true
    productId?: true
    alertType?: true
    threshold?: true
    isActive?: true
    createdAt?: true
    triggeredAt?: true
    _all?: true
  }

  export type PriceAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceAlert to aggregate.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceAlerts
    **/
    _count?: true | PriceAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceAlertMaxAggregateInputType
  }

  export type GetPriceAlertAggregateType<T extends PriceAlertAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceAlert[P]>
      : GetScalarType<T[P], AggregatePriceAlert[P]>
  }




  export type PriceAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceAlertWhereInput
    orderBy?: PriceAlertOrderByWithAggregationInput | PriceAlertOrderByWithAggregationInput[]
    by: PriceAlertScalarFieldEnum[] | PriceAlertScalarFieldEnum
    having?: PriceAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceAlertCountAggregateInputType | true
    _avg?: PriceAlertAvgAggregateInputType
    _sum?: PriceAlertSumAggregateInputType
    _min?: PriceAlertMinAggregateInputType
    _max?: PriceAlertMaxAggregateInputType
  }

  export type PriceAlertGroupByOutputType = {
    id: string
    siteId: string
    productId: string
    alertType: string
    threshold: Decimal
    isActive: boolean
    createdAt: Date | null
    triggeredAt: Date | null
    _count: PriceAlertCountAggregateOutputType | null
    _avg: PriceAlertAvgAggregateOutputType | null
    _sum: PriceAlertSumAggregateOutputType | null
    _min: PriceAlertMinAggregateOutputType | null
    _max: PriceAlertMaxAggregateOutputType | null
  }

  type GetPriceAlertGroupByPayload<T extends PriceAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceAlertGroupByOutputType[P]>
            : GetScalarType<T[P], PriceAlertGroupByOutputType[P]>
        }
      >
    >


  export type PriceAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    productId?: boolean
    alertType?: boolean
    threshold?: boolean
    isActive?: boolean
    createdAt?: boolean
    triggeredAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    productId?: boolean
    alertType?: boolean
    threshold?: boolean
    isActive?: boolean
    createdAt?: boolean
    triggeredAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    productId?: boolean
    alertType?: boolean
    threshold?: boolean
    isActive?: boolean
    createdAt?: boolean
    triggeredAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectScalar = {
    id?: boolean
    siteId?: boolean
    productId?: boolean
    alertType?: boolean
    threshold?: boolean
    isActive?: boolean
    createdAt?: boolean
    triggeredAt?: boolean
  }

  export type PriceAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "productId" | "alertType" | "threshold" | "isActive" | "createdAt" | "triggeredAt", ExtArgs["result"]["priceAlert"]>
  export type PriceAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type PriceAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type PriceAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $PriceAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceAlert"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: string
      productId: string
      alertType: string
      threshold: Prisma.Decimal
      isActive: boolean
      createdAt: Date | null
      triggeredAt: Date | null
    }, ExtArgs["result"]["priceAlert"]>
    composites: {}
  }

  type PriceAlertGetPayload<S extends boolean | null | undefined | PriceAlertDefaultArgs> = $Result.GetResult<Prisma.$PriceAlertPayload, S>

  type PriceAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceAlertCountAggregateInputType | true
    }

  export interface PriceAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceAlert'], meta: { name: 'PriceAlert' } }
    /**
     * Find zero or one PriceAlert that matches the filter.
     * @param {PriceAlertFindUniqueArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceAlertFindUniqueArgs>(args: SelectSubset<T, PriceAlertFindUniqueArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceAlertFindUniqueOrThrowArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindFirstArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceAlertFindFirstArgs>(args?: SelectSubset<T, PriceAlertFindFirstArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindFirstOrThrowArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceAlerts
     * const priceAlerts = await prisma.priceAlert.findMany()
     * 
     * // Get first 10 PriceAlerts
     * const priceAlerts = await prisma.priceAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceAlertFindManyArgs>(args?: SelectSubset<T, PriceAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceAlert.
     * @param {PriceAlertCreateArgs} args - Arguments to create a PriceAlert.
     * @example
     * // Create one PriceAlert
     * const PriceAlert = await prisma.priceAlert.create({
     *   data: {
     *     // ... data to create a PriceAlert
     *   }
     * })
     * 
     */
    create<T extends PriceAlertCreateArgs>(args: SelectSubset<T, PriceAlertCreateArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceAlerts.
     * @param {PriceAlertCreateManyArgs} args - Arguments to create many PriceAlerts.
     * @example
     * // Create many PriceAlerts
     * const priceAlert = await prisma.priceAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceAlertCreateManyArgs>(args?: SelectSubset<T, PriceAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceAlerts and returns the data saved in the database.
     * @param {PriceAlertCreateManyAndReturnArgs} args - Arguments to create many PriceAlerts.
     * @example
     * // Create many PriceAlerts
     * const priceAlert = await prisma.priceAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceAlerts and only return the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceAlert.
     * @param {PriceAlertDeleteArgs} args - Arguments to delete one PriceAlert.
     * @example
     * // Delete one PriceAlert
     * const PriceAlert = await prisma.priceAlert.delete({
     *   where: {
     *     // ... filter to delete one PriceAlert
     *   }
     * })
     * 
     */
    delete<T extends PriceAlertDeleteArgs>(args: SelectSubset<T, PriceAlertDeleteArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceAlert.
     * @param {PriceAlertUpdateArgs} args - Arguments to update one PriceAlert.
     * @example
     * // Update one PriceAlert
     * const priceAlert = await prisma.priceAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceAlertUpdateArgs>(args: SelectSubset<T, PriceAlertUpdateArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceAlerts.
     * @param {PriceAlertDeleteManyArgs} args - Arguments to filter PriceAlerts to delete.
     * @example
     * // Delete a few PriceAlerts
     * const { count } = await prisma.priceAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceAlertDeleteManyArgs>(args?: SelectSubset<T, PriceAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceAlerts
     * const priceAlert = await prisma.priceAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceAlertUpdateManyArgs>(args: SelectSubset<T, PriceAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceAlerts and returns the data updated in the database.
     * @param {PriceAlertUpdateManyAndReturnArgs} args - Arguments to update many PriceAlerts.
     * @example
     * // Update many PriceAlerts
     * const priceAlert = await prisma.priceAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceAlerts and only return the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceAlert.
     * @param {PriceAlertUpsertArgs} args - Arguments to update or create a PriceAlert.
     * @example
     * // Update or create a PriceAlert
     * const priceAlert = await prisma.priceAlert.upsert({
     *   create: {
     *     // ... data to create a PriceAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceAlert we want to update
     *   }
     * })
     */
    upsert<T extends PriceAlertUpsertArgs>(args: SelectSubset<T, PriceAlertUpsertArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertCountArgs} args - Arguments to filter PriceAlerts to count.
     * @example
     * // Count the number of PriceAlerts
     * const count = await prisma.priceAlert.count({
     *   where: {
     *     // ... the filter for the PriceAlerts we want to count
     *   }
     * })
    **/
    count<T extends PriceAlertCountArgs>(
      args?: Subset<T, PriceAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAlertAggregateArgs>(args: Subset<T, PriceAlertAggregateArgs>): Prisma.PrismaPromise<GetPriceAlertAggregateType<T>>

    /**
     * Group by PriceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceAlertGroupByArgs['orderBy'] }
        : { orderBy?: PriceAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceAlert model
   */
  readonly fields: PriceAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceAlert model
   */
  interface PriceAlertFieldRefs {
    readonly id: FieldRef<"PriceAlert", 'String'>
    readonly siteId: FieldRef<"PriceAlert", 'String'>
    readonly productId: FieldRef<"PriceAlert", 'String'>
    readonly alertType: FieldRef<"PriceAlert", 'String'>
    readonly threshold: FieldRef<"PriceAlert", 'Decimal'>
    readonly isActive: FieldRef<"PriceAlert", 'Boolean'>
    readonly createdAt: FieldRef<"PriceAlert", 'DateTime'>
    readonly triggeredAt: FieldRef<"PriceAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceAlert findUnique
   */
  export type PriceAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert findUniqueOrThrow
   */
  export type PriceAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert findFirst
   */
  export type PriceAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceAlerts.
     */
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert findFirstOrThrow
   */
  export type PriceAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceAlerts.
     */
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert findMany
   */
  export type PriceAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlerts to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert create
   */
  export type PriceAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceAlert.
     */
    data: XOR<PriceAlertCreateInput, PriceAlertUncheckedCreateInput>
  }

  /**
   * PriceAlert createMany
   */
  export type PriceAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceAlerts.
     */
    data: PriceAlertCreateManyInput | PriceAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceAlert createManyAndReturn
   */
  export type PriceAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * The data used to create many PriceAlerts.
     */
    data: PriceAlertCreateManyInput | PriceAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceAlert update
   */
  export type PriceAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceAlert.
     */
    data: XOR<PriceAlertUpdateInput, PriceAlertUncheckedUpdateInput>
    /**
     * Choose, which PriceAlert to update.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert updateMany
   */
  export type PriceAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceAlerts.
     */
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyInput>
    /**
     * Filter which PriceAlerts to update
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to update.
     */
    limit?: number
  }

  /**
   * PriceAlert updateManyAndReturn
   */
  export type PriceAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * The data used to update PriceAlerts.
     */
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyInput>
    /**
     * Filter which PriceAlerts to update
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceAlert upsert
   */
  export type PriceAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceAlert to update in case it exists.
     */
    where: PriceAlertWhereUniqueInput
    /**
     * In case the PriceAlert found by the `where` argument doesn't exist, create a new PriceAlert with this data.
     */
    create: XOR<PriceAlertCreateInput, PriceAlertUncheckedCreateInput>
    /**
     * In case the PriceAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceAlertUpdateInput, PriceAlertUncheckedUpdateInput>
  }

  /**
   * PriceAlert delete
   */
  export type PriceAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter which PriceAlert to delete.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert deleteMany
   */
  export type PriceAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceAlerts to delete
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to delete.
     */
    limit?: number
  }

  /**
   * PriceAlert without action
   */
  export type PriceAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
  }


  /**
   * Model InteractiveQuiz
   */

  export type AggregateInteractiveQuiz = {
    _count: InteractiveQuizCountAggregateOutputType | null
    _min: InteractiveQuizMinAggregateOutputType | null
    _max: InteractiveQuizMaxAggregateOutputType | null
  }

  export type InteractiveQuizMinAggregateOutputType = {
    id: string | null
    siteId: string | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InteractiveQuizMaxAggregateOutputType = {
    id: string | null
    siteId: string | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InteractiveQuizCountAggregateOutputType = {
    id: number
    siteId: number
    title: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InteractiveQuizMinAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InteractiveQuizMaxAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InteractiveQuizCountAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InteractiveQuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractiveQuiz to aggregate.
     */
    where?: InteractiveQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractiveQuizs to fetch.
     */
    orderBy?: InteractiveQuizOrderByWithRelationInput | InteractiveQuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractiveQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractiveQuizs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractiveQuizs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteractiveQuizs
    **/
    _count?: true | InteractiveQuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractiveQuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractiveQuizMaxAggregateInputType
  }

  export type GetInteractiveQuizAggregateType<T extends InteractiveQuizAggregateArgs> = {
        [P in keyof T & keyof AggregateInteractiveQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteractiveQuiz[P]>
      : GetScalarType<T[P], AggregateInteractiveQuiz[P]>
  }




  export type InteractiveQuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractiveQuizWhereInput
    orderBy?: InteractiveQuizOrderByWithAggregationInput | InteractiveQuizOrderByWithAggregationInput[]
    by: InteractiveQuizScalarFieldEnum[] | InteractiveQuizScalarFieldEnum
    having?: InteractiveQuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractiveQuizCountAggregateInputType | true
    _min?: InteractiveQuizMinAggregateInputType
    _max?: InteractiveQuizMaxAggregateInputType
  }

  export type InteractiveQuizGroupByOutputType = {
    id: string
    siteId: string
    title: string
    description: string | null
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: InteractiveQuizCountAggregateOutputType | null
    _min: InteractiveQuizMinAggregateOutputType | null
    _max: InteractiveQuizMaxAggregateOutputType | null
  }

  type GetInteractiveQuizGroupByPayload<T extends InteractiveQuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractiveQuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractiveQuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractiveQuizGroupByOutputType[P]>
            : GetScalarType<T[P], InteractiveQuizGroupByOutputType[P]>
        }
      >
    >


  export type InteractiveQuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
    questions?: boolean | InteractiveQuiz$questionsArgs<ExtArgs>
    results?: boolean | InteractiveQuiz$resultsArgs<ExtArgs>
    _count?: boolean | InteractiveQuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactiveQuiz"]>

  export type InteractiveQuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactiveQuiz"]>

  export type InteractiveQuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactiveQuiz"]>

  export type InteractiveQuizSelectScalar = {
    id?: boolean
    siteId?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InteractiveQuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "title" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["interactiveQuiz"]>
  export type InteractiveQuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
    questions?: boolean | InteractiveQuiz$questionsArgs<ExtArgs>
    results?: boolean | InteractiveQuiz$resultsArgs<ExtArgs>
    _count?: boolean | InteractiveQuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InteractiveQuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type InteractiveQuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $InteractiveQuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteractiveQuiz"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      results: Prisma.$QuizResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: string
      title: string
      description: string | null
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["interactiveQuiz"]>
    composites: {}
  }

  type InteractiveQuizGetPayload<S extends boolean | null | undefined | InteractiveQuizDefaultArgs> = $Result.GetResult<Prisma.$InteractiveQuizPayload, S>

  type InteractiveQuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractiveQuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractiveQuizCountAggregateInputType | true
    }

  export interface InteractiveQuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteractiveQuiz'], meta: { name: 'InteractiveQuiz' } }
    /**
     * Find zero or one InteractiveQuiz that matches the filter.
     * @param {InteractiveQuizFindUniqueArgs} args - Arguments to find a InteractiveQuiz
     * @example
     * // Get one InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractiveQuizFindUniqueArgs>(args: SelectSubset<T, InteractiveQuizFindUniqueArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InteractiveQuiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractiveQuizFindUniqueOrThrowArgs} args - Arguments to find a InteractiveQuiz
     * @example
     * // Get one InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractiveQuizFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractiveQuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractiveQuiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizFindFirstArgs} args - Arguments to find a InteractiveQuiz
     * @example
     * // Get one InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractiveQuizFindFirstArgs>(args?: SelectSubset<T, InteractiveQuizFindFirstArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractiveQuiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizFindFirstOrThrowArgs} args - Arguments to find a InteractiveQuiz
     * @example
     * // Get one InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractiveQuizFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractiveQuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InteractiveQuizs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteractiveQuizs
     * const interactiveQuizs = await prisma.interactiveQuiz.findMany()
     * 
     * // Get first 10 InteractiveQuizs
     * const interactiveQuizs = await prisma.interactiveQuiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactiveQuizWithIdOnly = await prisma.interactiveQuiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractiveQuizFindManyArgs>(args?: SelectSubset<T, InteractiveQuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InteractiveQuiz.
     * @param {InteractiveQuizCreateArgs} args - Arguments to create a InteractiveQuiz.
     * @example
     * // Create one InteractiveQuiz
     * const InteractiveQuiz = await prisma.interactiveQuiz.create({
     *   data: {
     *     // ... data to create a InteractiveQuiz
     *   }
     * })
     * 
     */
    create<T extends InteractiveQuizCreateArgs>(args: SelectSubset<T, InteractiveQuizCreateArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InteractiveQuizs.
     * @param {InteractiveQuizCreateManyArgs} args - Arguments to create many InteractiveQuizs.
     * @example
     * // Create many InteractiveQuizs
     * const interactiveQuiz = await prisma.interactiveQuiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractiveQuizCreateManyArgs>(args?: SelectSubset<T, InteractiveQuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteractiveQuizs and returns the data saved in the database.
     * @param {InteractiveQuizCreateManyAndReturnArgs} args - Arguments to create many InteractiveQuizs.
     * @example
     * // Create many InteractiveQuizs
     * const interactiveQuiz = await prisma.interactiveQuiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteractiveQuizs and only return the `id`
     * const interactiveQuizWithIdOnly = await prisma.interactiveQuiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractiveQuizCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractiveQuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InteractiveQuiz.
     * @param {InteractiveQuizDeleteArgs} args - Arguments to delete one InteractiveQuiz.
     * @example
     * // Delete one InteractiveQuiz
     * const InteractiveQuiz = await prisma.interactiveQuiz.delete({
     *   where: {
     *     // ... filter to delete one InteractiveQuiz
     *   }
     * })
     * 
     */
    delete<T extends InteractiveQuizDeleteArgs>(args: SelectSubset<T, InteractiveQuizDeleteArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InteractiveQuiz.
     * @param {InteractiveQuizUpdateArgs} args - Arguments to update one InteractiveQuiz.
     * @example
     * // Update one InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractiveQuizUpdateArgs>(args: SelectSubset<T, InteractiveQuizUpdateArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InteractiveQuizs.
     * @param {InteractiveQuizDeleteManyArgs} args - Arguments to filter InteractiveQuizs to delete.
     * @example
     * // Delete a few InteractiveQuizs
     * const { count } = await prisma.interactiveQuiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractiveQuizDeleteManyArgs>(args?: SelectSubset<T, InteractiveQuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractiveQuizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteractiveQuizs
     * const interactiveQuiz = await prisma.interactiveQuiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractiveQuizUpdateManyArgs>(args: SelectSubset<T, InteractiveQuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractiveQuizs and returns the data updated in the database.
     * @param {InteractiveQuizUpdateManyAndReturnArgs} args - Arguments to update many InteractiveQuizs.
     * @example
     * // Update many InteractiveQuizs
     * const interactiveQuiz = await prisma.interactiveQuiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InteractiveQuizs and only return the `id`
     * const interactiveQuizWithIdOnly = await prisma.interactiveQuiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractiveQuizUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractiveQuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InteractiveQuiz.
     * @param {InteractiveQuizUpsertArgs} args - Arguments to update or create a InteractiveQuiz.
     * @example
     * // Update or create a InteractiveQuiz
     * const interactiveQuiz = await prisma.interactiveQuiz.upsert({
     *   create: {
     *     // ... data to create a InteractiveQuiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteractiveQuiz we want to update
     *   }
     * })
     */
    upsert<T extends InteractiveQuizUpsertArgs>(args: SelectSubset<T, InteractiveQuizUpsertArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InteractiveQuizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizCountArgs} args - Arguments to filter InteractiveQuizs to count.
     * @example
     * // Count the number of InteractiveQuizs
     * const count = await prisma.interactiveQuiz.count({
     *   where: {
     *     // ... the filter for the InteractiveQuizs we want to count
     *   }
     * })
    **/
    count<T extends InteractiveQuizCountArgs>(
      args?: Subset<T, InteractiveQuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractiveQuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteractiveQuiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractiveQuizAggregateArgs>(args: Subset<T, InteractiveQuizAggregateArgs>): Prisma.PrismaPromise<GetInteractiveQuizAggregateType<T>>

    /**
     * Group by InteractiveQuiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractiveQuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractiveQuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractiveQuizGroupByArgs['orderBy'] }
        : { orderBy?: InteractiveQuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractiveQuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractiveQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteractiveQuiz model
   */
  readonly fields: InteractiveQuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteractiveQuiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractiveQuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends InteractiveQuiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, InteractiveQuiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    results<T extends InteractiveQuiz$resultsArgs<ExtArgs> = {}>(args?: Subset<T, InteractiveQuiz$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteractiveQuiz model
   */
  interface InteractiveQuizFieldRefs {
    readonly id: FieldRef<"InteractiveQuiz", 'String'>
    readonly siteId: FieldRef<"InteractiveQuiz", 'String'>
    readonly title: FieldRef<"InteractiveQuiz", 'String'>
    readonly description: FieldRef<"InteractiveQuiz", 'String'>
    readonly isActive: FieldRef<"InteractiveQuiz", 'Boolean'>
    readonly createdAt: FieldRef<"InteractiveQuiz", 'DateTime'>
    readonly updatedAt: FieldRef<"InteractiveQuiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InteractiveQuiz findUnique
   */
  export type InteractiveQuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter, which InteractiveQuiz to fetch.
     */
    where: InteractiveQuizWhereUniqueInput
  }

  /**
   * InteractiveQuiz findUniqueOrThrow
   */
  export type InteractiveQuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter, which InteractiveQuiz to fetch.
     */
    where: InteractiveQuizWhereUniqueInput
  }

  /**
   * InteractiveQuiz findFirst
   */
  export type InteractiveQuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter, which InteractiveQuiz to fetch.
     */
    where?: InteractiveQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractiveQuizs to fetch.
     */
    orderBy?: InteractiveQuizOrderByWithRelationInput | InteractiveQuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractiveQuizs.
     */
    cursor?: InteractiveQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractiveQuizs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractiveQuizs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractiveQuizs.
     */
    distinct?: InteractiveQuizScalarFieldEnum | InteractiveQuizScalarFieldEnum[]
  }

  /**
   * InteractiveQuiz findFirstOrThrow
   */
  export type InteractiveQuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter, which InteractiveQuiz to fetch.
     */
    where?: InteractiveQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractiveQuizs to fetch.
     */
    orderBy?: InteractiveQuizOrderByWithRelationInput | InteractiveQuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractiveQuizs.
     */
    cursor?: InteractiveQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractiveQuizs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractiveQuizs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractiveQuizs.
     */
    distinct?: InteractiveQuizScalarFieldEnum | InteractiveQuizScalarFieldEnum[]
  }

  /**
   * InteractiveQuiz findMany
   */
  export type InteractiveQuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter, which InteractiveQuizs to fetch.
     */
    where?: InteractiveQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractiveQuizs to fetch.
     */
    orderBy?: InteractiveQuizOrderByWithRelationInput | InteractiveQuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteractiveQuizs.
     */
    cursor?: InteractiveQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractiveQuizs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractiveQuizs.
     */
    skip?: number
    distinct?: InteractiveQuizScalarFieldEnum | InteractiveQuizScalarFieldEnum[]
  }

  /**
   * InteractiveQuiz create
   */
  export type InteractiveQuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * The data needed to create a InteractiveQuiz.
     */
    data: XOR<InteractiveQuizCreateInput, InteractiveQuizUncheckedCreateInput>
  }

  /**
   * InteractiveQuiz createMany
   */
  export type InteractiveQuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteractiveQuizs.
     */
    data: InteractiveQuizCreateManyInput | InteractiveQuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteractiveQuiz createManyAndReturn
   */
  export type InteractiveQuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * The data used to create many InteractiveQuizs.
     */
    data: InteractiveQuizCreateManyInput | InteractiveQuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractiveQuiz update
   */
  export type InteractiveQuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * The data needed to update a InteractiveQuiz.
     */
    data: XOR<InteractiveQuizUpdateInput, InteractiveQuizUncheckedUpdateInput>
    /**
     * Choose, which InteractiveQuiz to update.
     */
    where: InteractiveQuizWhereUniqueInput
  }

  /**
   * InteractiveQuiz updateMany
   */
  export type InteractiveQuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteractiveQuizs.
     */
    data: XOR<InteractiveQuizUpdateManyMutationInput, InteractiveQuizUncheckedUpdateManyInput>
    /**
     * Filter which InteractiveQuizs to update
     */
    where?: InteractiveQuizWhereInput
    /**
     * Limit how many InteractiveQuizs to update.
     */
    limit?: number
  }

  /**
   * InteractiveQuiz updateManyAndReturn
   */
  export type InteractiveQuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * The data used to update InteractiveQuizs.
     */
    data: XOR<InteractiveQuizUpdateManyMutationInput, InteractiveQuizUncheckedUpdateManyInput>
    /**
     * Filter which InteractiveQuizs to update
     */
    where?: InteractiveQuizWhereInput
    /**
     * Limit how many InteractiveQuizs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractiveQuiz upsert
   */
  export type InteractiveQuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * The filter to search for the InteractiveQuiz to update in case it exists.
     */
    where: InteractiveQuizWhereUniqueInput
    /**
     * In case the InteractiveQuiz found by the `where` argument doesn't exist, create a new InteractiveQuiz with this data.
     */
    create: XOR<InteractiveQuizCreateInput, InteractiveQuizUncheckedCreateInput>
    /**
     * In case the InteractiveQuiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractiveQuizUpdateInput, InteractiveQuizUncheckedUpdateInput>
  }

  /**
   * InteractiveQuiz delete
   */
  export type InteractiveQuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
    /**
     * Filter which InteractiveQuiz to delete.
     */
    where: InteractiveQuizWhereUniqueInput
  }

  /**
   * InteractiveQuiz deleteMany
   */
  export type InteractiveQuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractiveQuizs to delete
     */
    where?: InteractiveQuizWhereInput
    /**
     * Limit how many InteractiveQuizs to delete.
     */
    limit?: number
  }

  /**
   * InteractiveQuiz.questions
   */
  export type InteractiveQuiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * InteractiveQuiz.results
   */
  export type InteractiveQuiz$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    where?: QuizResultWhereInput
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    cursor?: QuizResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * InteractiveQuiz without action
   */
  export type InteractiveQuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractiveQuiz
     */
    select?: InteractiveQuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractiveQuiz
     */
    omit?: InteractiveQuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractiveQuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    question: string | null
    questionType: string | null
    order: number | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    question: string | null
    questionType: string | null
    order: number | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    question: number
    questionType: number
    order: number
    isRequired: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    order?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    order?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    questionType?: true
    order?: true
    isRequired?: true
    createdAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    questionType?: true
    order?: true
    isRequired?: true
    createdAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    questionType?: true
    order?: true
    isRequired?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    quizId: string
    question: string
    questionType: string
    order: number
    isRequired: boolean
    createdAt: Date | null
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    questionType?: boolean
    order?: boolean
    isRequired?: boolean
    createdAt?: boolean
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    questionType?: boolean
    order?: boolean
    isRequired?: boolean
    createdAt?: boolean
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    questionType?: boolean
    order?: boolean
    isRequired?: boolean
    createdAt?: boolean
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    question?: boolean
    questionType?: boolean
    order?: boolean
    isRequired?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "question" | "questionType" | "order" | "isRequired" | "createdAt", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      answers: Prisma.$QuizAnswerPayload<ExtArgs>[]
      options: Prisma.$QuizQuestionOptionPayload<ExtArgs>[]
      quiz: Prisma.$InteractiveQuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      question: string
      questionType: string
      order: number
      isRequired: boolean
      createdAt: Date | null
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends QuizQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends QuizQuestion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz<T extends InteractiveQuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InteractiveQuizDefaultArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly quizId: FieldRef<"QuizQuestion", 'String'>
    readonly question: FieldRef<"QuizQuestion", 'String'>
    readonly questionType: FieldRef<"QuizQuestion", 'String'>
    readonly order: FieldRef<"QuizQuestion", 'Int'>
    readonly isRequired: FieldRef<"QuizQuestion", 'Boolean'>
    readonly createdAt: FieldRef<"QuizQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion.answers
   */
  export type QuizQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizQuestion.options
   */
  export type QuizQuestion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    where?: QuizQuestionOptionWhereInput
    orderBy?: QuizQuestionOptionOrderByWithRelationInput | QuizQuestionOptionOrderByWithRelationInput[]
    cursor?: QuizQuestionOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionOptionScalarFieldEnum | QuizQuestionOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestionOption
   */

  export type AggregateQuizQuestionOption = {
    _count: QuizQuestionOptionCountAggregateOutputType | null
    _avg: QuizQuestionOptionAvgAggregateOutputType | null
    _sum: QuizQuestionOptionSumAggregateOutputType | null
    _min: QuizQuestionOptionMinAggregateOutputType | null
    _max: QuizQuestionOptionMaxAggregateOutputType | null
  }

  export type QuizQuestionOptionAvgAggregateOutputType = {
    order: number | null
  }

  export type QuizQuestionOptionSumAggregateOutputType = {
    order: number | null
  }

  export type QuizQuestionOptionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    optionText: string | null
    optionValue: string | null
    order: number | null
    createdAt: Date | null
  }

  export type QuizQuestionOptionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    optionText: string | null
    optionValue: string | null
    order: number | null
    createdAt: Date | null
  }

  export type QuizQuestionOptionCountAggregateOutputType = {
    id: number
    questionId: number
    optionText: number
    optionValue: number
    order: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionOptionAvgAggregateInputType = {
    order?: true
  }

  export type QuizQuestionOptionSumAggregateInputType = {
    order?: true
  }

  export type QuizQuestionOptionMinAggregateInputType = {
    id?: true
    questionId?: true
    optionText?: true
    optionValue?: true
    order?: true
    createdAt?: true
  }

  export type QuizQuestionOptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    optionText?: true
    optionValue?: true
    order?: true
    createdAt?: true
  }

  export type QuizQuestionOptionCountAggregateInputType = {
    id?: true
    questionId?: true
    optionText?: true
    optionValue?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionOption to aggregate.
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionOptions to fetch.
     */
    orderBy?: QuizQuestionOptionOrderByWithRelationInput | QuizQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestionOptions
    **/
    _count?: true | QuizQuestionOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionOptionMaxAggregateInputType
  }

  export type GetQuizQuestionOptionAggregateType<T extends QuizQuestionOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestionOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestionOption[P]>
      : GetScalarType<T[P], AggregateQuizQuestionOption[P]>
  }




  export type QuizQuestionOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionOptionWhereInput
    orderBy?: QuizQuestionOptionOrderByWithAggregationInput | QuizQuestionOptionOrderByWithAggregationInput[]
    by: QuizQuestionOptionScalarFieldEnum[] | QuizQuestionOptionScalarFieldEnum
    having?: QuizQuestionOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionOptionCountAggregateInputType | true
    _avg?: QuizQuestionOptionAvgAggregateInputType
    _sum?: QuizQuestionOptionSumAggregateInputType
    _min?: QuizQuestionOptionMinAggregateInputType
    _max?: QuizQuestionOptionMaxAggregateInputType
  }

  export type QuizQuestionOptionGroupByOutputType = {
    id: string
    questionId: string
    optionText: string
    optionValue: string
    order: number
    createdAt: Date | null
    _count: QuizQuestionOptionCountAggregateOutputType | null
    _avg: QuizQuestionOptionAvgAggregateOutputType | null
    _sum: QuizQuestionOptionSumAggregateOutputType | null
    _min: QuizQuestionOptionMinAggregateOutputType | null
    _max: QuizQuestionOptionMaxAggregateOutputType | null
  }

  type GetQuizQuestionOptionGroupByPayload<T extends QuizQuestionOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionOptionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionOptionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    optionText?: boolean
    optionValue?: boolean
    order?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionOption"]>

  export type QuizQuestionOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    optionText?: boolean
    optionValue?: boolean
    order?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionOption"]>

  export type QuizQuestionOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    optionText?: boolean
    optionValue?: boolean
    order?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionOption"]>

  export type QuizQuestionOptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    optionText?: boolean
    optionValue?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "optionText" | "optionValue" | "order" | "createdAt", ExtArgs["result"]["quizQuestionOption"]>
  export type QuizQuestionOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizQuestionOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizQuestionOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestionOption"
    objects: {
      question: Prisma.$QuizQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      optionText: string
      optionValue: string
      order: number
      createdAt: Date | null
    }, ExtArgs["result"]["quizQuestionOption"]>
    composites: {}
  }

  type QuizQuestionOptionGetPayload<S extends boolean | null | undefined | QuizQuestionOptionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionOptionPayload, S>

  type QuizQuestionOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionOptionCountAggregateInputType | true
    }

  export interface QuizQuestionOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestionOption'], meta: { name: 'QuizQuestionOption' } }
    /**
     * Find zero or one QuizQuestionOption that matches the filter.
     * @param {QuizQuestionOptionFindUniqueArgs} args - Arguments to find a QuizQuestionOption
     * @example
     * // Get one QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionOptionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionOptionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestionOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionOptionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestionOption
     * @example
     * // Get one QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionFindFirstArgs} args - Arguments to find a QuizQuestionOption
     * @example
     * // Get one QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionOptionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionOptionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestionOption
     * @example
     * // Get one QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestionOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestionOptions
     * const quizQuestionOptions = await prisma.quizQuestionOption.findMany()
     * 
     * // Get first 10 QuizQuestionOptions
     * const quizQuestionOptions = await prisma.quizQuestionOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionOptionWithIdOnly = await prisma.quizQuestionOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionOptionFindManyArgs>(args?: SelectSubset<T, QuizQuestionOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestionOption.
     * @param {QuizQuestionOptionCreateArgs} args - Arguments to create a QuizQuestionOption.
     * @example
     * // Create one QuizQuestionOption
     * const QuizQuestionOption = await prisma.quizQuestionOption.create({
     *   data: {
     *     // ... data to create a QuizQuestionOption
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionOptionCreateArgs>(args: SelectSubset<T, QuizQuestionOptionCreateArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestionOptions.
     * @param {QuizQuestionOptionCreateManyArgs} args - Arguments to create many QuizQuestionOptions.
     * @example
     * // Create many QuizQuestionOptions
     * const quizQuestionOption = await prisma.quizQuestionOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionOptionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestionOptions and returns the data saved in the database.
     * @param {QuizQuestionOptionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestionOptions.
     * @example
     * // Create many QuizQuestionOptions
     * const quizQuestionOption = await prisma.quizQuestionOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestionOptions and only return the `id`
     * const quizQuestionOptionWithIdOnly = await prisma.quizQuestionOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestionOption.
     * @param {QuizQuestionOptionDeleteArgs} args - Arguments to delete one QuizQuestionOption.
     * @example
     * // Delete one QuizQuestionOption
     * const QuizQuestionOption = await prisma.quizQuestionOption.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestionOption
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionOptionDeleteArgs>(args: SelectSubset<T, QuizQuestionOptionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestionOption.
     * @param {QuizQuestionOptionUpdateArgs} args - Arguments to update one QuizQuestionOption.
     * @example
     * // Update one QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionOptionUpdateArgs>(args: SelectSubset<T, QuizQuestionOptionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestionOptions.
     * @param {QuizQuestionOptionDeleteManyArgs} args - Arguments to filter QuizQuestionOptions to delete.
     * @example
     * // Delete a few QuizQuestionOptions
     * const { count } = await prisma.quizQuestionOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionOptionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestionOptions
     * const quizQuestionOption = await prisma.quizQuestionOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionOptionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionOptions and returns the data updated in the database.
     * @param {QuizQuestionOptionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestionOptions.
     * @example
     * // Update many QuizQuestionOptions
     * const quizQuestionOption = await prisma.quizQuestionOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestionOptions and only return the `id`
     * const quizQuestionOptionWithIdOnly = await prisma.quizQuestionOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestionOption.
     * @param {QuizQuestionOptionUpsertArgs} args - Arguments to update or create a QuizQuestionOption.
     * @example
     * // Update or create a QuizQuestionOption
     * const quizQuestionOption = await prisma.quizQuestionOption.upsert({
     *   create: {
     *     // ... data to create a QuizQuestionOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestionOption we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionOptionUpsertArgs>(args: SelectSubset<T, QuizQuestionOptionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionOptionClient<$Result.GetResult<Prisma.$QuizQuestionOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionCountArgs} args - Arguments to filter QuizQuestionOptions to count.
     * @example
     * // Count the number of QuizQuestionOptions
     * const count = await prisma.quizQuestionOption.count({
     *   where: {
     *     // ... the filter for the QuizQuestionOptions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionOptionCountArgs>(
      args?: Subset<T, QuizQuestionOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionOptionAggregateArgs>(args: Subset<T, QuizQuestionOptionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionOptionAggregateType<T>>

    /**
     * Group by QuizQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionOptionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestionOption model
   */
  readonly fields: QuizQuestionOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestionOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestionOption model
   */
  interface QuizQuestionOptionFieldRefs {
    readonly id: FieldRef<"QuizQuestionOption", 'String'>
    readonly questionId: FieldRef<"QuizQuestionOption", 'String'>
    readonly optionText: FieldRef<"QuizQuestionOption", 'String'>
    readonly optionValue: FieldRef<"QuizQuestionOption", 'String'>
    readonly order: FieldRef<"QuizQuestionOption", 'Int'>
    readonly createdAt: FieldRef<"QuizQuestionOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestionOption findUnique
   */
  export type QuizQuestionOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionOption to fetch.
     */
    where: QuizQuestionOptionWhereUniqueInput
  }

  /**
   * QuizQuestionOption findUniqueOrThrow
   */
  export type QuizQuestionOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionOption to fetch.
     */
    where: QuizQuestionOptionWhereUniqueInput
  }

  /**
   * QuizQuestionOption findFirst
   */
  export type QuizQuestionOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionOption to fetch.
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionOptions to fetch.
     */
    orderBy?: QuizQuestionOptionOrderByWithRelationInput | QuizQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionOptions.
     */
    cursor?: QuizQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionOptions.
     */
    distinct?: QuizQuestionOptionScalarFieldEnum | QuizQuestionOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestionOption findFirstOrThrow
   */
  export type QuizQuestionOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionOption to fetch.
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionOptions to fetch.
     */
    orderBy?: QuizQuestionOptionOrderByWithRelationInput | QuizQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionOptions.
     */
    cursor?: QuizQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionOptions.
     */
    distinct?: QuizQuestionOptionScalarFieldEnum | QuizQuestionOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestionOption findMany
   */
  export type QuizQuestionOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionOptions to fetch.
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionOptions to fetch.
     */
    orderBy?: QuizQuestionOptionOrderByWithRelationInput | QuizQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestionOptions.
     */
    cursor?: QuizQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionOptions.
     */
    skip?: number
    distinct?: QuizQuestionOptionScalarFieldEnum | QuizQuestionOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestionOption create
   */
  export type QuizQuestionOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestionOption.
     */
    data: XOR<QuizQuestionOptionCreateInput, QuizQuestionOptionUncheckedCreateInput>
  }

  /**
   * QuizQuestionOption createMany
   */
  export type QuizQuestionOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestionOptions.
     */
    data: QuizQuestionOptionCreateManyInput | QuizQuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestionOption createManyAndReturn
   */
  export type QuizQuestionOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestionOptions.
     */
    data: QuizQuestionOptionCreateManyInput | QuizQuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionOption update
   */
  export type QuizQuestionOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestionOption.
     */
    data: XOR<QuizQuestionOptionUpdateInput, QuizQuestionOptionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestionOption to update.
     */
    where: QuizQuestionOptionWhereUniqueInput
  }

  /**
   * QuizQuestionOption updateMany
   */
  export type QuizQuestionOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestionOptions.
     */
    data: XOR<QuizQuestionOptionUpdateManyMutationInput, QuizQuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionOptions to update
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * Limit how many QuizQuestionOptions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestionOption updateManyAndReturn
   */
  export type QuizQuestionOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestionOptions.
     */
    data: XOR<QuizQuestionOptionUpdateManyMutationInput, QuizQuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionOptions to update
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * Limit how many QuizQuestionOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionOption upsert
   */
  export type QuizQuestionOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestionOption to update in case it exists.
     */
    where: QuizQuestionOptionWhereUniqueInput
    /**
     * In case the QuizQuestionOption found by the `where` argument doesn't exist, create a new QuizQuestionOption with this data.
     */
    create: XOR<QuizQuestionOptionCreateInput, QuizQuestionOptionUncheckedCreateInput>
    /**
     * In case the QuizQuestionOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionOptionUpdateInput, QuizQuestionOptionUncheckedUpdateInput>
  }

  /**
   * QuizQuestionOption delete
   */
  export type QuizQuestionOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestionOption to delete.
     */
    where: QuizQuestionOptionWhereUniqueInput
  }

  /**
   * QuizQuestionOption deleteMany
   */
  export type QuizQuestionOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionOptions to delete
     */
    where?: QuizQuestionOptionWhereInput
    /**
     * Limit how many QuizQuestionOptions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestionOption without action
   */
  export type QuizQuestionOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionOption
     */
    select?: QuizQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionOption
     */
    omit?: QuizQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionOptionInclude<ExtArgs> | null
  }


  /**
   * Model QuizResult
   */

  export type AggregateQuizResult = {
    _count: QuizResultCountAggregateOutputType | null
    _min: QuizResultMinAggregateOutputType | null
    _max: QuizResultMaxAggregateOutputType | null
  }

  export type QuizResultMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    sessionId: string | null
    completedAt: Date | null
  }

  export type QuizResultMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    sessionId: string | null
    completedAt: Date | null
  }

  export type QuizResultCountAggregateOutputType = {
    id: number
    quizId: number
    sessionId: number
    answers: number
    recommendations: number
    completedAt: number
    _all: number
  }


  export type QuizResultMinAggregateInputType = {
    id?: true
    quizId?: true
    sessionId?: true
    completedAt?: true
  }

  export type QuizResultMaxAggregateInputType = {
    id?: true
    quizId?: true
    sessionId?: true
    completedAt?: true
  }

  export type QuizResultCountAggregateInputType = {
    id?: true
    quizId?: true
    sessionId?: true
    answers?: true
    recommendations?: true
    completedAt?: true
    _all?: true
  }

  export type QuizResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResult to aggregate.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizResults
    **/
    _count?: true | QuizResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizResultMaxAggregateInputType
  }

  export type GetQuizResultAggregateType<T extends QuizResultAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizResult[P]>
      : GetScalarType<T[P], AggregateQuizResult[P]>
  }




  export type QuizResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResultWhereInput
    orderBy?: QuizResultOrderByWithAggregationInput | QuizResultOrderByWithAggregationInput[]
    by: QuizResultScalarFieldEnum[] | QuizResultScalarFieldEnum
    having?: QuizResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizResultCountAggregateInputType | true
    _min?: QuizResultMinAggregateInputType
    _max?: QuizResultMaxAggregateInputType
  }

  export type QuizResultGroupByOutputType = {
    id: string
    quizId: string
    sessionId: string
    answers: JsonValue
    recommendations: JsonValue | null
    completedAt: Date | null
    _count: QuizResultCountAggregateOutputType | null
    _min: QuizResultMinAggregateOutputType | null
    _max: QuizResultMaxAggregateOutputType | null
  }

  type GetQuizResultGroupByPayload<T extends QuizResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizResultGroupByOutputType[P]>
            : GetScalarType<T[P], QuizResultGroupByOutputType[P]>
        }
      >
    >


  export type QuizResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sessionId?: boolean
    answers?: boolean
    recommendations?: boolean
    completedAt?: boolean
    quizAnswers?: boolean | QuizResult$quizAnswersArgs<ExtArgs>
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
    _count?: boolean | QuizResultCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sessionId?: boolean
    answers?: boolean
    recommendations?: boolean
    completedAt?: boolean
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sessionId?: boolean
    answers?: boolean
    recommendations?: boolean
    completedAt?: boolean
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectScalar = {
    id?: boolean
    quizId?: boolean
    sessionId?: boolean
    answers?: boolean
    recommendations?: boolean
    completedAt?: boolean
  }

  export type QuizResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "sessionId" | "answers" | "recommendations" | "completedAt", ExtArgs["result"]["quizResult"]>
  export type QuizResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAnswers?: boolean | QuizResult$quizAnswersArgs<ExtArgs>
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
    _count?: boolean | QuizResultCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }
  export type QuizResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | InteractiveQuizDefaultArgs<ExtArgs>
  }

  export type $QuizResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizResult"
    objects: {
      quizAnswers: Prisma.$QuizAnswerPayload<ExtArgs>[]
      quiz: Prisma.$InteractiveQuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      sessionId: string
      answers: Prisma.JsonValue
      recommendations: Prisma.JsonValue | null
      completedAt: Date | null
    }, ExtArgs["result"]["quizResult"]>
    composites: {}
  }

  type QuizResultGetPayload<S extends boolean | null | undefined | QuizResultDefaultArgs> = $Result.GetResult<Prisma.$QuizResultPayload, S>

  type QuizResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizResultCountAggregateInputType | true
    }

  export interface QuizResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizResult'], meta: { name: 'QuizResult' } }
    /**
     * Find zero or one QuizResult that matches the filter.
     * @param {QuizResultFindUniqueArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizResultFindUniqueArgs>(args: SelectSubset<T, QuizResultFindUniqueArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizResultFindUniqueOrThrowArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizResultFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindFirstArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizResultFindFirstArgs>(args?: SelectSubset<T, QuizResultFindFirstArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindFirstOrThrowArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizResultFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizResults
     * const quizResults = await prisma.quizResult.findMany()
     * 
     * // Get first 10 QuizResults
     * const quizResults = await prisma.quizResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizResultFindManyArgs>(args?: SelectSubset<T, QuizResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizResult.
     * @param {QuizResultCreateArgs} args - Arguments to create a QuizResult.
     * @example
     * // Create one QuizResult
     * const QuizResult = await prisma.quizResult.create({
     *   data: {
     *     // ... data to create a QuizResult
     *   }
     * })
     * 
     */
    create<T extends QuizResultCreateArgs>(args: SelectSubset<T, QuizResultCreateArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizResults.
     * @param {QuizResultCreateManyArgs} args - Arguments to create many QuizResults.
     * @example
     * // Create many QuizResults
     * const quizResult = await prisma.quizResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizResultCreateManyArgs>(args?: SelectSubset<T, QuizResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizResults and returns the data saved in the database.
     * @param {QuizResultCreateManyAndReturnArgs} args - Arguments to create many QuizResults.
     * @example
     * // Create many QuizResults
     * const quizResult = await prisma.quizResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizResults and only return the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizResultCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizResult.
     * @param {QuizResultDeleteArgs} args - Arguments to delete one QuizResult.
     * @example
     * // Delete one QuizResult
     * const QuizResult = await prisma.quizResult.delete({
     *   where: {
     *     // ... filter to delete one QuizResult
     *   }
     * })
     * 
     */
    delete<T extends QuizResultDeleteArgs>(args: SelectSubset<T, QuizResultDeleteArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizResult.
     * @param {QuizResultUpdateArgs} args - Arguments to update one QuizResult.
     * @example
     * // Update one QuizResult
     * const quizResult = await prisma.quizResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizResultUpdateArgs>(args: SelectSubset<T, QuizResultUpdateArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizResults.
     * @param {QuizResultDeleteManyArgs} args - Arguments to filter QuizResults to delete.
     * @example
     * // Delete a few QuizResults
     * const { count } = await prisma.quizResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizResultDeleteManyArgs>(args?: SelectSubset<T, QuizResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizResults
     * const quizResult = await prisma.quizResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizResultUpdateManyArgs>(args: SelectSubset<T, QuizResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResults and returns the data updated in the database.
     * @param {QuizResultUpdateManyAndReturnArgs} args - Arguments to update many QuizResults.
     * @example
     * // Update many QuizResults
     * const quizResult = await prisma.quizResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizResults and only return the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizResultUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizResult.
     * @param {QuizResultUpsertArgs} args - Arguments to update or create a QuizResult.
     * @example
     * // Update or create a QuizResult
     * const quizResult = await prisma.quizResult.upsert({
     *   create: {
     *     // ... data to create a QuizResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizResult we want to update
     *   }
     * })
     */
    upsert<T extends QuizResultUpsertArgs>(args: SelectSubset<T, QuizResultUpsertArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultCountArgs} args - Arguments to filter QuizResults to count.
     * @example
     * // Count the number of QuizResults
     * const count = await prisma.quizResult.count({
     *   where: {
     *     // ... the filter for the QuizResults we want to count
     *   }
     * })
    **/
    count<T extends QuizResultCountArgs>(
      args?: Subset<T, QuizResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizResultAggregateArgs>(args: Subset<T, QuizResultAggregateArgs>): Prisma.PrismaPromise<GetQuizResultAggregateType<T>>

    /**
     * Group by QuizResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizResultGroupByArgs['orderBy'] }
        : { orderBy?: QuizResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizResult model
   */
  readonly fields: QuizResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizAnswers<T extends QuizResult$quizAnswersArgs<ExtArgs> = {}>(args?: Subset<T, QuizResult$quizAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz<T extends InteractiveQuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InteractiveQuizDefaultArgs<ExtArgs>>): Prisma__InteractiveQuizClient<$Result.GetResult<Prisma.$InteractiveQuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizResult model
   */
  interface QuizResultFieldRefs {
    readonly id: FieldRef<"QuizResult", 'String'>
    readonly quizId: FieldRef<"QuizResult", 'String'>
    readonly sessionId: FieldRef<"QuizResult", 'String'>
    readonly answers: FieldRef<"QuizResult", 'Json'>
    readonly recommendations: FieldRef<"QuizResult", 'Json'>
    readonly completedAt: FieldRef<"QuizResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizResult findUnique
   */
  export type QuizResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult findUniqueOrThrow
   */
  export type QuizResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult findFirst
   */
  export type QuizResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResults.
     */
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult findFirstOrThrow
   */
  export type QuizResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResults.
     */
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult findMany
   */
  export type QuizResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter, which QuizResults to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult create
   */
  export type QuizResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizResult.
     */
    data: XOR<QuizResultCreateInput, QuizResultUncheckedCreateInput>
  }

  /**
   * QuizResult createMany
   */
  export type QuizResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizResults.
     */
    data: QuizResultCreateManyInput | QuizResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizResult createManyAndReturn
   */
  export type QuizResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data used to create many QuizResults.
     */
    data: QuizResultCreateManyInput | QuizResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResult update
   */
  export type QuizResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizResult.
     */
    data: XOR<QuizResultUpdateInput, QuizResultUncheckedUpdateInput>
    /**
     * Choose, which QuizResult to update.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult updateMany
   */
  export type QuizResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizResults.
     */
    data: XOR<QuizResultUpdateManyMutationInput, QuizResultUncheckedUpdateManyInput>
    /**
     * Filter which QuizResults to update
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to update.
     */
    limit?: number
  }

  /**
   * QuizResult updateManyAndReturn
   */
  export type QuizResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data used to update QuizResults.
     */
    data: XOR<QuizResultUpdateManyMutationInput, QuizResultUncheckedUpdateManyInput>
    /**
     * Filter which QuizResults to update
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResult upsert
   */
  export type QuizResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizResult to update in case it exists.
     */
    where: QuizResultWhereUniqueInput
    /**
     * In case the QuizResult found by the `where` argument doesn't exist, create a new QuizResult with this data.
     */
    create: XOR<QuizResultCreateInput, QuizResultUncheckedCreateInput>
    /**
     * In case the QuizResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizResultUpdateInput, QuizResultUncheckedUpdateInput>
  }

  /**
   * QuizResult delete
   */
  export type QuizResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
    /**
     * Filter which QuizResult to delete.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult deleteMany
   */
  export type QuizResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResults to delete
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to delete.
     */
    limit?: number
  }

  /**
   * QuizResult.quizAnswers
   */
  export type QuizResult$quizAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizResult without action
   */
  export type QuizResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResultInclude<ExtArgs> | null
  }


  /**
   * Model QuizAnswer
   */

  export type AggregateQuizAnswer = {
    _count: QuizAnswerCountAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  export type QuizAnswerMinAggregateOutputType = {
    id: string | null
    resultId: string | null
    questionId: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type QuizAnswerMaxAggregateOutputType = {
    id: string | null
    resultId: string | null
    questionId: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type QuizAnswerCountAggregateOutputType = {
    id: number
    resultId: number
    questionId: number
    answer: number
    createdAt: number
    _all: number
  }


  export type QuizAnswerMinAggregateInputType = {
    id?: true
    resultId?: true
    questionId?: true
    answer?: true
    createdAt?: true
  }

  export type QuizAnswerMaxAggregateInputType = {
    id?: true
    resultId?: true
    questionId?: true
    answer?: true
    createdAt?: true
  }

  export type QuizAnswerCountAggregateInputType = {
    id?: true
    resultId?: true
    questionId?: true
    answer?: true
    createdAt?: true
    _all?: true
  }

  export type QuizAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswer to aggregate.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAnswers
    **/
    _count?: true | QuizAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type GetQuizAnswerAggregateType<T extends QuizAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAnswer[P]>
      : GetScalarType<T[P], AggregateQuizAnswer[P]>
  }




  export type QuizAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithAggregationInput | QuizAnswerOrderByWithAggregationInput[]
    by: QuizAnswerScalarFieldEnum[] | QuizAnswerScalarFieldEnum
    having?: QuizAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAnswerCountAggregateInputType | true
    _min?: QuizAnswerMinAggregateInputType
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type QuizAnswerGroupByOutputType = {
    id: string
    resultId: string
    questionId: string
    answer: string
    createdAt: Date | null
    _count: QuizAnswerCountAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  type GetQuizAnswerGroupByPayload<T extends QuizAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuizAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resultId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resultId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resultId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectScalar = {
    id?: boolean
    resultId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
  }

  export type QuizAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resultId" | "questionId" | "answer" | "createdAt", ExtArgs["result"]["quizAnswer"]>
  export type QuizAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    result?: boolean | QuizResultDefaultArgs<ExtArgs>
  }

  export type $QuizAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAnswer"
    objects: {
      question: Prisma.$QuizQuestionPayload<ExtArgs>
      result: Prisma.$QuizResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resultId: string
      questionId: string
      answer: string
      createdAt: Date | null
    }, ExtArgs["result"]["quizAnswer"]>
    composites: {}
  }

  type QuizAnswerGetPayload<S extends boolean | null | undefined | QuizAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuizAnswerPayload, S>

  type QuizAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAnswerCountAggregateInputType | true
    }

  export interface QuizAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAnswer'], meta: { name: 'QuizAnswer' } }
    /**
     * Find zero or one QuizAnswer that matches the filter.
     * @param {QuizAnswerFindUniqueArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAnswerFindUniqueArgs>(args: SelectSubset<T, QuizAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAnswerFindFirstArgs>(args?: SelectSubset<T, QuizAnswerFindFirstArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany()
     * 
     * // Get first 10 QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAnswerFindManyArgs>(args?: SelectSubset<T, QuizAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAnswer.
     * @param {QuizAnswerCreateArgs} args - Arguments to create a QuizAnswer.
     * @example
     * // Create one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.create({
     *   data: {
     *     // ... data to create a QuizAnswer
     *   }
     * })
     * 
     */
    create<T extends QuizAnswerCreateArgs>(args: SelectSubset<T, QuizAnswerCreateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAnswers.
     * @param {QuizAnswerCreateManyArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAnswerCreateManyArgs>(args?: SelectSubset<T, QuizAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAnswers and returns the data saved in the database.
     * @param {QuizAnswerCreateManyAndReturnArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAnswer.
     * @param {QuizAnswerDeleteArgs} args - Arguments to delete one QuizAnswer.
     * @example
     * // Delete one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuizAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuizAnswerDeleteArgs>(args: SelectSubset<T, QuizAnswerDeleteArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAnswer.
     * @param {QuizAnswerUpdateArgs} args - Arguments to update one QuizAnswer.
     * @example
     * // Update one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAnswerUpdateArgs>(args: SelectSubset<T, QuizAnswerUpdateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAnswers.
     * @param {QuizAnswerDeleteManyArgs} args - Arguments to filter QuizAnswers to delete.
     * @example
     * // Delete a few QuizAnswers
     * const { count } = await prisma.quizAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAnswerDeleteManyArgs>(args?: SelectSubset<T, QuizAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAnswerUpdateManyArgs>(args: SelectSubset<T, QuizAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers and returns the data updated in the database.
     * @param {QuizAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuizAnswers.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAnswer.
     * @param {QuizAnswerUpsertArgs} args - Arguments to update or create a QuizAnswer.
     * @example
     * // Update or create a QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.upsert({
     *   create: {
     *     // ... data to create a QuizAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuizAnswerUpsertArgs>(args: SelectSubset<T, QuizAnswerUpsertArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerCountArgs} args - Arguments to filter QuizAnswers to count.
     * @example
     * // Count the number of QuizAnswers
     * const count = await prisma.quizAnswer.count({
     *   where: {
     *     // ... the filter for the QuizAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuizAnswerCountArgs>(
      args?: Subset<T, QuizAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAnswerAggregateArgs>(args: Subset<T, QuizAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuizAnswerAggregateType<T>>

    /**
     * Group by QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuizAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAnswer model
   */
  readonly fields: QuizAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    result<T extends QuizResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizResultDefaultArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAnswer model
   */
  interface QuizAnswerFieldRefs {
    readonly id: FieldRef<"QuizAnswer", 'String'>
    readonly resultId: FieldRef<"QuizAnswer", 'String'>
    readonly questionId: FieldRef<"QuizAnswer", 'String'>
    readonly answer: FieldRef<"QuizAnswer", 'String'>
    readonly createdAt: FieldRef<"QuizAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAnswer findUnique
   */
  export type QuizAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findUniqueOrThrow
   */
  export type QuizAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findFirst
   */
  export type QuizAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findFirstOrThrow
   */
  export type QuizAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findMany
   */
  export type QuizAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswers to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer create
   */
  export type QuizAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAnswer.
     */
    data: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
  }

  /**
   * QuizAnswer createMany
   */
  export type QuizAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAnswer createManyAndReturn
   */
  export type QuizAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer update
   */
  export type QuizAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAnswer.
     */
    data: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuizAnswer to update.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer updateMany
   */
  export type QuizAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
  }

  /**
   * QuizAnswer updateManyAndReturn
   */
  export type QuizAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer upsert
   */
  export type QuizAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAnswer to update in case it exists.
     */
    where: QuizAnswerWhereUniqueInput
    /**
     * In case the QuizAnswer found by the `where` argument doesn't exist, create a new QuizAnswer with this data.
     */
    create: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
    /**
     * In case the QuizAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
  }

  /**
   * QuizAnswer delete
   */
  export type QuizAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuizAnswer to delete.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer deleteMany
   */
  export type QuizAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswers to delete
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuizAnswer without action
   */
  export type QuizAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateLink
   */

  export type AggregateAffiliateLink = {
    _count: AffiliateLinkCountAggregateOutputType | null
    _min: AffiliateLinkMinAggregateOutputType | null
    _max: AffiliateLinkMaxAggregateOutputType | null
  }

  export type AffiliateLinkMinAggregateOutputType = {
    id: string | null
    name: string | null
    originalUrl: string | null
    affiliateUrl: string | null
    siteId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
    merchantId: string | null
    displayText: string | null
    trackingId: string | null
    status: string | null
    expirationDate: Date | null
  }

  export type AffiliateLinkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    originalUrl: string | null
    affiliateUrl: string | null
    siteId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
    merchantId: string | null
    displayText: string | null
    trackingId: string | null
    status: string | null
    expirationDate: Date | null
  }

  export type AffiliateLinkCountAggregateOutputType = {
    id: number
    name: number
    originalUrl: number
    affiliateUrl: number
    siteId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    productId: number
    merchantId: number
    displayText: number
    trackingId: number
    status: number
    commissionInfo: number
    expirationDate: number
    _all: number
  }


  export type AffiliateLinkMinAggregateInputType = {
    id?: true
    name?: true
    originalUrl?: true
    affiliateUrl?: true
    siteId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    merchantId?: true
    displayText?: true
    trackingId?: true
    status?: true
    expirationDate?: true
  }

  export type AffiliateLinkMaxAggregateInputType = {
    id?: true
    name?: true
    originalUrl?: true
    affiliateUrl?: true
    siteId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    merchantId?: true
    displayText?: true
    trackingId?: true
    status?: true
    expirationDate?: true
  }

  export type AffiliateLinkCountAggregateInputType = {
    id?: true
    name?: true
    originalUrl?: true
    affiliateUrl?: true
    siteId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    merchantId?: true
    displayText?: true
    trackingId?: true
    status?: true
    commissionInfo?: true
    expirationDate?: true
    _all?: true
  }

  export type AffiliateLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLink to aggregate.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateLinks
    **/
    _count?: true | AffiliateLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateLinkMaxAggregateInputType
  }

  export type GetAffiliateLinkAggregateType<T extends AffiliateLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateLink[P]>
      : GetScalarType<T[P], AggregateAffiliateLink[P]>
  }




  export type AffiliateLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithAggregationInput | AffiliateLinkOrderByWithAggregationInput[]
    by: AffiliateLinkScalarFieldEnum[] | AffiliateLinkScalarFieldEnum
    having?: AffiliateLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateLinkCountAggregateInputType | true
    _min?: AffiliateLinkMinAggregateInputType
    _max?: AffiliateLinkMaxAggregateInputType
  }

  export type AffiliateLinkGroupByOutputType = {
    id: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
    merchantId: string | null
    displayText: string | null
    trackingId: string | null
    status: string
    commissionInfo: JsonValue | null
    expirationDate: Date | null
    _count: AffiliateLinkCountAggregateOutputType | null
    _min: AffiliateLinkMinAggregateOutputType | null
    _max: AffiliateLinkMaxAggregateOutputType | null
  }

  type GetAffiliateLinkGroupByPayload<T extends AffiliateLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateLinkGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateLinkGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalUrl?: boolean
    affiliateUrl?: boolean
    siteId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    merchantId?: boolean
    displayText?: boolean
    trackingId?: boolean
    status?: boolean
    commissionInfo?: boolean
    expirationDate?: boolean
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    conversions?: boolean | AffiliateLink$conversionsArgs<ExtArgs>
    linkClicks?: boolean | AffiliateLink$linkClicksArgs<ExtArgs>
    _count?: boolean | AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateLink"]>

  export type AffiliateLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalUrl?: boolean
    affiliateUrl?: boolean
    siteId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    merchantId?: boolean
    displayText?: boolean
    trackingId?: boolean
    status?: boolean
    commissionInfo?: boolean
    expirationDate?: boolean
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateLink"]>

  export type AffiliateLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalUrl?: boolean
    affiliateUrl?: boolean
    siteId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    merchantId?: boolean
    displayText?: boolean
    trackingId?: boolean
    status?: boolean
    commissionInfo?: boolean
    expirationDate?: boolean
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateLink"]>

  export type AffiliateLinkSelectScalar = {
    id?: boolean
    name?: boolean
    originalUrl?: boolean
    affiliateUrl?: boolean
    siteId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    merchantId?: boolean
    displayText?: boolean
    trackingId?: boolean
    status?: boolean
    commissionInfo?: boolean
    expirationDate?: boolean
  }

  export type AffiliateLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "originalUrl" | "affiliateUrl" | "siteId" | "createdBy" | "createdAt" | "updatedAt" | "productId" | "merchantId" | "displayText" | "trackingId" | "status" | "commissionInfo" | "expirationDate", ExtArgs["result"]["affiliateLink"]>
  export type AffiliateLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    conversions?: boolean | AffiliateLink$conversionsArgs<ExtArgs>
    linkClicks?: boolean | AffiliateLink$linkClicksArgs<ExtArgs>
    _count?: boolean | AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type AffiliateLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | AffiliateLink$merchantArgs<ExtArgs>
    product?: boolean | AffiliateLink$productArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $AffiliateLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateLink"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      site: Prisma.$SitePayload<ExtArgs>
      conversions: Prisma.$ConversionPayload<ExtArgs>[]
      linkClicks: Prisma.$LinkClickPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      originalUrl: string
      affiliateUrl: string
      siteId: string
      createdBy: string | null
      createdAt: Date | null
      updatedAt: Date | null
      productId: string | null
      merchantId: string | null
      displayText: string | null
      trackingId: string | null
      status: string
      commissionInfo: Prisma.JsonValue | null
      expirationDate: Date | null
    }, ExtArgs["result"]["affiliateLink"]>
    composites: {}
  }

  type AffiliateLinkGetPayload<S extends boolean | null | undefined | AffiliateLinkDefaultArgs> = $Result.GetResult<Prisma.$AffiliateLinkPayload, S>

  type AffiliateLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AffiliateLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AffiliateLinkCountAggregateInputType | true
    }

  export interface AffiliateLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateLink'], meta: { name: 'AffiliateLink' } }
    /**
     * Find zero or one AffiliateLink that matches the filter.
     * @param {AffiliateLinkFindUniqueArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateLinkFindUniqueArgs>(args: SelectSubset<T, AffiliateLinkFindUniqueArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AffiliateLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AffiliateLinkFindUniqueOrThrowArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindFirstArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateLinkFindFirstArgs>(args?: SelectSubset<T, AffiliateLinkFindFirstArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindFirstOrThrowArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AffiliateLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateLinks
     * const affiliateLinks = await prisma.affiliateLink.findMany()
     * 
     * // Get first 10 AffiliateLinks
     * const affiliateLinks = await prisma.affiliateLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateLinkWithIdOnly = await prisma.affiliateLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateLinkFindManyArgs>(args?: SelectSubset<T, AffiliateLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AffiliateLink.
     * @param {AffiliateLinkCreateArgs} args - Arguments to create a AffiliateLink.
     * @example
     * // Create one AffiliateLink
     * const AffiliateLink = await prisma.affiliateLink.create({
     *   data: {
     *     // ... data to create a AffiliateLink
     *   }
     * })
     * 
     */
    create<T extends AffiliateLinkCreateArgs>(args: SelectSubset<T, AffiliateLinkCreateArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AffiliateLinks.
     * @param {AffiliateLinkCreateManyArgs} args - Arguments to create many AffiliateLinks.
     * @example
     * // Create many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateLinkCreateManyArgs>(args?: SelectSubset<T, AffiliateLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateLinks and returns the data saved in the database.
     * @param {AffiliateLinkCreateManyAndReturnArgs} args - Arguments to create many AffiliateLinks.
     * @example
     * // Create many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateLinks and only return the `id`
     * const affiliateLinkWithIdOnly = await prisma.affiliateLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AffiliateLink.
     * @param {AffiliateLinkDeleteArgs} args - Arguments to delete one AffiliateLink.
     * @example
     * // Delete one AffiliateLink
     * const AffiliateLink = await prisma.affiliateLink.delete({
     *   where: {
     *     // ... filter to delete one AffiliateLink
     *   }
     * })
     * 
     */
    delete<T extends AffiliateLinkDeleteArgs>(args: SelectSubset<T, AffiliateLinkDeleteArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AffiliateLink.
     * @param {AffiliateLinkUpdateArgs} args - Arguments to update one AffiliateLink.
     * @example
     * // Update one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateLinkUpdateArgs>(args: SelectSubset<T, AffiliateLinkUpdateArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AffiliateLinks.
     * @param {AffiliateLinkDeleteManyArgs} args - Arguments to filter AffiliateLinks to delete.
     * @example
     * // Delete a few AffiliateLinks
     * const { count } = await prisma.affiliateLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateLinkDeleteManyArgs>(args?: SelectSubset<T, AffiliateLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateLinkUpdateManyArgs>(args: SelectSubset<T, AffiliateLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateLinks and returns the data updated in the database.
     * @param {AffiliateLinkUpdateManyAndReturnArgs} args - Arguments to update many AffiliateLinks.
     * @example
     * // Update many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AffiliateLinks and only return the `id`
     * const affiliateLinkWithIdOnly = await prisma.affiliateLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AffiliateLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, AffiliateLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AffiliateLink.
     * @param {AffiliateLinkUpsertArgs} args - Arguments to update or create a AffiliateLink.
     * @example
     * // Update or create a AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.upsert({
     *   create: {
     *     // ... data to create a AffiliateLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateLink we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateLinkUpsertArgs>(args: SelectSubset<T, AffiliateLinkUpsertArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AffiliateLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkCountArgs} args - Arguments to filter AffiliateLinks to count.
     * @example
     * // Count the number of AffiliateLinks
     * const count = await prisma.affiliateLink.count({
     *   where: {
     *     // ... the filter for the AffiliateLinks we want to count
     *   }
     * })
    **/
    count<T extends AffiliateLinkCountArgs>(
      args?: Subset<T, AffiliateLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateLinkAggregateArgs>(args: Subset<T, AffiliateLinkAggregateArgs>): Prisma.PrismaPromise<GetAffiliateLinkAggregateType<T>>

    /**
     * Group by AffiliateLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateLinkGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateLink model
   */
  readonly fields: AffiliateLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends AffiliateLink$merchantArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$merchantArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends AffiliateLink$productArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversions<T extends AffiliateLink$conversionsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$conversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkClicks<T extends AffiliateLink$linkClicksArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$linkClicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateLink model
   */
  interface AffiliateLinkFieldRefs {
    readonly id: FieldRef<"AffiliateLink", 'String'>
    readonly name: FieldRef<"AffiliateLink", 'String'>
    readonly originalUrl: FieldRef<"AffiliateLink", 'String'>
    readonly affiliateUrl: FieldRef<"AffiliateLink", 'String'>
    readonly siteId: FieldRef<"AffiliateLink", 'String'>
    readonly createdBy: FieldRef<"AffiliateLink", 'String'>
    readonly createdAt: FieldRef<"AffiliateLink", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliateLink", 'DateTime'>
    readonly productId: FieldRef<"AffiliateLink", 'String'>
    readonly merchantId: FieldRef<"AffiliateLink", 'String'>
    readonly displayText: FieldRef<"AffiliateLink", 'String'>
    readonly trackingId: FieldRef<"AffiliateLink", 'String'>
    readonly status: FieldRef<"AffiliateLink", 'String'>
    readonly commissionInfo: FieldRef<"AffiliateLink", 'Json'>
    readonly expirationDate: FieldRef<"AffiliateLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateLink findUnique
   */
  export type AffiliateLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink findUniqueOrThrow
   */
  export type AffiliateLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink findFirst
   */
  export type AffiliateLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinks.
     */
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink findFirstOrThrow
   */
  export type AffiliateLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinks.
     */
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink findMany
   */
  export type AffiliateLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLinks to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink create
   */
  export type AffiliateLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateLink.
     */
    data: XOR<AffiliateLinkCreateInput, AffiliateLinkUncheckedCreateInput>
  }

  /**
   * AffiliateLink createMany
   */
  export type AffiliateLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateLinks.
     */
    data: AffiliateLinkCreateManyInput | AffiliateLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateLink createManyAndReturn
   */
  export type AffiliateLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * The data used to create many AffiliateLinks.
     */
    data: AffiliateLinkCreateManyInput | AffiliateLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateLink update
   */
  export type AffiliateLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateLink.
     */
    data: XOR<AffiliateLinkUpdateInput, AffiliateLinkUncheckedUpdateInput>
    /**
     * Choose, which AffiliateLink to update.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink updateMany
   */
  export type AffiliateLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateLinks.
     */
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateLinks to update
     */
    where?: AffiliateLinkWhereInput
    /**
     * Limit how many AffiliateLinks to update.
     */
    limit?: number
  }

  /**
   * AffiliateLink updateManyAndReturn
   */
  export type AffiliateLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * The data used to update AffiliateLinks.
     */
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateLinks to update
     */
    where?: AffiliateLinkWhereInput
    /**
     * Limit how many AffiliateLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateLink upsert
   */
  export type AffiliateLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateLink to update in case it exists.
     */
    where: AffiliateLinkWhereUniqueInput
    /**
     * In case the AffiliateLink found by the `where` argument doesn't exist, create a new AffiliateLink with this data.
     */
    create: XOR<AffiliateLinkCreateInput, AffiliateLinkUncheckedCreateInput>
    /**
     * In case the AffiliateLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateLinkUpdateInput, AffiliateLinkUncheckedUpdateInput>
  }

  /**
   * AffiliateLink delete
   */
  export type AffiliateLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter which AffiliateLink to delete.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink deleteMany
   */
  export type AffiliateLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLinks to delete
     */
    where?: AffiliateLinkWhereInput
    /**
     * Limit how many AffiliateLinks to delete.
     */
    limit?: number
  }

  /**
   * AffiliateLink.merchant
   */
  export type AffiliateLink$merchantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    where?: MerchantWhereInput
  }

  /**
   * AffiliateLink.product
   */
  export type AffiliateLink$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * AffiliateLink.conversions
   */
  export type AffiliateLink$conversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    cursor?: ConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * AffiliateLink.linkClicks
   */
  export type AffiliateLink$linkClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    where?: LinkClickWhereInput
    orderBy?: LinkClickOrderByWithRelationInput | LinkClickOrderByWithRelationInput[]
    cursor?: LinkClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkClickScalarFieldEnum | LinkClickScalarFieldEnum[]
  }

  /**
   * AffiliateLink without action
   */
  export type AffiliateLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
  }


  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    name: number
    description: number
    website: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    name: string
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliateLinks?: boolean | Merchant$affiliateLinksArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MerchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "website" | "logoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["merchant"]>
  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLinks?: boolean | Merchant$affiliateLinksArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MerchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      affiliateLinks: Prisma.$AffiliateLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      website: string | null
      logoUrl: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {MerchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateLinks<T extends Merchant$affiliateLinksArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$affiliateLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'String'>
    readonly name: FieldRef<"Merchant", 'String'>
    readonly description: FieldRef<"Merchant", 'String'>
    readonly website: FieldRef<"Merchant", 'String'>
    readonly logoUrl: FieldRef<"Merchant", 'String'>
    readonly createdAt: FieldRef<"Merchant", 'DateTime'>
    readonly updatedAt: FieldRef<"Merchant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant updateManyAndReturn
   */
  export type MerchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to delete.
     */
    limit?: number
  }

  /**
   * Merchant.affiliateLinks
   */
  export type Merchant$affiliateLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLink
     */
    omit?: AffiliateLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    cursor?: AffiliateLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model LinkClick
   */

  export type AggregateLinkClick = {
    _count: LinkClickCountAggregateOutputType | null
    _avg: LinkClickAvgAggregateOutputType | null
    _sum: LinkClickSumAggregateOutputType | null
    _min: LinkClickMinAggregateOutputType | null
    _max: LinkClickMaxAggregateOutputType | null
  }

  export type LinkClickAvgAggregateOutputType = {
    conversionValue: Decimal | null
  }

  export type LinkClickSumAggregateOutputType = {
    conversionValue: Decimal | null
  }

  export type LinkClickMinAggregateOutputType = {
    id: string | null
    affiliateLinkId: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionStatus: string | null
    conversionValue: Decimal | null
  }

  export type LinkClickMaxAggregateOutputType = {
    id: string | null
    affiliateLinkId: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionStatus: string | null
    conversionValue: Decimal | null
  }

  export type LinkClickCountAggregateOutputType = {
    id: number
    affiliateLinkId: number
    ipAddress: number
    userAgent: number
    referrer: number
    clickedAt: number
    conversionStatus: number
    conversionValue: number
    _all: number
  }


  export type LinkClickAvgAggregateInputType = {
    conversionValue?: true
  }

  export type LinkClickSumAggregateInputType = {
    conversionValue?: true
  }

  export type LinkClickMinAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionStatus?: true
    conversionValue?: true
  }

  export type LinkClickMaxAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionStatus?: true
    conversionValue?: true
  }

  export type LinkClickCountAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionStatus?: true
    conversionValue?: true
    _all?: true
  }

  export type LinkClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkClick to aggregate.
     */
    where?: LinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkClicks to fetch.
     */
    orderBy?: LinkClickOrderByWithRelationInput | LinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkClicks
    **/
    _count?: true | LinkClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkClickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkClickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkClickMaxAggregateInputType
  }

  export type GetLinkClickAggregateType<T extends LinkClickAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkClick[P]>
      : GetScalarType<T[P], AggregateLinkClick[P]>
  }




  export type LinkClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkClickWhereInput
    orderBy?: LinkClickOrderByWithAggregationInput | LinkClickOrderByWithAggregationInput[]
    by: LinkClickScalarFieldEnum[] | LinkClickScalarFieldEnum
    having?: LinkClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkClickCountAggregateInputType | true
    _avg?: LinkClickAvgAggregateInputType
    _sum?: LinkClickSumAggregateInputType
    _min?: LinkClickMinAggregateInputType
    _max?: LinkClickMaxAggregateInputType
  }

  export type LinkClickGroupByOutputType = {
    id: string
    affiliateLinkId: string
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionStatus: string | null
    conversionValue: Decimal | null
    _count: LinkClickCountAggregateOutputType | null
    _avg: LinkClickAvgAggregateOutputType | null
    _sum: LinkClickSumAggregateOutputType | null
    _min: LinkClickMinAggregateOutputType | null
    _max: LinkClickMaxAggregateOutputType | null
  }

  type GetLinkClickGroupByPayload<T extends LinkClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkClickGroupByOutputType[P]>
            : GetScalarType<T[P], LinkClickGroupByOutputType[P]>
        }
      >
    >


  export type LinkClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionStatus?: boolean
    conversionValue?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkClick"]>

  export type LinkClickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionStatus?: boolean
    conversionValue?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkClick"]>

  export type LinkClickSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionStatus?: boolean
    conversionValue?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkClick"]>

  export type LinkClickSelectScalar = {
    id?: boolean
    affiliateLinkId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionStatus?: boolean
    conversionValue?: boolean
  }

  export type LinkClickOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliateLinkId" | "ipAddress" | "userAgent" | "referrer" | "clickedAt" | "conversionStatus" | "conversionValue", ExtArgs["result"]["linkClick"]>
  export type LinkClickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }
  export type LinkClickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }
  export type LinkClickIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }

  export type $LinkClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkClick"
    objects: {
      affiliateLink: Prisma.$AffiliateLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateLinkId: string
      ipAddress: string | null
      userAgent: string | null
      referrer: string | null
      clickedAt: Date | null
      conversionStatus: string | null
      conversionValue: Prisma.Decimal | null
    }, ExtArgs["result"]["linkClick"]>
    composites: {}
  }

  type LinkClickGetPayload<S extends boolean | null | undefined | LinkClickDefaultArgs> = $Result.GetResult<Prisma.$LinkClickPayload, S>

  type LinkClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkClickFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkClickCountAggregateInputType | true
    }

  export interface LinkClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkClick'], meta: { name: 'LinkClick' } }
    /**
     * Find zero or one LinkClick that matches the filter.
     * @param {LinkClickFindUniqueArgs} args - Arguments to find a LinkClick
     * @example
     * // Get one LinkClick
     * const linkClick = await prisma.linkClick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkClickFindUniqueArgs>(args: SelectSubset<T, LinkClickFindUniqueArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkClick that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkClickFindUniqueOrThrowArgs} args - Arguments to find a LinkClick
     * @example
     * // Get one LinkClick
     * const linkClick = await prisma.linkClick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkClickFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkClickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkClick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickFindFirstArgs} args - Arguments to find a LinkClick
     * @example
     * // Get one LinkClick
     * const linkClick = await prisma.linkClick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkClickFindFirstArgs>(args?: SelectSubset<T, LinkClickFindFirstArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkClick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickFindFirstOrThrowArgs} args - Arguments to find a LinkClick
     * @example
     * // Get one LinkClick
     * const linkClick = await prisma.linkClick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkClickFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkClickFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkClicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkClicks
     * const linkClicks = await prisma.linkClick.findMany()
     * 
     * // Get first 10 LinkClicks
     * const linkClicks = await prisma.linkClick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkClickWithIdOnly = await prisma.linkClick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkClickFindManyArgs>(args?: SelectSubset<T, LinkClickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkClick.
     * @param {LinkClickCreateArgs} args - Arguments to create a LinkClick.
     * @example
     * // Create one LinkClick
     * const LinkClick = await prisma.linkClick.create({
     *   data: {
     *     // ... data to create a LinkClick
     *   }
     * })
     * 
     */
    create<T extends LinkClickCreateArgs>(args: SelectSubset<T, LinkClickCreateArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkClicks.
     * @param {LinkClickCreateManyArgs} args - Arguments to create many LinkClicks.
     * @example
     * // Create many LinkClicks
     * const linkClick = await prisma.linkClick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkClickCreateManyArgs>(args?: SelectSubset<T, LinkClickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkClicks and returns the data saved in the database.
     * @param {LinkClickCreateManyAndReturnArgs} args - Arguments to create many LinkClicks.
     * @example
     * // Create many LinkClicks
     * const linkClick = await prisma.linkClick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkClicks and only return the `id`
     * const linkClickWithIdOnly = await prisma.linkClick.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkClickCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkClickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkClick.
     * @param {LinkClickDeleteArgs} args - Arguments to delete one LinkClick.
     * @example
     * // Delete one LinkClick
     * const LinkClick = await prisma.linkClick.delete({
     *   where: {
     *     // ... filter to delete one LinkClick
     *   }
     * })
     * 
     */
    delete<T extends LinkClickDeleteArgs>(args: SelectSubset<T, LinkClickDeleteArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkClick.
     * @param {LinkClickUpdateArgs} args - Arguments to update one LinkClick.
     * @example
     * // Update one LinkClick
     * const linkClick = await prisma.linkClick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkClickUpdateArgs>(args: SelectSubset<T, LinkClickUpdateArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkClicks.
     * @param {LinkClickDeleteManyArgs} args - Arguments to filter LinkClicks to delete.
     * @example
     * // Delete a few LinkClicks
     * const { count } = await prisma.linkClick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkClickDeleteManyArgs>(args?: SelectSubset<T, LinkClickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkClicks
     * const linkClick = await prisma.linkClick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkClickUpdateManyArgs>(args: SelectSubset<T, LinkClickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkClicks and returns the data updated in the database.
     * @param {LinkClickUpdateManyAndReturnArgs} args - Arguments to update many LinkClicks.
     * @example
     * // Update many LinkClicks
     * const linkClick = await prisma.linkClick.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkClicks and only return the `id`
     * const linkClickWithIdOnly = await prisma.linkClick.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkClickUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkClickUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkClick.
     * @param {LinkClickUpsertArgs} args - Arguments to update or create a LinkClick.
     * @example
     * // Update or create a LinkClick
     * const linkClick = await prisma.linkClick.upsert({
     *   create: {
     *     // ... data to create a LinkClick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkClick we want to update
     *   }
     * })
     */
    upsert<T extends LinkClickUpsertArgs>(args: SelectSubset<T, LinkClickUpsertArgs<ExtArgs>>): Prisma__LinkClickClient<$Result.GetResult<Prisma.$LinkClickPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickCountArgs} args - Arguments to filter LinkClicks to count.
     * @example
     * // Count the number of LinkClicks
     * const count = await prisma.linkClick.count({
     *   where: {
     *     // ... the filter for the LinkClicks we want to count
     *   }
     * })
    **/
    count<T extends LinkClickCountArgs>(
      args?: Subset<T, LinkClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkClickAggregateArgs>(args: Subset<T, LinkClickAggregateArgs>): Prisma.PrismaPromise<GetLinkClickAggregateType<T>>

    /**
     * Group by LinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkClickGroupByArgs['orderBy'] }
        : { orderBy?: LinkClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkClick model
   */
  readonly fields: LinkClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkClick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateLink<T extends AffiliateLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLinkDefaultArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkClick model
   */
  interface LinkClickFieldRefs {
    readonly id: FieldRef<"LinkClick", 'String'>
    readonly affiliateLinkId: FieldRef<"LinkClick", 'String'>
    readonly ipAddress: FieldRef<"LinkClick", 'String'>
    readonly userAgent: FieldRef<"LinkClick", 'String'>
    readonly referrer: FieldRef<"LinkClick", 'String'>
    readonly clickedAt: FieldRef<"LinkClick", 'DateTime'>
    readonly conversionStatus: FieldRef<"LinkClick", 'String'>
    readonly conversionValue: FieldRef<"LinkClick", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * LinkClick findUnique
   */
  export type LinkClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter, which LinkClick to fetch.
     */
    where: LinkClickWhereUniqueInput
  }

  /**
   * LinkClick findUniqueOrThrow
   */
  export type LinkClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter, which LinkClick to fetch.
     */
    where: LinkClickWhereUniqueInput
  }

  /**
   * LinkClick findFirst
   */
  export type LinkClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter, which LinkClick to fetch.
     */
    where?: LinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkClicks to fetch.
     */
    orderBy?: LinkClickOrderByWithRelationInput | LinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkClicks.
     */
    cursor?: LinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkClicks.
     */
    distinct?: LinkClickScalarFieldEnum | LinkClickScalarFieldEnum[]
  }

  /**
   * LinkClick findFirstOrThrow
   */
  export type LinkClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter, which LinkClick to fetch.
     */
    where?: LinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkClicks to fetch.
     */
    orderBy?: LinkClickOrderByWithRelationInput | LinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkClicks.
     */
    cursor?: LinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkClicks.
     */
    distinct?: LinkClickScalarFieldEnum | LinkClickScalarFieldEnum[]
  }

  /**
   * LinkClick findMany
   */
  export type LinkClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter, which LinkClicks to fetch.
     */
    where?: LinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkClicks to fetch.
     */
    orderBy?: LinkClickOrderByWithRelationInput | LinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkClicks.
     */
    cursor?: LinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkClicks.
     */
    skip?: number
    distinct?: LinkClickScalarFieldEnum | LinkClickScalarFieldEnum[]
  }

  /**
   * LinkClick create
   */
  export type LinkClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkClick.
     */
    data: XOR<LinkClickCreateInput, LinkClickUncheckedCreateInput>
  }

  /**
   * LinkClick createMany
   */
  export type LinkClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkClicks.
     */
    data: LinkClickCreateManyInput | LinkClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkClick createManyAndReturn
   */
  export type LinkClickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * The data used to create many LinkClicks.
     */
    data: LinkClickCreateManyInput | LinkClickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkClick update
   */
  export type LinkClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkClick.
     */
    data: XOR<LinkClickUpdateInput, LinkClickUncheckedUpdateInput>
    /**
     * Choose, which LinkClick to update.
     */
    where: LinkClickWhereUniqueInput
  }

  /**
   * LinkClick updateMany
   */
  export type LinkClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkClicks.
     */
    data: XOR<LinkClickUpdateManyMutationInput, LinkClickUncheckedUpdateManyInput>
    /**
     * Filter which LinkClicks to update
     */
    where?: LinkClickWhereInput
    /**
     * Limit how many LinkClicks to update.
     */
    limit?: number
  }

  /**
   * LinkClick updateManyAndReturn
   */
  export type LinkClickUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * The data used to update LinkClicks.
     */
    data: XOR<LinkClickUpdateManyMutationInput, LinkClickUncheckedUpdateManyInput>
    /**
     * Filter which LinkClicks to update
     */
    where?: LinkClickWhereInput
    /**
     * Limit how many LinkClicks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkClick upsert
   */
  export type LinkClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkClick to update in case it exists.
     */
    where: LinkClickWhereUniqueInput
    /**
     * In case the LinkClick found by the `where` argument doesn't exist, create a new LinkClick with this data.
     */
    create: XOR<LinkClickCreateInput, LinkClickUncheckedCreateInput>
    /**
     * In case the LinkClick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkClickUpdateInput, LinkClickUncheckedUpdateInput>
  }

  /**
   * LinkClick delete
   */
  export type LinkClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
    /**
     * Filter which LinkClick to delete.
     */
    where: LinkClickWhereUniqueInput
  }

  /**
   * LinkClick deleteMany
   */
  export type LinkClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkClicks to delete
     */
    where?: LinkClickWhereInput
    /**
     * Limit how many LinkClicks to delete.
     */
    limit?: number
  }

  /**
   * LinkClick without action
   */
  export type LinkClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkClick
     */
    select?: LinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkClick
     */
    omit?: LinkClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkClickInclude<ExtArgs> | null
  }


  /**
   * Model Conversion
   */

  export type AggregateConversion = {
    _count: ConversionCountAggregateOutputType | null
    _avg: ConversionAvgAggregateOutputType | null
    _sum: ConversionSumAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  export type ConversionAvgAggregateOutputType = {
    orderValue: Decimal | null
    commission: Decimal | null
  }

  export type ConversionSumAggregateOutputType = {
    orderValue: Decimal | null
    commission: Decimal | null
  }

  export type ConversionMinAggregateOutputType = {
    id: string | null
    affiliateLinkId: string | null
    orderId: string | null
    orderValue: Decimal | null
    commission: Decimal | null
    currency: string | null
    conversionDate: Date | null
    status: string | null
    notes: string | null
  }

  export type ConversionMaxAggregateOutputType = {
    id: string | null
    affiliateLinkId: string | null
    orderId: string | null
    orderValue: Decimal | null
    commission: Decimal | null
    currency: string | null
    conversionDate: Date | null
    status: string | null
    notes: string | null
  }

  export type ConversionCountAggregateOutputType = {
    id: number
    affiliateLinkId: number
    orderId: number
    orderValue: number
    commission: number
    currency: number
    conversionDate: number
    status: number
    notes: number
    _all: number
  }


  export type ConversionAvgAggregateInputType = {
    orderValue?: true
    commission?: true
  }

  export type ConversionSumAggregateInputType = {
    orderValue?: true
    commission?: true
  }

  export type ConversionMinAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    orderId?: true
    orderValue?: true
    commission?: true
    currency?: true
    conversionDate?: true
    status?: true
    notes?: true
  }

  export type ConversionMaxAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    orderId?: true
    orderValue?: true
    commission?: true
    currency?: true
    conversionDate?: true
    status?: true
    notes?: true
  }

  export type ConversionCountAggregateInputType = {
    id?: true
    affiliateLinkId?: true
    orderId?: true
    orderValue?: true
    commission?: true
    currency?: true
    conversionDate?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type ConversionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversion to aggregate.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversions
    **/
    _count?: true | ConversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversionMaxAggregateInputType
  }

  export type GetConversionAggregateType<T extends ConversionAggregateArgs> = {
        [P in keyof T & keyof AggregateConversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversion[P]>
      : GetScalarType<T[P], AggregateConversion[P]>
  }




  export type ConversionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithAggregationInput | ConversionOrderByWithAggregationInput[]
    by: ConversionScalarFieldEnum[] | ConversionScalarFieldEnum
    having?: ConversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversionCountAggregateInputType | true
    _avg?: ConversionAvgAggregateInputType
    _sum?: ConversionSumAggregateInputType
    _min?: ConversionMinAggregateInputType
    _max?: ConversionMaxAggregateInputType
  }

  export type ConversionGroupByOutputType = {
    id: string
    affiliateLinkId: string
    orderId: string | null
    orderValue: Decimal
    commission: Decimal
    currency: string
    conversionDate: Date | null
    status: string
    notes: string | null
    _count: ConversionCountAggregateOutputType | null
    _avg: ConversionAvgAggregateOutputType | null
    _sum: ConversionSumAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  type GetConversionGroupByPayload<T extends ConversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversionGroupByOutputType[P]>
            : GetScalarType<T[P], ConversionGroupByOutputType[P]>
        }
      >
    >


  export type ConversionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    orderId?: boolean
    orderValue?: boolean
    commission?: boolean
    currency?: boolean
    conversionDate?: boolean
    status?: boolean
    notes?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    orderId?: boolean
    orderValue?: boolean
    commission?: boolean
    currency?: boolean
    conversionDate?: boolean
    status?: boolean
    notes?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateLinkId?: boolean
    orderId?: boolean
    orderValue?: boolean
    commission?: boolean
    currency?: boolean
    conversionDate?: boolean
    status?: boolean
    notes?: boolean
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectScalar = {
    id?: boolean
    affiliateLinkId?: boolean
    orderId?: boolean
    orderValue?: boolean
    commission?: boolean
    currency?: boolean
    conversionDate?: boolean
    status?: boolean
    notes?: boolean
  }

  export type ConversionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliateLinkId" | "orderId" | "orderValue" | "commission" | "currency" | "conversionDate" | "status" | "notes", ExtArgs["result"]["conversion"]>
  export type ConversionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }
  export type ConversionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }
  export type ConversionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateLink?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
  }

  export type $ConversionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversion"
    objects: {
      affiliateLink: Prisma.$AffiliateLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateLinkId: string
      orderId: string | null
      orderValue: Prisma.Decimal
      commission: Prisma.Decimal
      currency: string
      conversionDate: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["conversion"]>
    composites: {}
  }

  type ConversionGetPayload<S extends boolean | null | undefined | ConversionDefaultArgs> = $Result.GetResult<Prisma.$ConversionPayload, S>

  type ConversionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversionCountAggregateInputType | true
    }

  export interface ConversionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversion'], meta: { name: 'Conversion' } }
    /**
     * Find zero or one Conversion that matches the filter.
     * @param {ConversionFindUniqueArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversionFindUniqueArgs>(args: SelectSubset<T, ConversionFindUniqueArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversionFindUniqueOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversionFindFirstArgs>(args?: SelectSubset<T, ConversionFindFirstArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversions
     * const conversions = await prisma.conversion.findMany()
     * 
     * // Get first 10 Conversions
     * const conversions = await prisma.conversion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversionWithIdOnly = await prisma.conversion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversionFindManyArgs>(args?: SelectSubset<T, ConversionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversion.
     * @param {ConversionCreateArgs} args - Arguments to create a Conversion.
     * @example
     * // Create one Conversion
     * const Conversion = await prisma.conversion.create({
     *   data: {
     *     // ... data to create a Conversion
     *   }
     * })
     * 
     */
    create<T extends ConversionCreateArgs>(args: SelectSubset<T, ConversionCreateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversions.
     * @param {ConversionCreateManyArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversionCreateManyArgs>(args?: SelectSubset<T, ConversionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversions and returns the data saved in the database.
     * @param {ConversionCreateManyAndReturnArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversions and only return the `id`
     * const conversionWithIdOnly = await prisma.conversion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversion.
     * @param {ConversionDeleteArgs} args - Arguments to delete one Conversion.
     * @example
     * // Delete one Conversion
     * const Conversion = await prisma.conversion.delete({
     *   where: {
     *     // ... filter to delete one Conversion
     *   }
     * })
     * 
     */
    delete<T extends ConversionDeleteArgs>(args: SelectSubset<T, ConversionDeleteArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversion.
     * @param {ConversionUpdateArgs} args - Arguments to update one Conversion.
     * @example
     * // Update one Conversion
     * const conversion = await prisma.conversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversionUpdateArgs>(args: SelectSubset<T, ConversionUpdateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversions.
     * @param {ConversionDeleteManyArgs} args - Arguments to filter Conversions to delete.
     * @example
     * // Delete a few Conversions
     * const { count } = await prisma.conversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversionDeleteManyArgs>(args?: SelectSubset<T, ConversionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversions
     * const conversion = await prisma.conversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversionUpdateManyArgs>(args: SelectSubset<T, ConversionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversions and returns the data updated in the database.
     * @param {ConversionUpdateManyAndReturnArgs} args - Arguments to update many Conversions.
     * @example
     * // Update many Conversions
     * const conversion = await prisma.conversion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversions and only return the `id`
     * const conversionWithIdOnly = await prisma.conversion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversion.
     * @param {ConversionUpsertArgs} args - Arguments to update or create a Conversion.
     * @example
     * // Update or create a Conversion
     * const conversion = await prisma.conversion.upsert({
     *   create: {
     *     // ... data to create a Conversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversion we want to update
     *   }
     * })
     */
    upsert<T extends ConversionUpsertArgs>(args: SelectSubset<T, ConversionUpsertArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionCountArgs} args - Arguments to filter Conversions to count.
     * @example
     * // Count the number of Conversions
     * const count = await prisma.conversion.count({
     *   where: {
     *     // ... the filter for the Conversions we want to count
     *   }
     * })
    **/
    count<T extends ConversionCountArgs>(
      args?: Subset<T, ConversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversionAggregateArgs>(args: Subset<T, ConversionAggregateArgs>): Prisma.PrismaPromise<GetConversionAggregateType<T>>

    /**
     * Group by Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversionGroupByArgs['orderBy'] }
        : { orderBy?: ConversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversion model
   */
  readonly fields: ConversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateLink<T extends AffiliateLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLinkDefaultArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversion model
   */
  interface ConversionFieldRefs {
    readonly id: FieldRef<"Conversion", 'String'>
    readonly affiliateLinkId: FieldRef<"Conversion", 'String'>
    readonly orderId: FieldRef<"Conversion", 'String'>
    readonly orderValue: FieldRef<"Conversion", 'Decimal'>
    readonly commission: FieldRef<"Conversion", 'Decimal'>
    readonly currency: FieldRef<"Conversion", 'String'>
    readonly conversionDate: FieldRef<"Conversion", 'DateTime'>
    readonly status: FieldRef<"Conversion", 'String'>
    readonly notes: FieldRef<"Conversion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversion findUnique
   */
  export type ConversionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findUniqueOrThrow
   */
  export type ConversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findFirst
   */
  export type ConversionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findFirstOrThrow
   */
  export type ConversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findMany
   */
  export type ConversionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversions to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion create
   */
  export type ConversionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversion.
     */
    data: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
  }

  /**
   * Conversion createMany
   */
  export type ConversionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversion createManyAndReturn
   */
  export type ConversionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversion update
   */
  export type ConversionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversion.
     */
    data: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
    /**
     * Choose, which Conversion to update.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion updateMany
   */
  export type ConversionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversions.
     */
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyInput>
    /**
     * Filter which Conversions to update
     */
    where?: ConversionWhereInput
    /**
     * Limit how many Conversions to update.
     */
    limit?: number
  }

  /**
   * Conversion updateManyAndReturn
   */
  export type ConversionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * The data used to update Conversions.
     */
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyInput>
    /**
     * Filter which Conversions to update
     */
    where?: ConversionWhereInput
    /**
     * Limit how many Conversions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversion upsert
   */
  export type ConversionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversion to update in case it exists.
     */
    where: ConversionWhereUniqueInput
    /**
     * In case the Conversion found by the `where` argument doesn't exist, create a new Conversion with this data.
     */
    create: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
    /**
     * In case the Conversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
  }

  /**
   * Conversion delete
   */
  export type ConversionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter which Conversion to delete.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion deleteMany
   */
  export type ConversionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversions to delete
     */
    where?: ConversionWhereInput
    /**
     * Limit how many Conversions to delete.
     */
    limit?: number
  }

  /**
   * Conversion without action
   */
  export type ConversionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversion
     */
    omit?: ConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: number | null
    siteId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: number | null
    siteId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    siteId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
    siteId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
    siteId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    siteId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: number
    siteId: string | null
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    siteId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    siteId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    siteId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
    siteId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId" | "siteId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: number
      siteId: string | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly siteId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    tableName: string | null
    recordId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    tableName: string | null
    recordId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    tableName: number
    recordId: number
    oldValues: number
    newValues: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    tableName?: true
    recordId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    tableName?: true
    recordId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    tableName?: true
    recordId?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    tableName: string
    recordId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    createdAt: Date | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "tableName" | "recordId" | "oldValues" | "newValues" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      tableName: string
      recordId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      createdAt: Date | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model NewsletterSubscriber
   */

  export type AggregateNewsletterSubscriber = {
    _count: NewsletterSubscriberCountAggregateOutputType | null
    _min: NewsletterSubscriberMinAggregateOutputType | null
    _max: NewsletterSubscriberMaxAggregateOutputType | null
  }

  export type NewsletterSubscriberMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    isActive: boolean | null
    subscribedAt: Date | null
    unsubscribedAt: Date | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterSubscriberMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    isActive: boolean | null
    subscribedAt: Date | null
    unsubscribedAt: Date | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterSubscriberCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    isActive: number
    subscribedAt: number
    unsubscribedAt: number
    preferences: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsletterSubscriberMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    isActive?: true
    subscribedAt?: true
    unsubscribedAt?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterSubscriberMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    isActive?: true
    subscribedAt?: true
    unsubscribedAt?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterSubscriberCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    isActive?: true
    subscribedAt?: true
    unsubscribedAt?: true
    preferences?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsletterSubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscriber to aggregate.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterSubscribers
    **/
    _count?: true | NewsletterSubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterSubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterSubscriberMaxAggregateInputType
  }

  export type GetNewsletterSubscriberAggregateType<T extends NewsletterSubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterSubscriber[P]>
      : GetScalarType<T[P], AggregateNewsletterSubscriber[P]>
  }




  export type NewsletterSubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriberWhereInput
    orderBy?: NewsletterSubscriberOrderByWithAggregationInput | NewsletterSubscriberOrderByWithAggregationInput[]
    by: NewsletterSubscriberScalarFieldEnum[] | NewsletterSubscriberScalarFieldEnum
    having?: NewsletterSubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterSubscriberCountAggregateInputType | true
    _min?: NewsletterSubscriberMinAggregateInputType
    _max?: NewsletterSubscriberMaxAggregateInputType
  }

  export type NewsletterSubscriberGroupByOutputType = {
    id: string
    email: string
    firstName: string | null
    lastName: string | null
    isActive: boolean
    subscribedAt: Date | null
    unsubscribedAt: Date | null
    preferences: JsonValue | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: NewsletterSubscriberCountAggregateOutputType | null
    _min: NewsletterSubscriberMinAggregateOutputType | null
    _max: NewsletterSubscriberMaxAggregateOutputType | null
  }

  type GetNewsletterSubscriberGroupByPayload<T extends NewsletterSubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterSubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterSubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterSubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterSubscriberGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    isActive?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
    preferences?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscriber"]>

  export type NewsletterSubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    isActive?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
    preferences?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscriber"]>

  export type NewsletterSubscriberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    isActive?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
    preferences?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscriber"]>

  export type NewsletterSubscriberSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    isActive?: boolean
    subscribedAt?: boolean
    unsubscribedAt?: boolean
    preferences?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsletterSubscriberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "isActive" | "subscribedAt" | "unsubscribedAt" | "preferences" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["newsletterSubscriber"]>

  export type $NewsletterSubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterSubscriber"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string | null
      lastName: string | null
      isActive: boolean
      subscribedAt: Date | null
      unsubscribedAt: Date | null
      preferences: Prisma.JsonValue | null
      source: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["newsletterSubscriber"]>
    composites: {}
  }

  type NewsletterSubscriberGetPayload<S extends boolean | null | undefined | NewsletterSubscriberDefaultArgs> = $Result.GetResult<Prisma.$NewsletterSubscriberPayload, S>

  type NewsletterSubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterSubscriberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterSubscriberCountAggregateInputType | true
    }

  export interface NewsletterSubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterSubscriber'], meta: { name: 'NewsletterSubscriber' } }
    /**
     * Find zero or one NewsletterSubscriber that matches the filter.
     * @param {NewsletterSubscriberFindUniqueArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterSubscriberFindUniqueArgs>(args: SelectSubset<T, NewsletterSubscriberFindUniqueArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsletterSubscriber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterSubscriberFindUniqueOrThrowArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterSubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindFirstArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterSubscriberFindFirstArgs>(args?: SelectSubset<T, NewsletterSubscriberFindFirstArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindFirstOrThrowArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterSubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsletterSubscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterSubscribers
     * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany()
     * 
     * // Get first 10 NewsletterSubscribers
     * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterSubscriberWithIdOnly = await prisma.newsletterSubscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterSubscriberFindManyArgs>(args?: SelectSubset<T, NewsletterSubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsletterSubscriber.
     * @param {NewsletterSubscriberCreateArgs} args - Arguments to create a NewsletterSubscriber.
     * @example
     * // Create one NewsletterSubscriber
     * const NewsletterSubscriber = await prisma.newsletterSubscriber.create({
     *   data: {
     *     // ... data to create a NewsletterSubscriber
     *   }
     * })
     * 
     */
    create<T extends NewsletterSubscriberCreateArgs>(args: SelectSubset<T, NewsletterSubscriberCreateArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsletterSubscribers.
     * @param {NewsletterSubscriberCreateManyArgs} args - Arguments to create many NewsletterSubscribers.
     * @example
     * // Create many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterSubscriberCreateManyArgs>(args?: SelectSubset<T, NewsletterSubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterSubscribers and returns the data saved in the database.
     * @param {NewsletterSubscriberCreateManyAndReturnArgs} args - Arguments to create many NewsletterSubscribers.
     * @example
     * // Create many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterSubscribers and only return the `id`
     * const newsletterSubscriberWithIdOnly = await prisma.newsletterSubscriber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterSubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsletterSubscriber.
     * @param {NewsletterSubscriberDeleteArgs} args - Arguments to delete one NewsletterSubscriber.
     * @example
     * // Delete one NewsletterSubscriber
     * const NewsletterSubscriber = await prisma.newsletterSubscriber.delete({
     *   where: {
     *     // ... filter to delete one NewsletterSubscriber
     *   }
     * })
     * 
     */
    delete<T extends NewsletterSubscriberDeleteArgs>(args: SelectSubset<T, NewsletterSubscriberDeleteArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsletterSubscriber.
     * @param {NewsletterSubscriberUpdateArgs} args - Arguments to update one NewsletterSubscriber.
     * @example
     * // Update one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterSubscriberUpdateArgs>(args: SelectSubset<T, NewsletterSubscriberUpdateArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsletterSubscribers.
     * @param {NewsletterSubscriberDeleteManyArgs} args - Arguments to filter NewsletterSubscribers to delete.
     * @example
     * // Delete a few NewsletterSubscribers
     * const { count } = await prisma.newsletterSubscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterSubscriberDeleteManyArgs>(args?: SelectSubset<T, NewsletterSubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterSubscriberUpdateManyArgs>(args: SelectSubset<T, NewsletterSubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscribers and returns the data updated in the database.
     * @param {NewsletterSubscriberUpdateManyAndReturnArgs} args - Arguments to update many NewsletterSubscribers.
     * @example
     * // Update many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsletterSubscribers and only return the `id`
     * const newsletterSubscriberWithIdOnly = await prisma.newsletterSubscriber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsletterSubscriberUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsletterSubscriberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsletterSubscriber.
     * @param {NewsletterSubscriberUpsertArgs} args - Arguments to update or create a NewsletterSubscriber.
     * @example
     * // Update or create a NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.upsert({
     *   create: {
     *     // ... data to create a NewsletterSubscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterSubscriber we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterSubscriberUpsertArgs>(args: SelectSubset<T, NewsletterSubscriberUpsertArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsletterSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberCountArgs} args - Arguments to filter NewsletterSubscribers to count.
     * @example
     * // Count the number of NewsletterSubscribers
     * const count = await prisma.newsletterSubscriber.count({
     *   where: {
     *     // ... the filter for the NewsletterSubscribers we want to count
     *   }
     * })
    **/
    count<T extends NewsletterSubscriberCountArgs>(
      args?: Subset<T, NewsletterSubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterSubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterSubscriberAggregateArgs>(args: Subset<T, NewsletterSubscriberAggregateArgs>): Prisma.PrismaPromise<GetNewsletterSubscriberAggregateType<T>>

    /**
     * Group by NewsletterSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterSubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterSubscriberGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterSubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterSubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterSubscriber model
   */
  readonly fields: NewsletterSubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterSubscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterSubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterSubscriber model
   */
  interface NewsletterSubscriberFieldRefs {
    readonly id: FieldRef<"NewsletterSubscriber", 'String'>
    readonly email: FieldRef<"NewsletterSubscriber", 'String'>
    readonly firstName: FieldRef<"NewsletterSubscriber", 'String'>
    readonly lastName: FieldRef<"NewsletterSubscriber", 'String'>
    readonly isActive: FieldRef<"NewsletterSubscriber", 'Boolean'>
    readonly subscribedAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
    readonly unsubscribedAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
    readonly preferences: FieldRef<"NewsletterSubscriber", 'Json'>
    readonly source: FieldRef<"NewsletterSubscriber", 'String'>
    readonly createdAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterSubscriber findUnique
   */
  export type NewsletterSubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber findUniqueOrThrow
   */
  export type NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber findFirst
   */
  export type NewsletterSubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscribers.
     */
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber findFirstOrThrow
   */
  export type NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscribers.
     */
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber findMany
   */
  export type NewsletterSubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscribers to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber create
   */
  export type NewsletterSubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * The data needed to create a NewsletterSubscriber.
     */
    data: XOR<NewsletterSubscriberCreateInput, NewsletterSubscriberUncheckedCreateInput>
  }

  /**
   * NewsletterSubscriber createMany
   */
  export type NewsletterSubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterSubscribers.
     */
    data: NewsletterSubscriberCreateManyInput | NewsletterSubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscriber createManyAndReturn
   */
  export type NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * The data used to create many NewsletterSubscribers.
     */
    data: NewsletterSubscriberCreateManyInput | NewsletterSubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscriber update
   */
  export type NewsletterSubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * The data needed to update a NewsletterSubscriber.
     */
    data: XOR<NewsletterSubscriberUpdateInput, NewsletterSubscriberUncheckedUpdateInput>
    /**
     * Choose, which NewsletterSubscriber to update.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber updateMany
   */
  export type NewsletterSubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterSubscribers.
     */
    data: XOR<NewsletterSubscriberUpdateManyMutationInput, NewsletterSubscriberUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscribers to update
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * Limit how many NewsletterSubscribers to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscriber updateManyAndReturn
   */
  export type NewsletterSubscriberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * The data used to update NewsletterSubscribers.
     */
    data: XOR<NewsletterSubscriberUpdateManyMutationInput, NewsletterSubscriberUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscribers to update
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * Limit how many NewsletterSubscribers to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscriber upsert
   */
  export type NewsletterSubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * The filter to search for the NewsletterSubscriber to update in case it exists.
     */
    where: NewsletterSubscriberWhereUniqueInput
    /**
     * In case the NewsletterSubscriber found by the `where` argument doesn't exist, create a new NewsletterSubscriber with this data.
     */
    create: XOR<NewsletterSubscriberCreateInput, NewsletterSubscriberUncheckedCreateInput>
    /**
     * In case the NewsletterSubscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterSubscriberUpdateInput, NewsletterSubscriberUncheckedUpdateInput>
  }

  /**
   * NewsletterSubscriber delete
   */
  export type NewsletterSubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
    /**
     * Filter which NewsletterSubscriber to delete.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber deleteMany
   */
  export type NewsletterSubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscribers to delete
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * Limit how many NewsletterSubscribers to delete.
     */
    limit?: number
  }

  /**
   * NewsletterSubscriber without action
   */
  export type NewsletterSubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscriber
     */
    omit?: NewsletterSubscriberOmit<ExtArgs> | null
  }


  /**
   * Model NewsletterCampaign
   */

  export type AggregateNewsletterCampaign = {
    _count: NewsletterCampaignCountAggregateOutputType | null
    _avg: NewsletterCampaignAvgAggregateOutputType | null
    _sum: NewsletterCampaignSumAggregateOutputType | null
    _min: NewsletterCampaignMinAggregateOutputType | null
    _max: NewsletterCampaignMaxAggregateOutputType | null
  }

  export type NewsletterCampaignAvgAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type NewsletterCampaignSumAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type NewsletterCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterCampaignCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    content: number
    status: number
    sentAt: number
    sentCount: number
    openCount: number
    clickCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsletterCampaignAvgAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type NewsletterCampaignSumAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type NewsletterCampaignMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterCampaignCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsletterCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterCampaign to aggregate.
     */
    where?: NewsletterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterCampaigns to fetch.
     */
    orderBy?: NewsletterCampaignOrderByWithRelationInput | NewsletterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterCampaigns
    **/
    _count?: true | NewsletterCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsletterCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsletterCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterCampaignMaxAggregateInputType
  }

  export type GetNewsletterCampaignAggregateType<T extends NewsletterCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterCampaign[P]>
      : GetScalarType<T[P], AggregateNewsletterCampaign[P]>
  }




  export type NewsletterCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterCampaignWhereInput
    orderBy?: NewsletterCampaignOrderByWithAggregationInput | NewsletterCampaignOrderByWithAggregationInput[]
    by: NewsletterCampaignScalarFieldEnum[] | NewsletterCampaignScalarFieldEnum
    having?: NewsletterCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterCampaignCountAggregateInputType | true
    _avg?: NewsletterCampaignAvgAggregateInputType
    _sum?: NewsletterCampaignSumAggregateInputType
    _min?: NewsletterCampaignMinAggregateInputType
    _max?: NewsletterCampaignMaxAggregateInputType
  }

  export type NewsletterCampaignGroupByOutputType = {
    id: string
    name: string
    subject: string
    content: string
    status: string
    sentAt: Date | null
    sentCount: number
    openCount: number
    clickCount: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: NewsletterCampaignCountAggregateOutputType | null
    _avg: NewsletterCampaignAvgAggregateOutputType | null
    _sum: NewsletterCampaignSumAggregateOutputType | null
    _min: NewsletterCampaignMinAggregateOutputType | null
    _max: NewsletterCampaignMaxAggregateOutputType | null
  }

  type GetNewsletterCampaignGroupByPayload<T extends NewsletterCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterCampaignGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterCampaign"]>

  export type NewsletterCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterCampaign"]>

  export type NewsletterCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterCampaign"]>

  export type NewsletterCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsletterCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "content" | "status" | "sentAt" | "sentCount" | "openCount" | "clickCount" | "createdAt" | "updatedAt", ExtArgs["result"]["newsletterCampaign"]>

  export type $NewsletterCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterCampaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      content: string
      status: string
      sentAt: Date | null
      sentCount: number
      openCount: number
      clickCount: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["newsletterCampaign"]>
    composites: {}
  }

  type NewsletterCampaignGetPayload<S extends boolean | null | undefined | NewsletterCampaignDefaultArgs> = $Result.GetResult<Prisma.$NewsletterCampaignPayload, S>

  type NewsletterCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterCampaignCountAggregateInputType | true
    }

  export interface NewsletterCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterCampaign'], meta: { name: 'NewsletterCampaign' } }
    /**
     * Find zero or one NewsletterCampaign that matches the filter.
     * @param {NewsletterCampaignFindUniqueArgs} args - Arguments to find a NewsletterCampaign
     * @example
     * // Get one NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterCampaignFindUniqueArgs>(args: SelectSubset<T, NewsletterCampaignFindUniqueArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsletterCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterCampaignFindUniqueOrThrowArgs} args - Arguments to find a NewsletterCampaign
     * @example
     * // Get one NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignFindFirstArgs} args - Arguments to find a NewsletterCampaign
     * @example
     * // Get one NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterCampaignFindFirstArgs>(args?: SelectSubset<T, NewsletterCampaignFindFirstArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignFindFirstOrThrowArgs} args - Arguments to find a NewsletterCampaign
     * @example
     * // Get one NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsletterCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterCampaigns
     * const newsletterCampaigns = await prisma.newsletterCampaign.findMany()
     * 
     * // Get first 10 NewsletterCampaigns
     * const newsletterCampaigns = await prisma.newsletterCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterCampaignWithIdOnly = await prisma.newsletterCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterCampaignFindManyArgs>(args?: SelectSubset<T, NewsletterCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsletterCampaign.
     * @param {NewsletterCampaignCreateArgs} args - Arguments to create a NewsletterCampaign.
     * @example
     * // Create one NewsletterCampaign
     * const NewsletterCampaign = await prisma.newsletterCampaign.create({
     *   data: {
     *     // ... data to create a NewsletterCampaign
     *   }
     * })
     * 
     */
    create<T extends NewsletterCampaignCreateArgs>(args: SelectSubset<T, NewsletterCampaignCreateArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsletterCampaigns.
     * @param {NewsletterCampaignCreateManyArgs} args - Arguments to create many NewsletterCampaigns.
     * @example
     * // Create many NewsletterCampaigns
     * const newsletterCampaign = await prisma.newsletterCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterCampaignCreateManyArgs>(args?: SelectSubset<T, NewsletterCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterCampaigns and returns the data saved in the database.
     * @param {NewsletterCampaignCreateManyAndReturnArgs} args - Arguments to create many NewsletterCampaigns.
     * @example
     * // Create many NewsletterCampaigns
     * const newsletterCampaign = await prisma.newsletterCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterCampaigns and only return the `id`
     * const newsletterCampaignWithIdOnly = await prisma.newsletterCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsletterCampaign.
     * @param {NewsletterCampaignDeleteArgs} args - Arguments to delete one NewsletterCampaign.
     * @example
     * // Delete one NewsletterCampaign
     * const NewsletterCampaign = await prisma.newsletterCampaign.delete({
     *   where: {
     *     // ... filter to delete one NewsletterCampaign
     *   }
     * })
     * 
     */
    delete<T extends NewsletterCampaignDeleteArgs>(args: SelectSubset<T, NewsletterCampaignDeleteArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsletterCampaign.
     * @param {NewsletterCampaignUpdateArgs} args - Arguments to update one NewsletterCampaign.
     * @example
     * // Update one NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterCampaignUpdateArgs>(args: SelectSubset<T, NewsletterCampaignUpdateArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsletterCampaigns.
     * @param {NewsletterCampaignDeleteManyArgs} args - Arguments to filter NewsletterCampaigns to delete.
     * @example
     * // Delete a few NewsletterCampaigns
     * const { count } = await prisma.newsletterCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterCampaignDeleteManyArgs>(args?: SelectSubset<T, NewsletterCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterCampaigns
     * const newsletterCampaign = await prisma.newsletterCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterCampaignUpdateManyArgs>(args: SelectSubset<T, NewsletterCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterCampaigns and returns the data updated in the database.
     * @param {NewsletterCampaignUpdateManyAndReturnArgs} args - Arguments to update many NewsletterCampaigns.
     * @example
     * // Update many NewsletterCampaigns
     * const newsletterCampaign = await prisma.newsletterCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsletterCampaigns and only return the `id`
     * const newsletterCampaignWithIdOnly = await prisma.newsletterCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsletterCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsletterCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsletterCampaign.
     * @param {NewsletterCampaignUpsertArgs} args - Arguments to update or create a NewsletterCampaign.
     * @example
     * // Update or create a NewsletterCampaign
     * const newsletterCampaign = await prisma.newsletterCampaign.upsert({
     *   create: {
     *     // ... data to create a NewsletterCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterCampaign we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterCampaignUpsertArgs>(args: SelectSubset<T, NewsletterCampaignUpsertArgs<ExtArgs>>): Prisma__NewsletterCampaignClient<$Result.GetResult<Prisma.$NewsletterCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsletterCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignCountArgs} args - Arguments to filter NewsletterCampaigns to count.
     * @example
     * // Count the number of NewsletterCampaigns
     * const count = await prisma.newsletterCampaign.count({
     *   where: {
     *     // ... the filter for the NewsletterCampaigns we want to count
     *   }
     * })
    **/
    count<T extends NewsletterCampaignCountArgs>(
      args?: Subset<T, NewsletterCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterCampaignAggregateArgs>(args: Subset<T, NewsletterCampaignAggregateArgs>): Prisma.PrismaPromise<GetNewsletterCampaignAggregateType<T>>

    /**
     * Group by NewsletterCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterCampaignGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterCampaign model
   */
  readonly fields: NewsletterCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterCampaign model
   */
  interface NewsletterCampaignFieldRefs {
    readonly id: FieldRef<"NewsletterCampaign", 'String'>
    readonly name: FieldRef<"NewsletterCampaign", 'String'>
    readonly subject: FieldRef<"NewsletterCampaign", 'String'>
    readonly content: FieldRef<"NewsletterCampaign", 'String'>
    readonly status: FieldRef<"NewsletterCampaign", 'String'>
    readonly sentAt: FieldRef<"NewsletterCampaign", 'DateTime'>
    readonly sentCount: FieldRef<"NewsletterCampaign", 'Int'>
    readonly openCount: FieldRef<"NewsletterCampaign", 'Int'>
    readonly clickCount: FieldRef<"NewsletterCampaign", 'Int'>
    readonly createdAt: FieldRef<"NewsletterCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsletterCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterCampaign findUnique
   */
  export type NewsletterCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterCampaign to fetch.
     */
    where: NewsletterCampaignWhereUniqueInput
  }

  /**
   * NewsletterCampaign findUniqueOrThrow
   */
  export type NewsletterCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterCampaign to fetch.
     */
    where: NewsletterCampaignWhereUniqueInput
  }

  /**
   * NewsletterCampaign findFirst
   */
  export type NewsletterCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterCampaign to fetch.
     */
    where?: NewsletterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterCampaigns to fetch.
     */
    orderBy?: NewsletterCampaignOrderByWithRelationInput | NewsletterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterCampaigns.
     */
    cursor?: NewsletterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterCampaigns.
     */
    distinct?: NewsletterCampaignScalarFieldEnum | NewsletterCampaignScalarFieldEnum[]
  }

  /**
   * NewsletterCampaign findFirstOrThrow
   */
  export type NewsletterCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterCampaign to fetch.
     */
    where?: NewsletterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterCampaigns to fetch.
     */
    orderBy?: NewsletterCampaignOrderByWithRelationInput | NewsletterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterCampaigns.
     */
    cursor?: NewsletterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterCampaigns.
     */
    distinct?: NewsletterCampaignScalarFieldEnum | NewsletterCampaignScalarFieldEnum[]
  }

  /**
   * NewsletterCampaign findMany
   */
  export type NewsletterCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterCampaigns to fetch.
     */
    where?: NewsletterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterCampaigns to fetch.
     */
    orderBy?: NewsletterCampaignOrderByWithRelationInput | NewsletterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterCampaigns.
     */
    cursor?: NewsletterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterCampaigns.
     */
    skip?: number
    distinct?: NewsletterCampaignScalarFieldEnum | NewsletterCampaignScalarFieldEnum[]
  }

  /**
   * NewsletterCampaign create
   */
  export type NewsletterCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * The data needed to create a NewsletterCampaign.
     */
    data: XOR<NewsletterCampaignCreateInput, NewsletterCampaignUncheckedCreateInput>
  }

  /**
   * NewsletterCampaign createMany
   */
  export type NewsletterCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterCampaigns.
     */
    data: NewsletterCampaignCreateManyInput | NewsletterCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterCampaign createManyAndReturn
   */
  export type NewsletterCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many NewsletterCampaigns.
     */
    data: NewsletterCampaignCreateManyInput | NewsletterCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterCampaign update
   */
  export type NewsletterCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * The data needed to update a NewsletterCampaign.
     */
    data: XOR<NewsletterCampaignUpdateInput, NewsletterCampaignUncheckedUpdateInput>
    /**
     * Choose, which NewsletterCampaign to update.
     */
    where: NewsletterCampaignWhereUniqueInput
  }

  /**
   * NewsletterCampaign updateMany
   */
  export type NewsletterCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterCampaigns.
     */
    data: XOR<NewsletterCampaignUpdateManyMutationInput, NewsletterCampaignUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterCampaigns to update
     */
    where?: NewsletterCampaignWhereInput
    /**
     * Limit how many NewsletterCampaigns to update.
     */
    limit?: number
  }

  /**
   * NewsletterCampaign updateManyAndReturn
   */
  export type NewsletterCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * The data used to update NewsletterCampaigns.
     */
    data: XOR<NewsletterCampaignUpdateManyMutationInput, NewsletterCampaignUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterCampaigns to update
     */
    where?: NewsletterCampaignWhereInput
    /**
     * Limit how many NewsletterCampaigns to update.
     */
    limit?: number
  }

  /**
   * NewsletterCampaign upsert
   */
  export type NewsletterCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * The filter to search for the NewsletterCampaign to update in case it exists.
     */
    where: NewsletterCampaignWhereUniqueInput
    /**
     * In case the NewsletterCampaign found by the `where` argument doesn't exist, create a new NewsletterCampaign with this data.
     */
    create: XOR<NewsletterCampaignCreateInput, NewsletterCampaignUncheckedCreateInput>
    /**
     * In case the NewsletterCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterCampaignUpdateInput, NewsletterCampaignUncheckedUpdateInput>
  }

  /**
   * NewsletterCampaign delete
   */
  export type NewsletterCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
    /**
     * Filter which NewsletterCampaign to delete.
     */
    where: NewsletterCampaignWhereUniqueInput
  }

  /**
   * NewsletterCampaign deleteMany
   */
  export type NewsletterCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterCampaigns to delete
     */
    where?: NewsletterCampaignWhereInput
    /**
     * Limit how many NewsletterCampaigns to delete.
     */
    limit?: number
  }

  /**
   * NewsletterCampaign without action
   */
  export type NewsletterCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterCampaign
     */
    select?: NewsletterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterCampaign
     */
    omit?: NewsletterCampaignOmit<ExtArgs> | null
  }


  /**
   * Model Newsletter
   */

  export type AggregateNewsletter = {
    _count: NewsletterCountAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  export type NewsletterMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsletterMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsletterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Newsletter to aggregate.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Newsletters
    **/
    _count?: true | NewsletterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterMaxAggregateInputType
  }

  export type GetNewsletterAggregateType<T extends NewsletterAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter[P]>
      : GetScalarType<T[P], AggregateNewsletter[P]>
  }




  export type NewsletterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterWhereInput
    orderBy?: NewsletterOrderByWithAggregationInput | NewsletterOrderByWithAggregationInput[]
    by: NewsletterScalarFieldEnum[] | NewsletterScalarFieldEnum
    having?: NewsletterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterCountAggregateInputType | true
    _min?: NewsletterMinAggregateInputType
    _max?: NewsletterMaxAggregateInputType
  }

  export type NewsletterGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: NewsletterCountAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  type GetNewsletterGroupByPayload<T extends NewsletterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletter"]>

  export type NewsletterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletter"]>

  export type NewsletterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletter"]>

  export type NewsletterSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsletterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["newsletter"]>

  export type $NewsletterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Newsletter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["newsletter"]>
    composites: {}
  }

  type NewsletterGetPayload<S extends boolean | null | undefined | NewsletterDefaultArgs> = $Result.GetResult<Prisma.$NewsletterPayload, S>

  type NewsletterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterCountAggregateInputType | true
    }

  export interface NewsletterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Newsletter'], meta: { name: 'Newsletter' } }
    /**
     * Find zero or one Newsletter that matches the filter.
     * @param {NewsletterFindUniqueArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterFindUniqueArgs>(args: SelectSubset<T, NewsletterFindUniqueArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Newsletter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterFindUniqueOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindFirstArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterFindFirstArgs>(args?: SelectSubset<T, NewsletterFindFirstArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindFirstOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Newsletters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletters
     * const newsletters = await prisma.newsletter.findMany()
     * 
     * // Get first 10 Newsletters
     * const newsletters = await prisma.newsletter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterWithIdOnly = await prisma.newsletter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterFindManyArgs>(args?: SelectSubset<T, NewsletterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Newsletter.
     * @param {NewsletterCreateArgs} args - Arguments to create a Newsletter.
     * @example
     * // Create one Newsletter
     * const Newsletter = await prisma.newsletter.create({
     *   data: {
     *     // ... data to create a Newsletter
     *   }
     * })
     * 
     */
    create<T extends NewsletterCreateArgs>(args: SelectSubset<T, NewsletterCreateArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Newsletters.
     * @param {NewsletterCreateManyArgs} args - Arguments to create many Newsletters.
     * @example
     * // Create many Newsletters
     * const newsletter = await prisma.newsletter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterCreateManyArgs>(args?: SelectSubset<T, NewsletterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Newsletters and returns the data saved in the database.
     * @param {NewsletterCreateManyAndReturnArgs} args - Arguments to create many Newsletters.
     * @example
     * // Create many Newsletters
     * const newsletter = await prisma.newsletter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Newsletters and only return the `id`
     * const newsletterWithIdOnly = await prisma.newsletter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Newsletter.
     * @param {NewsletterDeleteArgs} args - Arguments to delete one Newsletter.
     * @example
     * // Delete one Newsletter
     * const Newsletter = await prisma.newsletter.delete({
     *   where: {
     *     // ... filter to delete one Newsletter
     *   }
     * })
     * 
     */
    delete<T extends NewsletterDeleteArgs>(args: SelectSubset<T, NewsletterDeleteArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Newsletter.
     * @param {NewsletterUpdateArgs} args - Arguments to update one Newsletter.
     * @example
     * // Update one Newsletter
     * const newsletter = await prisma.newsletter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterUpdateArgs>(args: SelectSubset<T, NewsletterUpdateArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Newsletters.
     * @param {NewsletterDeleteManyArgs} args - Arguments to filter Newsletters to delete.
     * @example
     * // Delete a few Newsletters
     * const { count } = await prisma.newsletter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterDeleteManyArgs>(args?: SelectSubset<T, NewsletterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletters
     * const newsletter = await prisma.newsletter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterUpdateManyArgs>(args: SelectSubset<T, NewsletterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletters and returns the data updated in the database.
     * @param {NewsletterUpdateManyAndReturnArgs} args - Arguments to update many Newsletters.
     * @example
     * // Update many Newsletters
     * const newsletter = await prisma.newsletter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Newsletters and only return the `id`
     * const newsletterWithIdOnly = await prisma.newsletter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsletterUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsletterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Newsletter.
     * @param {NewsletterUpsertArgs} args - Arguments to update or create a Newsletter.
     * @example
     * // Update or create a Newsletter
     * const newsletter = await prisma.newsletter.upsert({
     *   create: {
     *     // ... data to create a Newsletter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterUpsertArgs>(args: SelectSubset<T, NewsletterUpsertArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCountArgs} args - Arguments to filter Newsletters to count.
     * @example
     * // Count the number of Newsletters
     * const count = await prisma.newsletter.count({
     *   where: {
     *     // ... the filter for the Newsletters we want to count
     *   }
     * })
    **/
    count<T extends NewsletterCountArgs>(
      args?: Subset<T, NewsletterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterAggregateArgs>(args: Subset<T, NewsletterAggregateArgs>): Prisma.PrismaPromise<GetNewsletterAggregateType<T>>

    /**
     * Group by Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Newsletter model
   */
  readonly fields: NewsletterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Newsletter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Newsletter model
   */
  interface NewsletterFieldRefs {
    readonly id: FieldRef<"Newsletter", 'String'>
    readonly name: FieldRef<"Newsletter", 'String'>
    readonly description: FieldRef<"Newsletter", 'String'>
    readonly createdAt: FieldRef<"Newsletter", 'DateTime'>
    readonly updatedAt: FieldRef<"Newsletter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Newsletter findUnique
   */
  export type NewsletterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter findUniqueOrThrow
   */
  export type NewsletterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter findFirst
   */
  export type NewsletterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter findFirstOrThrow
   */
  export type NewsletterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter findMany
   */
  export type NewsletterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletters to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter create
   */
  export type NewsletterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data needed to create a Newsletter.
     */
    data: XOR<NewsletterCreateInput, NewsletterUncheckedCreateInput>
  }

  /**
   * Newsletter createMany
   */
  export type NewsletterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Newsletters.
     */
    data: NewsletterCreateManyInput | NewsletterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Newsletter createManyAndReturn
   */
  export type NewsletterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data used to create many Newsletters.
     */
    data: NewsletterCreateManyInput | NewsletterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Newsletter update
   */
  export type NewsletterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data needed to update a Newsletter.
     */
    data: XOR<NewsletterUpdateInput, NewsletterUncheckedUpdateInput>
    /**
     * Choose, which Newsletter to update.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter updateMany
   */
  export type NewsletterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Newsletters.
     */
    data: XOR<NewsletterUpdateManyMutationInput, NewsletterUncheckedUpdateManyInput>
    /**
     * Filter which Newsletters to update
     */
    where?: NewsletterWhereInput
    /**
     * Limit how many Newsletters to update.
     */
    limit?: number
  }

  /**
   * Newsletter updateManyAndReturn
   */
  export type NewsletterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data used to update Newsletters.
     */
    data: XOR<NewsletterUpdateManyMutationInput, NewsletterUncheckedUpdateManyInput>
    /**
     * Filter which Newsletters to update
     */
    where?: NewsletterWhereInput
    /**
     * Limit how many Newsletters to update.
     */
    limit?: number
  }

  /**
   * Newsletter upsert
   */
  export type NewsletterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The filter to search for the Newsletter to update in case it exists.
     */
    where: NewsletterWhereUniqueInput
    /**
     * In case the Newsletter found by the `where` argument doesn't exist, create a new Newsletter with this data.
     */
    create: XOR<NewsletterCreateInput, NewsletterUncheckedCreateInput>
    /**
     * In case the Newsletter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterUpdateInput, NewsletterUncheckedUpdateInput>
  }

  /**
   * Newsletter delete
   */
  export type NewsletterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter which Newsletter to delete.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter deleteMany
   */
  export type NewsletterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Newsletters to delete
     */
    where?: NewsletterWhereInput
    /**
     * Limit how many Newsletters to delete.
     */
    limit?: number
  }

  /**
   * Newsletter without action
   */
  export type NewsletterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
  }


  /**
   * Model SocialMediaAccount
   */

  export type AggregateSocialMediaAccount = {
    _count: SocialMediaAccountCountAggregateOutputType | null
    _min: SocialMediaAccountMinAggregateOutputType | null
    _max: SocialMediaAccountMaxAggregateOutputType | null
  }

  export type SocialMediaAccountMinAggregateOutputType = {
    id: string | null
    platform: string | null
    username: string | null
    accessToken: string | null
    refreshToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaAccountMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    username: string | null
    accessToken: string | null
    refreshToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaAccountCountAggregateOutputType = {
    id: number
    platform: number
    username: number
    accessToken: number
    refreshToken: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialMediaAccountMinAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaAccountMaxAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaAccountCountAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialMediaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaAccount to aggregate.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialMediaAccounts
    **/
    _count?: true | SocialMediaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMediaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMediaAccountMaxAggregateInputType
  }

  export type GetSocialMediaAccountAggregateType<T extends SocialMediaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialMediaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialMediaAccount[P]>
      : GetScalarType<T[P], AggregateSocialMediaAccount[P]>
  }




  export type SocialMediaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaAccountWhereInput
    orderBy?: SocialMediaAccountOrderByWithAggregationInput | SocialMediaAccountOrderByWithAggregationInput[]
    by: SocialMediaAccountScalarFieldEnum[] | SocialMediaAccountScalarFieldEnum
    having?: SocialMediaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialMediaAccountCountAggregateInputType | true
    _min?: SocialMediaAccountMinAggregateInputType
    _max?: SocialMediaAccountMaxAggregateInputType
  }

  export type SocialMediaAccountGroupByOutputType = {
    id: string
    platform: string
    username: string
    accessToken: string | null
    refreshToken: string | null
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: SocialMediaAccountCountAggregateOutputType | null
    _min: SocialMediaAccountMinAggregateOutputType | null
    _max: SocialMediaAccountMaxAggregateOutputType | null
  }

  type GetSocialMediaAccountGroupByPayload<T extends SocialMediaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialMediaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialMediaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialMediaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SocialMediaAccountGroupByOutputType[P]>
        }
      >
    >


  export type SocialMediaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectScalar = {
    id?: boolean
    platform?: boolean
    username?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialMediaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "username" | "accessToken" | "refreshToken" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["socialMediaAccount"]>

  export type $SocialMediaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialMediaAccount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      username: string
      accessToken: string | null
      refreshToken: string | null
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["socialMediaAccount"]>
    composites: {}
  }

  type SocialMediaAccountGetPayload<S extends boolean | null | undefined | SocialMediaAccountDefaultArgs> = $Result.GetResult<Prisma.$SocialMediaAccountPayload, S>

  type SocialMediaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialMediaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialMediaAccountCountAggregateInputType | true
    }

  export interface SocialMediaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialMediaAccount'], meta: { name: 'SocialMediaAccount' } }
    /**
     * Find zero or one SocialMediaAccount that matches the filter.
     * @param {SocialMediaAccountFindUniqueArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialMediaAccountFindUniqueArgs>(args: SelectSubset<T, SocialMediaAccountFindUniqueArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialMediaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialMediaAccountFindUniqueOrThrowArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialMediaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindFirstArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialMediaAccountFindFirstArgs>(args?: SelectSubset<T, SocialMediaAccountFindFirstArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindFirstOrThrowArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialMediaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialMediaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialMediaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialMediaAccounts
     * const socialMediaAccounts = await prisma.socialMediaAccount.findMany()
     * 
     * // Get first 10 SocialMediaAccounts
     * const socialMediaAccounts = await prisma.socialMediaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialMediaAccountFindManyArgs>(args?: SelectSubset<T, SocialMediaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialMediaAccount.
     * @param {SocialMediaAccountCreateArgs} args - Arguments to create a SocialMediaAccount.
     * @example
     * // Create one SocialMediaAccount
     * const SocialMediaAccount = await prisma.socialMediaAccount.create({
     *   data: {
     *     // ... data to create a SocialMediaAccount
     *   }
     * })
     * 
     */
    create<T extends SocialMediaAccountCreateArgs>(args: SelectSubset<T, SocialMediaAccountCreateArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialMediaAccounts.
     * @param {SocialMediaAccountCreateManyArgs} args - Arguments to create many SocialMediaAccounts.
     * @example
     * // Create many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialMediaAccountCreateManyArgs>(args?: SelectSubset<T, SocialMediaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialMediaAccounts and returns the data saved in the database.
     * @param {SocialMediaAccountCreateManyAndReturnArgs} args - Arguments to create many SocialMediaAccounts.
     * @example
     * // Create many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialMediaAccounts and only return the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialMediaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialMediaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialMediaAccount.
     * @param {SocialMediaAccountDeleteArgs} args - Arguments to delete one SocialMediaAccount.
     * @example
     * // Delete one SocialMediaAccount
     * const SocialMediaAccount = await prisma.socialMediaAccount.delete({
     *   where: {
     *     // ... filter to delete one SocialMediaAccount
     *   }
     * })
     * 
     */
    delete<T extends SocialMediaAccountDeleteArgs>(args: SelectSubset<T, SocialMediaAccountDeleteArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialMediaAccount.
     * @param {SocialMediaAccountUpdateArgs} args - Arguments to update one SocialMediaAccount.
     * @example
     * // Update one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialMediaAccountUpdateArgs>(args: SelectSubset<T, SocialMediaAccountUpdateArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialMediaAccounts.
     * @param {SocialMediaAccountDeleteManyArgs} args - Arguments to filter SocialMediaAccounts to delete.
     * @example
     * // Delete a few SocialMediaAccounts
     * const { count } = await prisma.socialMediaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialMediaAccountDeleteManyArgs>(args?: SelectSubset<T, SocialMediaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialMediaAccountUpdateManyArgs>(args: SelectSubset<T, SocialMediaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaAccounts and returns the data updated in the database.
     * @param {SocialMediaAccountUpdateManyAndReturnArgs} args - Arguments to update many SocialMediaAccounts.
     * @example
     * // Update many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialMediaAccounts and only return the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialMediaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialMediaAccount.
     * @param {SocialMediaAccountUpsertArgs} args - Arguments to update or create a SocialMediaAccount.
     * @example
     * // Update or create a SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.upsert({
     *   create: {
     *     // ... data to create a SocialMediaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialMediaAccount we want to update
     *   }
     * })
     */
    upsert<T extends SocialMediaAccountUpsertArgs>(args: SelectSubset<T, SocialMediaAccountUpsertArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialMediaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountCountArgs} args - Arguments to filter SocialMediaAccounts to count.
     * @example
     * // Count the number of SocialMediaAccounts
     * const count = await prisma.socialMediaAccount.count({
     *   where: {
     *     // ... the filter for the SocialMediaAccounts we want to count
     *   }
     * })
    **/
    count<T extends SocialMediaAccountCountArgs>(
      args?: Subset<T, SocialMediaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialMediaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialMediaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialMediaAccountAggregateArgs>(args: Subset<T, SocialMediaAccountAggregateArgs>): Prisma.PrismaPromise<GetSocialMediaAccountAggregateType<T>>

    /**
     * Group by SocialMediaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialMediaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialMediaAccountGroupByArgs['orderBy'] }
        : { orderBy?: SocialMediaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialMediaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialMediaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialMediaAccount model
   */
  readonly fields: SocialMediaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialMediaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialMediaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialMediaAccount model
   */
  interface SocialMediaAccountFieldRefs {
    readonly id: FieldRef<"SocialMediaAccount", 'String'>
    readonly platform: FieldRef<"SocialMediaAccount", 'String'>
    readonly username: FieldRef<"SocialMediaAccount", 'String'>
    readonly accessToken: FieldRef<"SocialMediaAccount", 'String'>
    readonly refreshToken: FieldRef<"SocialMediaAccount", 'String'>
    readonly isActive: FieldRef<"SocialMediaAccount", 'Boolean'>
    readonly createdAt: FieldRef<"SocialMediaAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialMediaAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialMediaAccount findUnique
   */
  export type SocialMediaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount findUniqueOrThrow
   */
  export type SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount findFirst
   */
  export type SocialMediaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaAccounts.
     */
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount findFirstOrThrow
   */
  export type SocialMediaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaAccounts.
     */
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount findMany
   */
  export type SocialMediaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccounts to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount create
   */
  export type SocialMediaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data needed to create a SocialMediaAccount.
     */
    data: XOR<SocialMediaAccountCreateInput, SocialMediaAccountUncheckedCreateInput>
  }

  /**
   * SocialMediaAccount createMany
   */
  export type SocialMediaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialMediaAccounts.
     */
    data: SocialMediaAccountCreateManyInput | SocialMediaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaAccount createManyAndReturn
   */
  export type SocialMediaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SocialMediaAccounts.
     */
    data: SocialMediaAccountCreateManyInput | SocialMediaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaAccount update
   */
  export type SocialMediaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data needed to update a SocialMediaAccount.
     */
    data: XOR<SocialMediaAccountUpdateInput, SocialMediaAccountUncheckedUpdateInput>
    /**
     * Choose, which SocialMediaAccount to update.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount updateMany
   */
  export type SocialMediaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialMediaAccounts.
     */
    data: XOR<SocialMediaAccountUpdateManyMutationInput, SocialMediaAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaAccounts to update
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to update.
     */
    limit?: number
  }

  /**
   * SocialMediaAccount updateManyAndReturn
   */
  export type SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data used to update SocialMediaAccounts.
     */
    data: XOR<SocialMediaAccountUpdateManyMutationInput, SocialMediaAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaAccounts to update
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to update.
     */
    limit?: number
  }

  /**
   * SocialMediaAccount upsert
   */
  export type SocialMediaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The filter to search for the SocialMediaAccount to update in case it exists.
     */
    where: SocialMediaAccountWhereUniqueInput
    /**
     * In case the SocialMediaAccount found by the `where` argument doesn't exist, create a new SocialMediaAccount with this data.
     */
    create: XOR<SocialMediaAccountCreateInput, SocialMediaAccountUncheckedCreateInput>
    /**
     * In case the SocialMediaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialMediaAccountUpdateInput, SocialMediaAccountUncheckedUpdateInput>
  }

  /**
   * SocialMediaAccount delete
   */
  export type SocialMediaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Filter which SocialMediaAccount to delete.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount deleteMany
   */
  export type SocialMediaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaAccounts to delete
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to delete.
     */
    limit?: number
  }

  /**
   * SocialMediaAccount without action
   */
  export type SocialMediaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
  }


  /**
   * Model SocialMediaPost
   */

  export type AggregateSocialMediaPost = {
    _count: SocialMediaPostCountAggregateOutputType | null
    _min: SocialMediaPostMinAggregateOutputType | null
    _max: SocialMediaPostMaxAggregateOutputType | null
  }

  export type SocialMediaPostMinAggregateOutputType = {
    id: string | null
    platform: string | null
    content: string | null
    status: string | null
    scheduledAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaPostMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    content: string | null
    status: string | null
    scheduledAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaPostCountAggregateOutputType = {
    id: number
    platform: number
    content: number
    mediaUrls: number
    status: number
    scheduledAt: number
    publishedAt: number
    engagement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialMediaPostMinAggregateInputType = {
    id?: true
    platform?: true
    content?: true
    status?: true
    scheduledAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaPostMaxAggregateInputType = {
    id?: true
    platform?: true
    content?: true
    status?: true
    scheduledAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaPostCountAggregateInputType = {
    id?: true
    platform?: true
    content?: true
    mediaUrls?: true
    status?: true
    scheduledAt?: true
    publishedAt?: true
    engagement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialMediaPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaPost to aggregate.
     */
    where?: SocialMediaPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaPosts to fetch.
     */
    orderBy?: SocialMediaPostOrderByWithRelationInput | SocialMediaPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialMediaPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialMediaPosts
    **/
    _count?: true | SocialMediaPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMediaPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMediaPostMaxAggregateInputType
  }

  export type GetSocialMediaPostAggregateType<T extends SocialMediaPostAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialMediaPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialMediaPost[P]>
      : GetScalarType<T[P], AggregateSocialMediaPost[P]>
  }




  export type SocialMediaPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaPostWhereInput
    orderBy?: SocialMediaPostOrderByWithAggregationInput | SocialMediaPostOrderByWithAggregationInput[]
    by: SocialMediaPostScalarFieldEnum[] | SocialMediaPostScalarFieldEnum
    having?: SocialMediaPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialMediaPostCountAggregateInputType | true
    _min?: SocialMediaPostMinAggregateInputType
    _max?: SocialMediaPostMaxAggregateInputType
  }

  export type SocialMediaPostGroupByOutputType = {
    id: string
    platform: string
    content: string
    mediaUrls: JsonValue | null
    status: string
    scheduledAt: Date | null
    publishedAt: Date | null
    engagement: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SocialMediaPostCountAggregateOutputType | null
    _min: SocialMediaPostMinAggregateOutputType | null
    _max: SocialMediaPostMaxAggregateOutputType | null
  }

  type GetSocialMediaPostGroupByPayload<T extends SocialMediaPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialMediaPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialMediaPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialMediaPostGroupByOutputType[P]>
            : GetScalarType<T[P], SocialMediaPostGroupByOutputType[P]>
        }
      >
    >


  export type SocialMediaPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    content?: boolean
    mediaUrls?: boolean
    status?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaPost"]>

  export type SocialMediaPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    content?: boolean
    mediaUrls?: boolean
    status?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaPost"]>

  export type SocialMediaPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    content?: boolean
    mediaUrls?: boolean
    status?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialMediaPost"]>

  export type SocialMediaPostSelectScalar = {
    id?: boolean
    platform?: boolean
    content?: boolean
    mediaUrls?: boolean
    status?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialMediaPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "content" | "mediaUrls" | "status" | "scheduledAt" | "publishedAt" | "engagement" | "createdAt" | "updatedAt", ExtArgs["result"]["socialMediaPost"]>

  export type $SocialMediaPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialMediaPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      content: string
      mediaUrls: Prisma.JsonValue | null
      status: string
      scheduledAt: Date | null
      publishedAt: Date | null
      engagement: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["socialMediaPost"]>
    composites: {}
  }

  type SocialMediaPostGetPayload<S extends boolean | null | undefined | SocialMediaPostDefaultArgs> = $Result.GetResult<Prisma.$SocialMediaPostPayload, S>

  type SocialMediaPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialMediaPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialMediaPostCountAggregateInputType | true
    }

  export interface SocialMediaPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialMediaPost'], meta: { name: 'SocialMediaPost' } }
    /**
     * Find zero or one SocialMediaPost that matches the filter.
     * @param {SocialMediaPostFindUniqueArgs} args - Arguments to find a SocialMediaPost
     * @example
     * // Get one SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialMediaPostFindUniqueArgs>(args: SelectSubset<T, SocialMediaPostFindUniqueArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialMediaPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialMediaPostFindUniqueOrThrowArgs} args - Arguments to find a SocialMediaPost
     * @example
     * // Get one SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialMediaPostFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialMediaPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostFindFirstArgs} args - Arguments to find a SocialMediaPost
     * @example
     * // Get one SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialMediaPostFindFirstArgs>(args?: SelectSubset<T, SocialMediaPostFindFirstArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostFindFirstOrThrowArgs} args - Arguments to find a SocialMediaPost
     * @example
     * // Get one SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialMediaPostFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialMediaPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialMediaPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialMediaPosts
     * const socialMediaPosts = await prisma.socialMediaPost.findMany()
     * 
     * // Get first 10 SocialMediaPosts
     * const socialMediaPosts = await prisma.socialMediaPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialMediaPostWithIdOnly = await prisma.socialMediaPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialMediaPostFindManyArgs>(args?: SelectSubset<T, SocialMediaPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialMediaPost.
     * @param {SocialMediaPostCreateArgs} args - Arguments to create a SocialMediaPost.
     * @example
     * // Create one SocialMediaPost
     * const SocialMediaPost = await prisma.socialMediaPost.create({
     *   data: {
     *     // ... data to create a SocialMediaPost
     *   }
     * })
     * 
     */
    create<T extends SocialMediaPostCreateArgs>(args: SelectSubset<T, SocialMediaPostCreateArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialMediaPosts.
     * @param {SocialMediaPostCreateManyArgs} args - Arguments to create many SocialMediaPosts.
     * @example
     * // Create many SocialMediaPosts
     * const socialMediaPost = await prisma.socialMediaPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialMediaPostCreateManyArgs>(args?: SelectSubset<T, SocialMediaPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialMediaPosts and returns the data saved in the database.
     * @param {SocialMediaPostCreateManyAndReturnArgs} args - Arguments to create many SocialMediaPosts.
     * @example
     * // Create many SocialMediaPosts
     * const socialMediaPost = await prisma.socialMediaPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialMediaPosts and only return the `id`
     * const socialMediaPostWithIdOnly = await prisma.socialMediaPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialMediaPostCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialMediaPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialMediaPost.
     * @param {SocialMediaPostDeleteArgs} args - Arguments to delete one SocialMediaPost.
     * @example
     * // Delete one SocialMediaPost
     * const SocialMediaPost = await prisma.socialMediaPost.delete({
     *   where: {
     *     // ... filter to delete one SocialMediaPost
     *   }
     * })
     * 
     */
    delete<T extends SocialMediaPostDeleteArgs>(args: SelectSubset<T, SocialMediaPostDeleteArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialMediaPost.
     * @param {SocialMediaPostUpdateArgs} args - Arguments to update one SocialMediaPost.
     * @example
     * // Update one SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialMediaPostUpdateArgs>(args: SelectSubset<T, SocialMediaPostUpdateArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialMediaPosts.
     * @param {SocialMediaPostDeleteManyArgs} args - Arguments to filter SocialMediaPosts to delete.
     * @example
     * // Delete a few SocialMediaPosts
     * const { count } = await prisma.socialMediaPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialMediaPostDeleteManyArgs>(args?: SelectSubset<T, SocialMediaPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialMediaPosts
     * const socialMediaPost = await prisma.socialMediaPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialMediaPostUpdateManyArgs>(args: SelectSubset<T, SocialMediaPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaPosts and returns the data updated in the database.
     * @param {SocialMediaPostUpdateManyAndReturnArgs} args - Arguments to update many SocialMediaPosts.
     * @example
     * // Update many SocialMediaPosts
     * const socialMediaPost = await prisma.socialMediaPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialMediaPosts and only return the `id`
     * const socialMediaPostWithIdOnly = await prisma.socialMediaPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialMediaPostUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialMediaPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialMediaPost.
     * @param {SocialMediaPostUpsertArgs} args - Arguments to update or create a SocialMediaPost.
     * @example
     * // Update or create a SocialMediaPost
     * const socialMediaPost = await prisma.socialMediaPost.upsert({
     *   create: {
     *     // ... data to create a SocialMediaPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialMediaPost we want to update
     *   }
     * })
     */
    upsert<T extends SocialMediaPostUpsertArgs>(args: SelectSubset<T, SocialMediaPostUpsertArgs<ExtArgs>>): Prisma__SocialMediaPostClient<$Result.GetResult<Prisma.$SocialMediaPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialMediaPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostCountArgs} args - Arguments to filter SocialMediaPosts to count.
     * @example
     * // Count the number of SocialMediaPosts
     * const count = await prisma.socialMediaPost.count({
     *   where: {
     *     // ... the filter for the SocialMediaPosts we want to count
     *   }
     * })
    **/
    count<T extends SocialMediaPostCountArgs>(
      args?: Subset<T, SocialMediaPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialMediaPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialMediaPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialMediaPostAggregateArgs>(args: Subset<T, SocialMediaPostAggregateArgs>): Prisma.PrismaPromise<GetSocialMediaPostAggregateType<T>>

    /**
     * Group by SocialMediaPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialMediaPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialMediaPostGroupByArgs['orderBy'] }
        : { orderBy?: SocialMediaPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialMediaPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialMediaPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialMediaPost model
   */
  readonly fields: SocialMediaPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialMediaPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialMediaPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialMediaPost model
   */
  interface SocialMediaPostFieldRefs {
    readonly id: FieldRef<"SocialMediaPost", 'String'>
    readonly platform: FieldRef<"SocialMediaPost", 'String'>
    readonly content: FieldRef<"SocialMediaPost", 'String'>
    readonly mediaUrls: FieldRef<"SocialMediaPost", 'Json'>
    readonly status: FieldRef<"SocialMediaPost", 'String'>
    readonly scheduledAt: FieldRef<"SocialMediaPost", 'DateTime'>
    readonly publishedAt: FieldRef<"SocialMediaPost", 'DateTime'>
    readonly engagement: FieldRef<"SocialMediaPost", 'Json'>
    readonly createdAt: FieldRef<"SocialMediaPost", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialMediaPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialMediaPost findUnique
   */
  export type SocialMediaPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaPost to fetch.
     */
    where: SocialMediaPostWhereUniqueInput
  }

  /**
   * SocialMediaPost findUniqueOrThrow
   */
  export type SocialMediaPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaPost to fetch.
     */
    where: SocialMediaPostWhereUniqueInput
  }

  /**
   * SocialMediaPost findFirst
   */
  export type SocialMediaPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaPost to fetch.
     */
    where?: SocialMediaPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaPosts to fetch.
     */
    orderBy?: SocialMediaPostOrderByWithRelationInput | SocialMediaPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaPosts.
     */
    cursor?: SocialMediaPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaPosts.
     */
    distinct?: SocialMediaPostScalarFieldEnum | SocialMediaPostScalarFieldEnum[]
  }

  /**
   * SocialMediaPost findFirstOrThrow
   */
  export type SocialMediaPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaPost to fetch.
     */
    where?: SocialMediaPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaPosts to fetch.
     */
    orderBy?: SocialMediaPostOrderByWithRelationInput | SocialMediaPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaPosts.
     */
    cursor?: SocialMediaPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaPosts.
     */
    distinct?: SocialMediaPostScalarFieldEnum | SocialMediaPostScalarFieldEnum[]
  }

  /**
   * SocialMediaPost findMany
   */
  export type SocialMediaPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter, which SocialMediaPosts to fetch.
     */
    where?: SocialMediaPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaPosts to fetch.
     */
    orderBy?: SocialMediaPostOrderByWithRelationInput | SocialMediaPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialMediaPosts.
     */
    cursor?: SocialMediaPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaPosts.
     */
    skip?: number
    distinct?: SocialMediaPostScalarFieldEnum | SocialMediaPostScalarFieldEnum[]
  }

  /**
   * SocialMediaPost create
   */
  export type SocialMediaPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * The data needed to create a SocialMediaPost.
     */
    data: XOR<SocialMediaPostCreateInput, SocialMediaPostUncheckedCreateInput>
  }

  /**
   * SocialMediaPost createMany
   */
  export type SocialMediaPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialMediaPosts.
     */
    data: SocialMediaPostCreateManyInput | SocialMediaPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaPost createManyAndReturn
   */
  export type SocialMediaPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * The data used to create many SocialMediaPosts.
     */
    data: SocialMediaPostCreateManyInput | SocialMediaPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaPost update
   */
  export type SocialMediaPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * The data needed to update a SocialMediaPost.
     */
    data: XOR<SocialMediaPostUpdateInput, SocialMediaPostUncheckedUpdateInput>
    /**
     * Choose, which SocialMediaPost to update.
     */
    where: SocialMediaPostWhereUniqueInput
  }

  /**
   * SocialMediaPost updateMany
   */
  export type SocialMediaPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialMediaPosts.
     */
    data: XOR<SocialMediaPostUpdateManyMutationInput, SocialMediaPostUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaPosts to update
     */
    where?: SocialMediaPostWhereInput
    /**
     * Limit how many SocialMediaPosts to update.
     */
    limit?: number
  }

  /**
   * SocialMediaPost updateManyAndReturn
   */
  export type SocialMediaPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * The data used to update SocialMediaPosts.
     */
    data: XOR<SocialMediaPostUpdateManyMutationInput, SocialMediaPostUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaPosts to update
     */
    where?: SocialMediaPostWhereInput
    /**
     * Limit how many SocialMediaPosts to update.
     */
    limit?: number
  }

  /**
   * SocialMediaPost upsert
   */
  export type SocialMediaPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * The filter to search for the SocialMediaPost to update in case it exists.
     */
    where: SocialMediaPostWhereUniqueInput
    /**
     * In case the SocialMediaPost found by the `where` argument doesn't exist, create a new SocialMediaPost with this data.
     */
    create: XOR<SocialMediaPostCreateInput, SocialMediaPostUncheckedCreateInput>
    /**
     * In case the SocialMediaPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialMediaPostUpdateInput, SocialMediaPostUncheckedUpdateInput>
  }

  /**
   * SocialMediaPost delete
   */
  export type SocialMediaPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
    /**
     * Filter which SocialMediaPost to delete.
     */
    where: SocialMediaPostWhereUniqueInput
  }

  /**
   * SocialMediaPost deleteMany
   */
  export type SocialMediaPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaPosts to delete
     */
    where?: SocialMediaPostWhereInput
    /**
     * Limit how many SocialMediaPosts to delete.
     */
    limit?: number
  }

  /**
   * SocialMediaPost without action
   */
  export type SocialMediaPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaPost
     */
    select?: SocialMediaPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaPost
     */
    omit?: SocialMediaPostOmit<ExtArgs> | null
  }


  /**
   * Model AffiliateProduct
   */

  export type AggregateAffiliateProduct = {
    _count: AffiliateProductCountAggregateOutputType | null
    _avg: AffiliateProductAvgAggregateOutputType | null
    _sum: AffiliateProductSumAggregateOutputType | null
    _min: AffiliateProductMinAggregateOutputType | null
    _max: AffiliateProductMaxAggregateOutputType | null
  }

  export type AffiliateProductAvgAggregateOutputType = {
    price: Decimal | null
    rating: Decimal | null
    reviewCount: number | null
  }

  export type AffiliateProductSumAggregateOutputType = {
    price: Decimal | null
    rating: Decimal | null
    reviewCount: number | null
  }

  export type AffiliateProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    affiliateUrl: string | null
    merchant: string | null
    category: string | null
    availability: boolean | null
    rating: Decimal | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    affiliateUrl: string | null
    merchant: string | null
    category: string | null
    availability: boolean | null
    rating: Decimal | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    affiliateUrl: number
    merchant: number
    category: number
    tags: number
    images: number
    specifications: number
    availability: number
    rating: number
    reviewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliateProductAvgAggregateInputType = {
    price?: true
    rating?: true
    reviewCount?: true
  }

  export type AffiliateProductSumAggregateInputType = {
    price?: true
    rating?: true
    reviewCount?: true
  }

  export type AffiliateProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    affiliateUrl?: true
    merchant?: true
    category?: true
    availability?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    affiliateUrl?: true
    merchant?: true
    category?: true
    availability?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    affiliateUrl?: true
    merchant?: true
    category?: true
    tags?: true
    images?: true
    specifications?: true
    availability?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliateProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProduct to aggregate.
     */
    where?: AffiliateProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProducts to fetch.
     */
    orderBy?: AffiliateProductOrderByWithRelationInput | AffiliateProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateProducts
    **/
    _count?: true | AffiliateProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateProductMaxAggregateInputType
  }

  export type GetAffiliateProductAggregateType<T extends AffiliateProductAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateProduct[P]>
      : GetScalarType<T[P], AggregateAffiliateProduct[P]>
  }




  export type AffiliateProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProductWhereInput
    orderBy?: AffiliateProductOrderByWithAggregationInput | AffiliateProductOrderByWithAggregationInput[]
    by: AffiliateProductScalarFieldEnum[] | AffiliateProductScalarFieldEnum
    having?: AffiliateProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateProductCountAggregateInputType | true
    _avg?: AffiliateProductAvgAggregateInputType
    _sum?: AffiliateProductSumAggregateInputType
    _min?: AffiliateProductMinAggregateInputType
    _max?: AffiliateProductMaxAggregateInputType
  }

  export type AffiliateProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: Decimal
    currency: string
    affiliateUrl: string
    merchant: string
    category: string | null
    tags: JsonValue | null
    images: JsonValue | null
    specifications: JsonValue | null
    availability: boolean
    rating: Decimal | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AffiliateProductCountAggregateOutputType | null
    _avg: AffiliateProductAvgAggregateOutputType | null
    _sum: AffiliateProductSumAggregateOutputType | null
    _min: AffiliateProductMinAggregateOutputType | null
    _max: AffiliateProductMaxAggregateOutputType | null
  }

  type GetAffiliateProductGroupByPayload<T extends AffiliateProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateProductGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateProductGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    affiliateUrl?: boolean
    merchant?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    specifications?: boolean
    availability?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["affiliateProduct"]>

  export type AffiliateProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    affiliateUrl?: boolean
    merchant?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    specifications?: boolean
    availability?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["affiliateProduct"]>

  export type AffiliateProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    affiliateUrl?: boolean
    merchant?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    specifications?: boolean
    availability?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["affiliateProduct"]>

  export type AffiliateProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    affiliateUrl?: boolean
    merchant?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    specifications?: boolean
    availability?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliateProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "affiliateUrl" | "merchant" | "category" | "tags" | "images" | "specifications" | "availability" | "rating" | "reviewCount" | "createdAt" | "updatedAt", ExtArgs["result"]["affiliateProduct"]>

  export type $AffiliateProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateProduct"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: Prisma.Decimal
      currency: string
      affiliateUrl: string
      merchant: string
      category: string | null
      tags: Prisma.JsonValue | null
      images: Prisma.JsonValue | null
      specifications: Prisma.JsonValue | null
      availability: boolean
      rating: Prisma.Decimal | null
      reviewCount: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["affiliateProduct"]>
    composites: {}
  }

  type AffiliateProductGetPayload<S extends boolean | null | undefined | AffiliateProductDefaultArgs> = $Result.GetResult<Prisma.$AffiliateProductPayload, S>

  type AffiliateProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AffiliateProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AffiliateProductCountAggregateInputType | true
    }

  export interface AffiliateProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateProduct'], meta: { name: 'AffiliateProduct' } }
    /**
     * Find zero or one AffiliateProduct that matches the filter.
     * @param {AffiliateProductFindUniqueArgs} args - Arguments to find a AffiliateProduct
     * @example
     * // Get one AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateProductFindUniqueArgs>(args: SelectSubset<T, AffiliateProductFindUniqueArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AffiliateProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AffiliateProductFindUniqueOrThrowArgs} args - Arguments to find a AffiliateProduct
     * @example
     * // Get one AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateProductFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductFindFirstArgs} args - Arguments to find a AffiliateProduct
     * @example
     * // Get one AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateProductFindFirstArgs>(args?: SelectSubset<T, AffiliateProductFindFirstArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductFindFirstOrThrowArgs} args - Arguments to find a AffiliateProduct
     * @example
     * // Get one AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateProductFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AffiliateProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateProducts
     * const affiliateProducts = await prisma.affiliateProduct.findMany()
     * 
     * // Get first 10 AffiliateProducts
     * const affiliateProducts = await prisma.affiliateProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateProductWithIdOnly = await prisma.affiliateProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateProductFindManyArgs>(args?: SelectSubset<T, AffiliateProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AffiliateProduct.
     * @param {AffiliateProductCreateArgs} args - Arguments to create a AffiliateProduct.
     * @example
     * // Create one AffiliateProduct
     * const AffiliateProduct = await prisma.affiliateProduct.create({
     *   data: {
     *     // ... data to create a AffiliateProduct
     *   }
     * })
     * 
     */
    create<T extends AffiliateProductCreateArgs>(args: SelectSubset<T, AffiliateProductCreateArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AffiliateProducts.
     * @param {AffiliateProductCreateManyArgs} args - Arguments to create many AffiliateProducts.
     * @example
     * // Create many AffiliateProducts
     * const affiliateProduct = await prisma.affiliateProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateProductCreateManyArgs>(args?: SelectSubset<T, AffiliateProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateProducts and returns the data saved in the database.
     * @param {AffiliateProductCreateManyAndReturnArgs} args - Arguments to create many AffiliateProducts.
     * @example
     * // Create many AffiliateProducts
     * const affiliateProduct = await prisma.affiliateProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateProducts and only return the `id`
     * const affiliateProductWithIdOnly = await prisma.affiliateProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateProductCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AffiliateProduct.
     * @param {AffiliateProductDeleteArgs} args - Arguments to delete one AffiliateProduct.
     * @example
     * // Delete one AffiliateProduct
     * const AffiliateProduct = await prisma.affiliateProduct.delete({
     *   where: {
     *     // ... filter to delete one AffiliateProduct
     *   }
     * })
     * 
     */
    delete<T extends AffiliateProductDeleteArgs>(args: SelectSubset<T, AffiliateProductDeleteArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AffiliateProduct.
     * @param {AffiliateProductUpdateArgs} args - Arguments to update one AffiliateProduct.
     * @example
     * // Update one AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateProductUpdateArgs>(args: SelectSubset<T, AffiliateProductUpdateArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AffiliateProducts.
     * @param {AffiliateProductDeleteManyArgs} args - Arguments to filter AffiliateProducts to delete.
     * @example
     * // Delete a few AffiliateProducts
     * const { count } = await prisma.affiliateProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateProductDeleteManyArgs>(args?: SelectSubset<T, AffiliateProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateProducts
     * const affiliateProduct = await prisma.affiliateProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateProductUpdateManyArgs>(args: SelectSubset<T, AffiliateProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateProducts and returns the data updated in the database.
     * @param {AffiliateProductUpdateManyAndReturnArgs} args - Arguments to update many AffiliateProducts.
     * @example
     * // Update many AffiliateProducts
     * const affiliateProduct = await prisma.affiliateProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AffiliateProducts and only return the `id`
     * const affiliateProductWithIdOnly = await prisma.affiliateProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AffiliateProductUpdateManyAndReturnArgs>(args: SelectSubset<T, AffiliateProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AffiliateProduct.
     * @param {AffiliateProductUpsertArgs} args - Arguments to update or create a AffiliateProduct.
     * @example
     * // Update or create a AffiliateProduct
     * const affiliateProduct = await prisma.affiliateProduct.upsert({
     *   create: {
     *     // ... data to create a AffiliateProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateProduct we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateProductUpsertArgs>(args: SelectSubset<T, AffiliateProductUpsertArgs<ExtArgs>>): Prisma__AffiliateProductClient<$Result.GetResult<Prisma.$AffiliateProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AffiliateProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductCountArgs} args - Arguments to filter AffiliateProducts to count.
     * @example
     * // Count the number of AffiliateProducts
     * const count = await prisma.affiliateProduct.count({
     *   where: {
     *     // ... the filter for the AffiliateProducts we want to count
     *   }
     * })
    **/
    count<T extends AffiliateProductCountArgs>(
      args?: Subset<T, AffiliateProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateProductAggregateArgs>(args: Subset<T, AffiliateProductAggregateArgs>): Prisma.PrismaPromise<GetAffiliateProductAggregateType<T>>

    /**
     * Group by AffiliateProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateProductGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateProduct model
   */
  readonly fields: AffiliateProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateProduct model
   */
  interface AffiliateProductFieldRefs {
    readonly id: FieldRef<"AffiliateProduct", 'String'>
    readonly name: FieldRef<"AffiliateProduct", 'String'>
    readonly description: FieldRef<"AffiliateProduct", 'String'>
    readonly price: FieldRef<"AffiliateProduct", 'Decimal'>
    readonly currency: FieldRef<"AffiliateProduct", 'String'>
    readonly affiliateUrl: FieldRef<"AffiliateProduct", 'String'>
    readonly merchant: FieldRef<"AffiliateProduct", 'String'>
    readonly category: FieldRef<"AffiliateProduct", 'String'>
    readonly tags: FieldRef<"AffiliateProduct", 'Json'>
    readonly images: FieldRef<"AffiliateProduct", 'Json'>
    readonly specifications: FieldRef<"AffiliateProduct", 'Json'>
    readonly availability: FieldRef<"AffiliateProduct", 'Boolean'>
    readonly rating: FieldRef<"AffiliateProduct", 'Decimal'>
    readonly reviewCount: FieldRef<"AffiliateProduct", 'Int'>
    readonly createdAt: FieldRef<"AffiliateProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliateProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateProduct findUnique
   */
  export type AffiliateProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateProduct to fetch.
     */
    where: AffiliateProductWhereUniqueInput
  }

  /**
   * AffiliateProduct findUniqueOrThrow
   */
  export type AffiliateProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateProduct to fetch.
     */
    where: AffiliateProductWhereUniqueInput
  }

  /**
   * AffiliateProduct findFirst
   */
  export type AffiliateProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateProduct to fetch.
     */
    where?: AffiliateProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProducts to fetch.
     */
    orderBy?: AffiliateProductOrderByWithRelationInput | AffiliateProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProducts.
     */
    cursor?: AffiliateProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProducts.
     */
    distinct?: AffiliateProductScalarFieldEnum | AffiliateProductScalarFieldEnum[]
  }

  /**
   * AffiliateProduct findFirstOrThrow
   */
  export type AffiliateProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateProduct to fetch.
     */
    where?: AffiliateProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProducts to fetch.
     */
    orderBy?: AffiliateProductOrderByWithRelationInput | AffiliateProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProducts.
     */
    cursor?: AffiliateProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProducts.
     */
    distinct?: AffiliateProductScalarFieldEnum | AffiliateProductScalarFieldEnum[]
  }

  /**
   * AffiliateProduct findMany
   */
  export type AffiliateProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateProducts to fetch.
     */
    where?: AffiliateProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProducts to fetch.
     */
    orderBy?: AffiliateProductOrderByWithRelationInput | AffiliateProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateProducts.
     */
    cursor?: AffiliateProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProducts.
     */
    skip?: number
    distinct?: AffiliateProductScalarFieldEnum | AffiliateProductScalarFieldEnum[]
  }

  /**
   * AffiliateProduct create
   */
  export type AffiliateProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * The data needed to create a AffiliateProduct.
     */
    data: XOR<AffiliateProductCreateInput, AffiliateProductUncheckedCreateInput>
  }

  /**
   * AffiliateProduct createMany
   */
  export type AffiliateProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateProducts.
     */
    data: AffiliateProductCreateManyInput | AffiliateProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateProduct createManyAndReturn
   */
  export type AffiliateProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * The data used to create many AffiliateProducts.
     */
    data: AffiliateProductCreateManyInput | AffiliateProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateProduct update
   */
  export type AffiliateProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * The data needed to update a AffiliateProduct.
     */
    data: XOR<AffiliateProductUpdateInput, AffiliateProductUncheckedUpdateInput>
    /**
     * Choose, which AffiliateProduct to update.
     */
    where: AffiliateProductWhereUniqueInput
  }

  /**
   * AffiliateProduct updateMany
   */
  export type AffiliateProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateProducts.
     */
    data: XOR<AffiliateProductUpdateManyMutationInput, AffiliateProductUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateProducts to update
     */
    where?: AffiliateProductWhereInput
    /**
     * Limit how many AffiliateProducts to update.
     */
    limit?: number
  }

  /**
   * AffiliateProduct updateManyAndReturn
   */
  export type AffiliateProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * The data used to update AffiliateProducts.
     */
    data: XOR<AffiliateProductUpdateManyMutationInput, AffiliateProductUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateProducts to update
     */
    where?: AffiliateProductWhereInput
    /**
     * Limit how many AffiliateProducts to update.
     */
    limit?: number
  }

  /**
   * AffiliateProduct upsert
   */
  export type AffiliateProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * The filter to search for the AffiliateProduct to update in case it exists.
     */
    where: AffiliateProductWhereUniqueInput
    /**
     * In case the AffiliateProduct found by the `where` argument doesn't exist, create a new AffiliateProduct with this data.
     */
    create: XOR<AffiliateProductCreateInput, AffiliateProductUncheckedCreateInput>
    /**
     * In case the AffiliateProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateProductUpdateInput, AffiliateProductUncheckedUpdateInput>
  }

  /**
   * AffiliateProduct delete
   */
  export type AffiliateProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
    /**
     * Filter which AffiliateProduct to delete.
     */
    where: AffiliateProductWhereUniqueInput
  }

  /**
   * AffiliateProduct deleteMany
   */
  export type AffiliateProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProducts to delete
     */
    where?: AffiliateProductWhereInput
    /**
     * Limit how many AffiliateProducts to delete.
     */
    limit?: number
  }

  /**
   * AffiliateProduct without action
   */
  export type AffiliateProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProduct
     */
    select?: AffiliateProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateProduct
     */
    omit?: AffiliateProductOmit<ExtArgs> | null
  }


  /**
   * Model AffiliateLinkClick
   */

  export type AggregateAffiliateLinkClick = {
    _count: AffiliateLinkClickCountAggregateOutputType | null
    _avg: AffiliateLinkClickAvgAggregateOutputType | null
    _sum: AffiliateLinkClickSumAggregateOutputType | null
    _min: AffiliateLinkClickMinAggregateOutputType | null
    _max: AffiliateLinkClickMaxAggregateOutputType | null
  }

  export type AffiliateLinkClickAvgAggregateOutputType = {
    conversionValue: Decimal | null
  }

  export type AffiliateLinkClickSumAggregateOutputType = {
    conversionValue: Decimal | null
  }

  export type AffiliateLinkClickMinAggregateOutputType = {
    id: string | null
    affiliateUrl: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionValue: Decimal | null
  }

  export type AffiliateLinkClickMaxAggregateOutputType = {
    id: string | null
    affiliateUrl: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionValue: Decimal | null
  }

  export type AffiliateLinkClickCountAggregateOutputType = {
    id: number
    affiliateUrl: number
    ipAddress: number
    userAgent: number
    referrer: number
    clickedAt: number
    conversionValue: number
    _all: number
  }


  export type AffiliateLinkClickAvgAggregateInputType = {
    conversionValue?: true
  }

  export type AffiliateLinkClickSumAggregateInputType = {
    conversionValue?: true
  }

  export type AffiliateLinkClickMinAggregateInputType = {
    id?: true
    affiliateUrl?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionValue?: true
  }

  export type AffiliateLinkClickMaxAggregateInputType = {
    id?: true
    affiliateUrl?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionValue?: true
  }

  export type AffiliateLinkClickCountAggregateInputType = {
    id?: true
    affiliateUrl?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    clickedAt?: true
    conversionValue?: true
    _all?: true
  }

  export type AffiliateLinkClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLinkClick to aggregate.
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinkClicks to fetch.
     */
    orderBy?: AffiliateLinkClickOrderByWithRelationInput | AffiliateLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateLinkClicks
    **/
    _count?: true | AffiliateLinkClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateLinkClickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateLinkClickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateLinkClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateLinkClickMaxAggregateInputType
  }

  export type GetAffiliateLinkClickAggregateType<T extends AffiliateLinkClickAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateLinkClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateLinkClick[P]>
      : GetScalarType<T[P], AggregateAffiliateLinkClick[P]>
  }




  export type AffiliateLinkClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkClickWhereInput
    orderBy?: AffiliateLinkClickOrderByWithAggregationInput | AffiliateLinkClickOrderByWithAggregationInput[]
    by: AffiliateLinkClickScalarFieldEnum[] | AffiliateLinkClickScalarFieldEnum
    having?: AffiliateLinkClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateLinkClickCountAggregateInputType | true
    _avg?: AffiliateLinkClickAvgAggregateInputType
    _sum?: AffiliateLinkClickSumAggregateInputType
    _min?: AffiliateLinkClickMinAggregateInputType
    _max?: AffiliateLinkClickMaxAggregateInputType
  }

  export type AffiliateLinkClickGroupByOutputType = {
    id: string
    affiliateUrl: string
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    clickedAt: Date | null
    conversionValue: Decimal | null
    _count: AffiliateLinkClickCountAggregateOutputType | null
    _avg: AffiliateLinkClickAvgAggregateOutputType | null
    _sum: AffiliateLinkClickSumAggregateOutputType | null
    _min: AffiliateLinkClickMinAggregateOutputType | null
    _max: AffiliateLinkClickMaxAggregateOutputType | null
  }

  type GetAffiliateLinkClickGroupByPayload<T extends AffiliateLinkClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateLinkClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateLinkClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateLinkClickGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateLinkClickGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateLinkClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateUrl?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionValue?: boolean
  }, ExtArgs["result"]["affiliateLinkClick"]>

  export type AffiliateLinkClickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateUrl?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionValue?: boolean
  }, ExtArgs["result"]["affiliateLinkClick"]>

  export type AffiliateLinkClickSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateUrl?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionValue?: boolean
  }, ExtArgs["result"]["affiliateLinkClick"]>

  export type AffiliateLinkClickSelectScalar = {
    id?: boolean
    affiliateUrl?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    clickedAt?: boolean
    conversionValue?: boolean
  }

  export type AffiliateLinkClickOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliateUrl" | "ipAddress" | "userAgent" | "referrer" | "clickedAt" | "conversionValue", ExtArgs["result"]["affiliateLinkClick"]>

  export type $AffiliateLinkClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateLinkClick"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateUrl: string
      ipAddress: string | null
      userAgent: string | null
      referrer: string | null
      clickedAt: Date | null
      conversionValue: Prisma.Decimal | null
    }, ExtArgs["result"]["affiliateLinkClick"]>
    composites: {}
  }

  type AffiliateLinkClickGetPayload<S extends boolean | null | undefined | AffiliateLinkClickDefaultArgs> = $Result.GetResult<Prisma.$AffiliateLinkClickPayload, S>

  type AffiliateLinkClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AffiliateLinkClickFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AffiliateLinkClickCountAggregateInputType | true
    }

  export interface AffiliateLinkClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateLinkClick'], meta: { name: 'AffiliateLinkClick' } }
    /**
     * Find zero or one AffiliateLinkClick that matches the filter.
     * @param {AffiliateLinkClickFindUniqueArgs} args - Arguments to find a AffiliateLinkClick
     * @example
     * // Get one AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateLinkClickFindUniqueArgs>(args: SelectSubset<T, AffiliateLinkClickFindUniqueArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AffiliateLinkClick that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AffiliateLinkClickFindUniqueOrThrowArgs} args - Arguments to find a AffiliateLinkClick
     * @example
     * // Get one AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateLinkClickFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateLinkClickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateLinkClick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickFindFirstArgs} args - Arguments to find a AffiliateLinkClick
     * @example
     * // Get one AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateLinkClickFindFirstArgs>(args?: SelectSubset<T, AffiliateLinkClickFindFirstArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AffiliateLinkClick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickFindFirstOrThrowArgs} args - Arguments to find a AffiliateLinkClick
     * @example
     * // Get one AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateLinkClickFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateLinkClickFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AffiliateLinkClicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateLinkClicks
     * const affiliateLinkClicks = await prisma.affiliateLinkClick.findMany()
     * 
     * // Get first 10 AffiliateLinkClicks
     * const affiliateLinkClicks = await prisma.affiliateLinkClick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateLinkClickWithIdOnly = await prisma.affiliateLinkClick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateLinkClickFindManyArgs>(args?: SelectSubset<T, AffiliateLinkClickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AffiliateLinkClick.
     * @param {AffiliateLinkClickCreateArgs} args - Arguments to create a AffiliateLinkClick.
     * @example
     * // Create one AffiliateLinkClick
     * const AffiliateLinkClick = await prisma.affiliateLinkClick.create({
     *   data: {
     *     // ... data to create a AffiliateLinkClick
     *   }
     * })
     * 
     */
    create<T extends AffiliateLinkClickCreateArgs>(args: SelectSubset<T, AffiliateLinkClickCreateArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AffiliateLinkClicks.
     * @param {AffiliateLinkClickCreateManyArgs} args - Arguments to create many AffiliateLinkClicks.
     * @example
     * // Create many AffiliateLinkClicks
     * const affiliateLinkClick = await prisma.affiliateLinkClick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateLinkClickCreateManyArgs>(args?: SelectSubset<T, AffiliateLinkClickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateLinkClicks and returns the data saved in the database.
     * @param {AffiliateLinkClickCreateManyAndReturnArgs} args - Arguments to create many AffiliateLinkClicks.
     * @example
     * // Create many AffiliateLinkClicks
     * const affiliateLinkClick = await prisma.affiliateLinkClick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateLinkClicks and only return the `id`
     * const affiliateLinkClickWithIdOnly = await prisma.affiliateLinkClick.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateLinkClickCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateLinkClickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AffiliateLinkClick.
     * @param {AffiliateLinkClickDeleteArgs} args - Arguments to delete one AffiliateLinkClick.
     * @example
     * // Delete one AffiliateLinkClick
     * const AffiliateLinkClick = await prisma.affiliateLinkClick.delete({
     *   where: {
     *     // ... filter to delete one AffiliateLinkClick
     *   }
     * })
     * 
     */
    delete<T extends AffiliateLinkClickDeleteArgs>(args: SelectSubset<T, AffiliateLinkClickDeleteArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AffiliateLinkClick.
     * @param {AffiliateLinkClickUpdateArgs} args - Arguments to update one AffiliateLinkClick.
     * @example
     * // Update one AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateLinkClickUpdateArgs>(args: SelectSubset<T, AffiliateLinkClickUpdateArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AffiliateLinkClicks.
     * @param {AffiliateLinkClickDeleteManyArgs} args - Arguments to filter AffiliateLinkClicks to delete.
     * @example
     * // Delete a few AffiliateLinkClicks
     * const { count } = await prisma.affiliateLinkClick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateLinkClickDeleteManyArgs>(args?: SelectSubset<T, AffiliateLinkClickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateLinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateLinkClicks
     * const affiliateLinkClick = await prisma.affiliateLinkClick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateLinkClickUpdateManyArgs>(args: SelectSubset<T, AffiliateLinkClickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateLinkClicks and returns the data updated in the database.
     * @param {AffiliateLinkClickUpdateManyAndReturnArgs} args - Arguments to update many AffiliateLinkClicks.
     * @example
     * // Update many AffiliateLinkClicks
     * const affiliateLinkClick = await prisma.affiliateLinkClick.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AffiliateLinkClicks and only return the `id`
     * const affiliateLinkClickWithIdOnly = await prisma.affiliateLinkClick.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AffiliateLinkClickUpdateManyAndReturnArgs>(args: SelectSubset<T, AffiliateLinkClickUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AffiliateLinkClick.
     * @param {AffiliateLinkClickUpsertArgs} args - Arguments to update or create a AffiliateLinkClick.
     * @example
     * // Update or create a AffiliateLinkClick
     * const affiliateLinkClick = await prisma.affiliateLinkClick.upsert({
     *   create: {
     *     // ... data to create a AffiliateLinkClick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateLinkClick we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateLinkClickUpsertArgs>(args: SelectSubset<T, AffiliateLinkClickUpsertArgs<ExtArgs>>): Prisma__AffiliateLinkClickClient<$Result.GetResult<Prisma.$AffiliateLinkClickPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AffiliateLinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickCountArgs} args - Arguments to filter AffiliateLinkClicks to count.
     * @example
     * // Count the number of AffiliateLinkClicks
     * const count = await prisma.affiliateLinkClick.count({
     *   where: {
     *     // ... the filter for the AffiliateLinkClicks we want to count
     *   }
     * })
    **/
    count<T extends AffiliateLinkClickCountArgs>(
      args?: Subset<T, AffiliateLinkClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateLinkClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateLinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateLinkClickAggregateArgs>(args: Subset<T, AffiliateLinkClickAggregateArgs>): Prisma.PrismaPromise<GetAffiliateLinkClickAggregateType<T>>

    /**
     * Group by AffiliateLinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateLinkClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateLinkClickGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateLinkClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateLinkClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateLinkClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateLinkClick model
   */
  readonly fields: AffiliateLinkClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateLinkClick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateLinkClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateLinkClick model
   */
  interface AffiliateLinkClickFieldRefs {
    readonly id: FieldRef<"AffiliateLinkClick", 'String'>
    readonly affiliateUrl: FieldRef<"AffiliateLinkClick", 'String'>
    readonly ipAddress: FieldRef<"AffiliateLinkClick", 'String'>
    readonly userAgent: FieldRef<"AffiliateLinkClick", 'String'>
    readonly referrer: FieldRef<"AffiliateLinkClick", 'String'>
    readonly clickedAt: FieldRef<"AffiliateLinkClick", 'DateTime'>
    readonly conversionValue: FieldRef<"AffiliateLinkClick", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateLinkClick findUnique
   */
  export type AffiliateLinkClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateLinkClick to fetch.
     */
    where: AffiliateLinkClickWhereUniqueInput
  }

  /**
   * AffiliateLinkClick findUniqueOrThrow
   */
  export type AffiliateLinkClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateLinkClick to fetch.
     */
    where: AffiliateLinkClickWhereUniqueInput
  }

  /**
   * AffiliateLinkClick findFirst
   */
  export type AffiliateLinkClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateLinkClick to fetch.
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinkClicks to fetch.
     */
    orderBy?: AffiliateLinkClickOrderByWithRelationInput | AffiliateLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinkClicks.
     */
    cursor?: AffiliateLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinkClicks.
     */
    distinct?: AffiliateLinkClickScalarFieldEnum | AffiliateLinkClickScalarFieldEnum[]
  }

  /**
   * AffiliateLinkClick findFirstOrThrow
   */
  export type AffiliateLinkClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateLinkClick to fetch.
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinkClicks to fetch.
     */
    orderBy?: AffiliateLinkClickOrderByWithRelationInput | AffiliateLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinkClicks.
     */
    cursor?: AffiliateLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinkClicks.
     */
    distinct?: AffiliateLinkClickScalarFieldEnum | AffiliateLinkClickScalarFieldEnum[]
  }

  /**
   * AffiliateLinkClick findMany
   */
  export type AffiliateLinkClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter, which AffiliateLinkClicks to fetch.
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinkClicks to fetch.
     */
    orderBy?: AffiliateLinkClickOrderByWithRelationInput | AffiliateLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateLinkClicks.
     */
    cursor?: AffiliateLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinkClicks.
     */
    skip?: number
    distinct?: AffiliateLinkClickScalarFieldEnum | AffiliateLinkClickScalarFieldEnum[]
  }

  /**
   * AffiliateLinkClick create
   */
  export type AffiliateLinkClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * The data needed to create a AffiliateLinkClick.
     */
    data: XOR<AffiliateLinkClickCreateInput, AffiliateLinkClickUncheckedCreateInput>
  }

  /**
   * AffiliateLinkClick createMany
   */
  export type AffiliateLinkClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateLinkClicks.
     */
    data: AffiliateLinkClickCreateManyInput | AffiliateLinkClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateLinkClick createManyAndReturn
   */
  export type AffiliateLinkClickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * The data used to create many AffiliateLinkClicks.
     */
    data: AffiliateLinkClickCreateManyInput | AffiliateLinkClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateLinkClick update
   */
  export type AffiliateLinkClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * The data needed to update a AffiliateLinkClick.
     */
    data: XOR<AffiliateLinkClickUpdateInput, AffiliateLinkClickUncheckedUpdateInput>
    /**
     * Choose, which AffiliateLinkClick to update.
     */
    where: AffiliateLinkClickWhereUniqueInput
  }

  /**
   * AffiliateLinkClick updateMany
   */
  export type AffiliateLinkClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateLinkClicks.
     */
    data: XOR<AffiliateLinkClickUpdateManyMutationInput, AffiliateLinkClickUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateLinkClicks to update
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * Limit how many AffiliateLinkClicks to update.
     */
    limit?: number
  }

  /**
   * AffiliateLinkClick updateManyAndReturn
   */
  export type AffiliateLinkClickUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * The data used to update AffiliateLinkClicks.
     */
    data: XOR<AffiliateLinkClickUpdateManyMutationInput, AffiliateLinkClickUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateLinkClicks to update
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * Limit how many AffiliateLinkClicks to update.
     */
    limit?: number
  }

  /**
   * AffiliateLinkClick upsert
   */
  export type AffiliateLinkClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * The filter to search for the AffiliateLinkClick to update in case it exists.
     */
    where: AffiliateLinkClickWhereUniqueInput
    /**
     * In case the AffiliateLinkClick found by the `where` argument doesn't exist, create a new AffiliateLinkClick with this data.
     */
    create: XOR<AffiliateLinkClickCreateInput, AffiliateLinkClickUncheckedCreateInput>
    /**
     * In case the AffiliateLinkClick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateLinkClickUpdateInput, AffiliateLinkClickUncheckedUpdateInput>
  }

  /**
   * AffiliateLinkClick delete
   */
  export type AffiliateLinkClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
    /**
     * Filter which AffiliateLinkClick to delete.
     */
    where: AffiliateLinkClickWhereUniqueInput
  }

  /**
   * AffiliateLinkClick deleteMany
   */
  export type AffiliateLinkClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLinkClicks to delete
     */
    where?: AffiliateLinkClickWhereInput
    /**
     * Limit how many AffiliateLinkClicks to delete.
     */
    limit?: number
  }

  /**
   * AffiliateLinkClick without action
   */
  export type AffiliateLinkClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkClick
     */
    select?: AffiliateLinkClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AffiliateLinkClick
     */
    omit?: AffiliateLinkClickOmit<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    prepTime: number | null
    cookTime: number | null
    servings: number | null
  }

  export type RecipeSumAggregateOutputType = {
    prepTime: number | null
    cookTime: number | null
    servings: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    prepTime: number | null
    cookTime: number | null
    servings: number | null
    difficulty: string | null
    cuisine: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    prepTime: number | null
    cookTime: number | null
    servings: number | null
    difficulty: string | null
    cuisine: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    prepTime: number
    cookTime: number
    servings: number
    difficulty: number
    cuisine: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    prepTime?: true
    cookTime?: true
    servings?: true
  }

  export type RecipeSumAggregateInputType = {
    prepTime?: true
    cookTime?: true
    servings?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prepTime?: true
    cookTime?: true
    servings?: true
    difficulty?: true
    cuisine?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prepTime?: true
    cookTime?: true
    servings?: true
    difficulty?: true
    cuisine?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prepTime?: true
    cookTime?: true
    servings?: true
    difficulty?: true
    cuisine?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    title: string
    description: string | null
    prepTime: number | null
    cookTime: number | null
    servings: number | null
    difficulty: string | null
    cuisine: string | null
    tags: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prepTime?: boolean
    cookTime?: boolean
    servings?: boolean
    difficulty?: boolean
    cuisine?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prepTime?: boolean
    cookTime?: boolean
    servings?: boolean
    difficulty?: boolean
    cuisine?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prepTime?: boolean
    cookTime?: boolean
    servings?: boolean
    difficulty?: boolean
    cuisine?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    prepTime?: boolean
    cookTime?: boolean
    servings?: boolean
    difficulty?: boolean
    cuisine?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "prepTime" | "cookTime" | "servings" | "difficulty" | "cuisine" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["recipe"]>
  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      ingredients: Prisma.$RecipeIngredientPayload<ExtArgs>[]
      instructions: Prisma.$RecipeInstructionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      prepTime: number | null
      cookTime: number | null
      servings: number | null
      difficulty: string | null
      cuisine: string | null
      tags: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes and returns the data updated in the database.
     * @param {RecipeUpdateManyAndReturnArgs} args - Arguments to update many Recipes.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ingredients<T extends Recipe$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructions<T extends Recipe$instructionsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$instructionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly title: FieldRef<"Recipe", 'String'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly prepTime: FieldRef<"Recipe", 'Int'>
    readonly cookTime: FieldRef<"Recipe", 'Int'>
    readonly servings: FieldRef<"Recipe", 'Int'>
    readonly difficulty: FieldRef<"Recipe", 'String'>
    readonly cuisine: FieldRef<"Recipe", 'String'>
    readonly tags: FieldRef<"Recipe", 'Json'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe updateManyAndReturn
   */
  export type RecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to delete.
     */
    limit?: number
  }

  /**
   * Recipe.ingredients
   */
  export type Recipe$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * Recipe.instructions
   */
  export type Recipe$instructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    where?: RecipeInstructionWhereInput
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    cursor?: RecipeInstructionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeIngredient
   */

  export type AggregateRecipeIngredient = {
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  export type RecipeIngredientAvgAggregateOutputType = {
    amount: Decimal | null
    order: number | null
  }

  export type RecipeIngredientSumAggregateOutputType = {
    amount: Decimal | null
    order: number | null
  }

  export type RecipeIngredientMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    name: string | null
    amount: Decimal | null
    unit: string | null
    notes: string | null
    order: number | null
    createdAt: Date | null
  }

  export type RecipeIngredientMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    name: string | null
    amount: Decimal | null
    unit: string | null
    notes: string | null
    order: number | null
    createdAt: Date | null
  }

  export type RecipeIngredientCountAggregateOutputType = {
    id: number
    recipeId: number
    name: number
    amount: number
    unit: number
    notes: number
    order: number
    createdAt: number
    _all: number
  }


  export type RecipeIngredientAvgAggregateInputType = {
    amount?: true
    order?: true
  }

  export type RecipeIngredientSumAggregateInputType = {
    amount?: true
    order?: true
  }

  export type RecipeIngredientMinAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
    order?: true
    createdAt?: true
  }

  export type RecipeIngredientMaxAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
    order?: true
    createdAt?: true
  }

  export type RecipeIngredientCountAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type RecipeIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredient to aggregate.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeIngredients
    **/
    _count?: true | RecipeIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type GetRecipeIngredientAggregateType<T extends RecipeIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeIngredient[P]>
      : GetScalarType<T[P], AggregateRecipeIngredient[P]>
  }




  export type RecipeIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithAggregationInput | RecipeIngredientOrderByWithAggregationInput[]
    by: RecipeIngredientScalarFieldEnum[] | RecipeIngredientScalarFieldEnum
    having?: RecipeIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeIngredientCountAggregateInputType | true
    _avg?: RecipeIngredientAvgAggregateInputType
    _sum?: RecipeIngredientSumAggregateInputType
    _min?: RecipeIngredientMinAggregateInputType
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type RecipeIngredientGroupByOutputType = {
    id: string
    recipeId: string
    name: string
    amount: Decimal
    unit: string
    notes: string | null
    order: number
    createdAt: Date | null
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  type GetRecipeIngredientGroupByPayload<T extends RecipeIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
        }
      >
    >


  export type RecipeIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    order?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    order?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    order?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectScalar = {
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type RecipeIngredientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "name" | "amount" | "unit" | "notes" | "order" | "createdAt", ExtArgs["result"]["recipeIngredient"]>
  export type RecipeIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeIngredient"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      name: string
      amount: Prisma.Decimal
      unit: string
      notes: string | null
      order: number
      createdAt: Date | null
    }, ExtArgs["result"]["recipeIngredient"]>
    composites: {}
  }

  type RecipeIngredientGetPayload<S extends boolean | null | undefined | RecipeIngredientDefaultArgs> = $Result.GetResult<Prisma.$RecipeIngredientPayload, S>

  type RecipeIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeIngredientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeIngredientCountAggregateInputType | true
    }

  export interface RecipeIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeIngredient'], meta: { name: 'RecipeIngredient' } }
    /**
     * Find zero or one RecipeIngredient that matches the filter.
     * @param {RecipeIngredientFindUniqueArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeIngredientFindUniqueArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeIngredient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeIngredientFindUniqueOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeIngredientFindFirstArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany()
     * 
     * // Get first 10 RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeIngredientFindManyArgs>(args?: SelectSubset<T, RecipeIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeIngredient.
     * @param {RecipeIngredientCreateArgs} args - Arguments to create a RecipeIngredient.
     * @example
     * // Create one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.create({
     *   data: {
     *     // ... data to create a RecipeIngredient
     *   }
     * })
     * 
     */
    create<T extends RecipeIngredientCreateArgs>(args: SelectSubset<T, RecipeIngredientCreateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeIngredients.
     * @param {RecipeIngredientCreateManyArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeIngredientCreateManyArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeIngredients and returns the data saved in the database.
     * @param {RecipeIngredientCreateManyAndReturnArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeIngredients and only return the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeIngredient.
     * @param {RecipeIngredientDeleteArgs} args - Arguments to delete one RecipeIngredient.
     * @example
     * // Delete one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.delete({
     *   where: {
     *     // ... filter to delete one RecipeIngredient
     *   }
     * })
     * 
     */
    delete<T extends RecipeIngredientDeleteArgs>(args: SelectSubset<T, RecipeIngredientDeleteArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeIngredient.
     * @param {RecipeIngredientUpdateArgs} args - Arguments to update one RecipeIngredient.
     * @example
     * // Update one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeIngredientUpdateArgs>(args: SelectSubset<T, RecipeIngredientUpdateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeIngredients.
     * @param {RecipeIngredientDeleteManyArgs} args - Arguments to filter RecipeIngredients to delete.
     * @example
     * // Delete a few RecipeIngredients
     * const { count } = await prisma.recipeIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeIngredientDeleteManyArgs>(args?: SelectSubset<T, RecipeIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeIngredientUpdateManyArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients and returns the data updated in the database.
     * @param {RecipeIngredientUpdateManyAndReturnArgs} args - Arguments to update many RecipeIngredients.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeIngredients and only return the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeIngredientUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeIngredient.
     * @param {RecipeIngredientUpsertArgs} args - Arguments to update or create a RecipeIngredient.
     * @example
     * // Update or create a RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.upsert({
     *   create: {
     *     // ... data to create a RecipeIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeIngredient we want to update
     *   }
     * })
     */
    upsert<T extends RecipeIngredientUpsertArgs>(args: SelectSubset<T, RecipeIngredientUpsertArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientCountArgs} args - Arguments to filter RecipeIngredients to count.
     * @example
     * // Count the number of RecipeIngredients
     * const count = await prisma.recipeIngredient.count({
     *   where: {
     *     // ... the filter for the RecipeIngredients we want to count
     *   }
     * })
    **/
    count<T extends RecipeIngredientCountArgs>(
      args?: Subset<T, RecipeIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeIngredientAggregateArgs>(args: Subset<T, RecipeIngredientAggregateArgs>): Prisma.PrismaPromise<GetRecipeIngredientAggregateType<T>>

    /**
     * Group by RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeIngredientGroupByArgs['orderBy'] }
        : { orderBy?: RecipeIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeIngredient model
   */
  readonly fields: RecipeIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeIngredient model
   */
  interface RecipeIngredientFieldRefs {
    readonly id: FieldRef<"RecipeIngredient", 'String'>
    readonly recipeId: FieldRef<"RecipeIngredient", 'String'>
    readonly name: FieldRef<"RecipeIngredient", 'String'>
    readonly amount: FieldRef<"RecipeIngredient", 'Decimal'>
    readonly unit: FieldRef<"RecipeIngredient", 'String'>
    readonly notes: FieldRef<"RecipeIngredient", 'String'>
    readonly order: FieldRef<"RecipeIngredient", 'Int'>
    readonly createdAt: FieldRef<"RecipeIngredient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecipeIngredient findUnique
   */
  export type RecipeIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findUniqueOrThrow
   */
  export type RecipeIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findFirst
   */
  export type RecipeIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findFirstOrThrow
   */
  export type RecipeIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findMany
   */
  export type RecipeIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredients to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient create
   */
  export type RecipeIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeIngredient.
     */
    data: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
  }

  /**
   * RecipeIngredient createMany
   */
  export type RecipeIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeIngredient createManyAndReturn
   */
  export type RecipeIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient update
   */
  export type RecipeIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeIngredient.
     */
    data: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
    /**
     * Choose, which RecipeIngredient to update.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient updateMany
   */
  export type RecipeIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
  }

  /**
   * RecipeIngredient updateManyAndReturn
   */
  export type RecipeIngredientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient upsert
   */
  export type RecipeIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeIngredient to update in case it exists.
     */
    where: RecipeIngredientWhereUniqueInput
    /**
     * In case the RecipeIngredient found by the `where` argument doesn't exist, create a new RecipeIngredient with this data.
     */
    create: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
    /**
     * In case the RecipeIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
  }

  /**
   * RecipeIngredient delete
   */
  export type RecipeIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter which RecipeIngredient to delete.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient deleteMany
   */
  export type RecipeIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredients to delete
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to delete.
     */
    limit?: number
  }

  /**
   * RecipeIngredient without action
   */
  export type RecipeIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
  }


  /**
   * Model RecipeInstruction
   */

  export type AggregateRecipeInstruction = {
    _count: RecipeInstructionCountAggregateOutputType | null
    _avg: RecipeInstructionAvgAggregateOutputType | null
    _sum: RecipeInstructionSumAggregateOutputType | null
    _min: RecipeInstructionMinAggregateOutputType | null
    _max: RecipeInstructionMaxAggregateOutputType | null
  }

  export type RecipeInstructionAvgAggregateOutputType = {
    stepNumber: number | null
  }

  export type RecipeInstructionSumAggregateOutputType = {
    stepNumber: number | null
  }

  export type RecipeInstructionMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    stepNumber: number | null
    instruction: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type RecipeInstructionMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    stepNumber: number | null
    instruction: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type RecipeInstructionCountAggregateOutputType = {
    id: number
    recipeId: number
    stepNumber: number
    instruction: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type RecipeInstructionAvgAggregateInputType = {
    stepNumber?: true
  }

  export type RecipeInstructionSumAggregateInputType = {
    stepNumber?: true
  }

  export type RecipeInstructionMinAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
    imageUrl?: true
    createdAt?: true
  }

  export type RecipeInstructionMaxAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
    imageUrl?: true
    createdAt?: true
  }

  export type RecipeInstructionCountAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type RecipeInstructionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInstruction to aggregate.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeInstructions
    **/
    _count?: true | RecipeInstructionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeInstructionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeInstructionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeInstructionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeInstructionMaxAggregateInputType
  }

  export type GetRecipeInstructionAggregateType<T extends RecipeInstructionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeInstruction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeInstruction[P]>
      : GetScalarType<T[P], AggregateRecipeInstruction[P]>
  }




  export type RecipeInstructionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInstructionWhereInput
    orderBy?: RecipeInstructionOrderByWithAggregationInput | RecipeInstructionOrderByWithAggregationInput[]
    by: RecipeInstructionScalarFieldEnum[] | RecipeInstructionScalarFieldEnum
    having?: RecipeInstructionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeInstructionCountAggregateInputType | true
    _avg?: RecipeInstructionAvgAggregateInputType
    _sum?: RecipeInstructionSumAggregateInputType
    _min?: RecipeInstructionMinAggregateInputType
    _max?: RecipeInstructionMaxAggregateInputType
  }

  export type RecipeInstructionGroupByOutputType = {
    id: string
    recipeId: string
    stepNumber: number
    instruction: string
    imageUrl: string | null
    createdAt: Date | null
    _count: RecipeInstructionCountAggregateOutputType | null
    _avg: RecipeInstructionAvgAggregateOutputType | null
    _sum: RecipeInstructionSumAggregateOutputType | null
    _min: RecipeInstructionMinAggregateOutputType | null
    _max: RecipeInstructionMaxAggregateOutputType | null
  }

  type GetRecipeInstructionGroupByPayload<T extends RecipeInstructionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeInstructionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeInstructionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeInstructionGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeInstructionGroupByOutputType[P]>
        }
      >
    >


  export type RecipeInstructionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectScalar = {
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type RecipeInstructionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "stepNumber" | "instruction" | "imageUrl" | "createdAt", ExtArgs["result"]["recipeInstruction"]>
  export type RecipeInstructionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeInstructionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeInstructionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeInstructionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeInstruction"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      stepNumber: number
      instruction: string
      imageUrl: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["recipeInstruction"]>
    composites: {}
  }

  type RecipeInstructionGetPayload<S extends boolean | null | undefined | RecipeInstructionDefaultArgs> = $Result.GetResult<Prisma.$RecipeInstructionPayload, S>

  type RecipeInstructionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeInstructionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeInstructionCountAggregateInputType | true
    }

  export interface RecipeInstructionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeInstruction'], meta: { name: 'RecipeInstruction' } }
    /**
     * Find zero or one RecipeInstruction that matches the filter.
     * @param {RecipeInstructionFindUniqueArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeInstructionFindUniqueArgs>(args: SelectSubset<T, RecipeInstructionFindUniqueArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeInstruction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeInstructionFindUniqueOrThrowArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeInstructionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeInstructionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeInstruction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindFirstArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeInstructionFindFirstArgs>(args?: SelectSubset<T, RecipeInstructionFindFirstArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeInstruction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindFirstOrThrowArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeInstructionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeInstructionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeInstructions
     * const recipeInstructions = await prisma.recipeInstruction.findMany()
     * 
     * // Get first 10 RecipeInstructions
     * const recipeInstructions = await prisma.recipeInstruction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeInstructionFindManyArgs>(args?: SelectSubset<T, RecipeInstructionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeInstruction.
     * @param {RecipeInstructionCreateArgs} args - Arguments to create a RecipeInstruction.
     * @example
     * // Create one RecipeInstruction
     * const RecipeInstruction = await prisma.recipeInstruction.create({
     *   data: {
     *     // ... data to create a RecipeInstruction
     *   }
     * })
     * 
     */
    create<T extends RecipeInstructionCreateArgs>(args: SelectSubset<T, RecipeInstructionCreateArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeInstructions.
     * @param {RecipeInstructionCreateManyArgs} args - Arguments to create many RecipeInstructions.
     * @example
     * // Create many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeInstructionCreateManyArgs>(args?: SelectSubset<T, RecipeInstructionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeInstructions and returns the data saved in the database.
     * @param {RecipeInstructionCreateManyAndReturnArgs} args - Arguments to create many RecipeInstructions.
     * @example
     * // Create many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeInstructions and only return the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeInstructionCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeInstructionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeInstruction.
     * @param {RecipeInstructionDeleteArgs} args - Arguments to delete one RecipeInstruction.
     * @example
     * // Delete one RecipeInstruction
     * const RecipeInstruction = await prisma.recipeInstruction.delete({
     *   where: {
     *     // ... filter to delete one RecipeInstruction
     *   }
     * })
     * 
     */
    delete<T extends RecipeInstructionDeleteArgs>(args: SelectSubset<T, RecipeInstructionDeleteArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeInstruction.
     * @param {RecipeInstructionUpdateArgs} args - Arguments to update one RecipeInstruction.
     * @example
     * // Update one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeInstructionUpdateArgs>(args: SelectSubset<T, RecipeInstructionUpdateArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeInstructions.
     * @param {RecipeInstructionDeleteManyArgs} args - Arguments to filter RecipeInstructions to delete.
     * @example
     * // Delete a few RecipeInstructions
     * const { count } = await prisma.recipeInstruction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeInstructionDeleteManyArgs>(args?: SelectSubset<T, RecipeInstructionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeInstructionUpdateManyArgs>(args: SelectSubset<T, RecipeInstructionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeInstructions and returns the data updated in the database.
     * @param {RecipeInstructionUpdateManyAndReturnArgs} args - Arguments to update many RecipeInstructions.
     * @example
     * // Update many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeInstructions and only return the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeInstructionUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeInstructionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeInstruction.
     * @param {RecipeInstructionUpsertArgs} args - Arguments to update or create a RecipeInstruction.
     * @example
     * // Update or create a RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.upsert({
     *   create: {
     *     // ... data to create a RecipeInstruction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeInstruction we want to update
     *   }
     * })
     */
    upsert<T extends RecipeInstructionUpsertArgs>(args: SelectSubset<T, RecipeInstructionUpsertArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionCountArgs} args - Arguments to filter RecipeInstructions to count.
     * @example
     * // Count the number of RecipeInstructions
     * const count = await prisma.recipeInstruction.count({
     *   where: {
     *     // ... the filter for the RecipeInstructions we want to count
     *   }
     * })
    **/
    count<T extends RecipeInstructionCountArgs>(
      args?: Subset<T, RecipeInstructionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeInstructionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeInstructionAggregateArgs>(args: Subset<T, RecipeInstructionAggregateArgs>): Prisma.PrismaPromise<GetRecipeInstructionAggregateType<T>>

    /**
     * Group by RecipeInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeInstructionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeInstructionGroupByArgs['orderBy'] }
        : { orderBy?: RecipeInstructionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeInstructionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeInstructionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeInstruction model
   */
  readonly fields: RecipeInstructionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeInstruction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeInstructionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeInstruction model
   */
  interface RecipeInstructionFieldRefs {
    readonly id: FieldRef<"RecipeInstruction", 'String'>
    readonly recipeId: FieldRef<"RecipeInstruction", 'String'>
    readonly stepNumber: FieldRef<"RecipeInstruction", 'Int'>
    readonly instruction: FieldRef<"RecipeInstruction", 'String'>
    readonly imageUrl: FieldRef<"RecipeInstruction", 'String'>
    readonly createdAt: FieldRef<"RecipeInstruction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecipeInstruction findUnique
   */
  export type RecipeInstructionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction findUniqueOrThrow
   */
  export type RecipeInstructionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction findFirst
   */
  export type RecipeInstructionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInstructions.
     */
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction findFirstOrThrow
   */
  export type RecipeInstructionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInstructions.
     */
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction findMany
   */
  export type RecipeInstructionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstructions to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction create
   */
  export type RecipeInstructionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeInstruction.
     */
    data: XOR<RecipeInstructionCreateInput, RecipeInstructionUncheckedCreateInput>
  }

  /**
   * RecipeInstruction createMany
   */
  export type RecipeInstructionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeInstructions.
     */
    data: RecipeInstructionCreateManyInput | RecipeInstructionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeInstruction createManyAndReturn
   */
  export type RecipeInstructionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeInstructions.
     */
    data: RecipeInstructionCreateManyInput | RecipeInstructionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeInstruction update
   */
  export type RecipeInstructionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeInstruction.
     */
    data: XOR<RecipeInstructionUpdateInput, RecipeInstructionUncheckedUpdateInput>
    /**
     * Choose, which RecipeInstruction to update.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction updateMany
   */
  export type RecipeInstructionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeInstructions.
     */
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyInput>
    /**
     * Filter which RecipeInstructions to update
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to update.
     */
    limit?: number
  }

  /**
   * RecipeInstruction updateManyAndReturn
   */
  export type RecipeInstructionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * The data used to update RecipeInstructions.
     */
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyInput>
    /**
     * Filter which RecipeInstructions to update
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeInstruction upsert
   */
  export type RecipeInstructionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeInstruction to update in case it exists.
     */
    where: RecipeInstructionWhereUniqueInput
    /**
     * In case the RecipeInstruction found by the `where` argument doesn't exist, create a new RecipeInstruction with this data.
     */
    create: XOR<RecipeInstructionCreateInput, RecipeInstructionUncheckedCreateInput>
    /**
     * In case the RecipeInstruction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeInstructionUpdateInput, RecipeInstructionUncheckedUpdateInput>
  }

  /**
   * RecipeInstruction delete
   */
  export type RecipeInstructionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter which RecipeInstruction to delete.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction deleteMany
   */
  export type RecipeInstructionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInstructions to delete
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to delete.
     */
    limit?: number
  }

  /**
   * RecipeInstruction without action
   */
  export type RecipeInstructionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
  }


  /**
   * Model ContentVersion
   */

  export type AggregateContentVersion = {
    _count: ContentVersionCountAggregateOutputType | null
    _avg: ContentVersionAvgAggregateOutputType | null
    _sum: ContentVersionSumAggregateOutputType | null
    _min: ContentVersionMinAggregateOutputType | null
    _max: ContentVersionMaxAggregateOutputType | null
  }

  export type ContentVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type ContentVersionSumAggregateOutputType = {
    version: number | null
  }

  export type ContentVersionMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    version: number | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ContentVersionMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    version: number | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ContentVersionCountAggregateOutputType = {
    id: number
    contentId: number
    version: number
    data: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ContentVersionAvgAggregateInputType = {
    version?: true
  }

  export type ContentVersionSumAggregateInputType = {
    version?: true
  }

  export type ContentVersionMinAggregateInputType = {
    id?: true
    contentId?: true
    version?: true
    createdBy?: true
    createdAt?: true
  }

  export type ContentVersionMaxAggregateInputType = {
    id?: true
    contentId?: true
    version?: true
    createdBy?: true
    createdAt?: true
  }

  export type ContentVersionCountAggregateInputType = {
    id?: true
    contentId?: true
    version?: true
    data?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ContentVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentVersion to aggregate.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentVersions
    **/
    _count?: true | ContentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentVersionMaxAggregateInputType
  }

  export type GetContentVersionAggregateType<T extends ContentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateContentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentVersion[P]>
      : GetScalarType<T[P], AggregateContentVersion[P]>
  }




  export type ContentVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentVersionWhereInput
    orderBy?: ContentVersionOrderByWithAggregationInput | ContentVersionOrderByWithAggregationInput[]
    by: ContentVersionScalarFieldEnum[] | ContentVersionScalarFieldEnum
    having?: ContentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentVersionCountAggregateInputType | true
    _avg?: ContentVersionAvgAggregateInputType
    _sum?: ContentVersionSumAggregateInputType
    _min?: ContentVersionMinAggregateInputType
    _max?: ContentVersionMaxAggregateInputType
  }

  export type ContentVersionGroupByOutputType = {
    id: string
    contentId: string
    version: number
    data: JsonValue
    createdBy: string | null
    createdAt: Date | null
    _count: ContentVersionCountAggregateOutputType | null
    _avg: ContentVersionAvgAggregateOutputType | null
    _sum: ContentVersionSumAggregateOutputType | null
    _min: ContentVersionMinAggregateOutputType | null
    _max: ContentVersionMaxAggregateOutputType | null
  }

  type GetContentVersionGroupByPayload<T extends ContentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ContentVersionGroupByOutputType[P]>
        }
      >
    >


  export type ContentVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentVersion"]>

  export type ContentVersionSelectScalar = {
    id?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ContentVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "version" | "data" | "createdBy" | "createdAt", ExtArgs["result"]["contentVersion"]>
  export type ContentVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }

  export type $ContentVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentVersion"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      version: number
      data: Prisma.JsonValue
      createdBy: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["contentVersion"]>
    composites: {}
  }

  type ContentVersionGetPayload<S extends boolean | null | undefined | ContentVersionDefaultArgs> = $Result.GetResult<Prisma.$ContentVersionPayload, S>

  type ContentVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentVersionCountAggregateInputType | true
    }

  export interface ContentVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentVersion'], meta: { name: 'ContentVersion' } }
    /**
     * Find zero or one ContentVersion that matches the filter.
     * @param {ContentVersionFindUniqueArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentVersionFindUniqueArgs>(args: SelectSubset<T, ContentVersionFindUniqueArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentVersionFindUniqueOrThrowArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindFirstArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentVersionFindFirstArgs>(args?: SelectSubset<T, ContentVersionFindFirstArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindFirstOrThrowArgs} args - Arguments to find a ContentVersion
     * @example
     * // Get one ContentVersion
     * const contentVersion = await prisma.contentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentVersions
     * const contentVersions = await prisma.contentVersion.findMany()
     * 
     * // Get first 10 ContentVersions
     * const contentVersions = await prisma.contentVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentVersionFindManyArgs>(args?: SelectSubset<T, ContentVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentVersion.
     * @param {ContentVersionCreateArgs} args - Arguments to create a ContentVersion.
     * @example
     * // Create one ContentVersion
     * const ContentVersion = await prisma.contentVersion.create({
     *   data: {
     *     // ... data to create a ContentVersion
     *   }
     * })
     * 
     */
    create<T extends ContentVersionCreateArgs>(args: SelectSubset<T, ContentVersionCreateArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentVersions.
     * @param {ContentVersionCreateManyArgs} args - Arguments to create many ContentVersions.
     * @example
     * // Create many ContentVersions
     * const contentVersion = await prisma.contentVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentVersionCreateManyArgs>(args?: SelectSubset<T, ContentVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentVersions and returns the data saved in the database.
     * @param {ContentVersionCreateManyAndReturnArgs} args - Arguments to create many ContentVersions.
     * @example
     * // Create many ContentVersions
     * const contentVersion = await prisma.contentVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentVersions and only return the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentVersion.
     * @param {ContentVersionDeleteArgs} args - Arguments to delete one ContentVersion.
     * @example
     * // Delete one ContentVersion
     * const ContentVersion = await prisma.contentVersion.delete({
     *   where: {
     *     // ... filter to delete one ContentVersion
     *   }
     * })
     * 
     */
    delete<T extends ContentVersionDeleteArgs>(args: SelectSubset<T, ContentVersionDeleteArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentVersion.
     * @param {ContentVersionUpdateArgs} args - Arguments to update one ContentVersion.
     * @example
     * // Update one ContentVersion
     * const contentVersion = await prisma.contentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentVersionUpdateArgs>(args: SelectSubset<T, ContentVersionUpdateArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentVersions.
     * @param {ContentVersionDeleteManyArgs} args - Arguments to filter ContentVersions to delete.
     * @example
     * // Delete a few ContentVersions
     * const { count } = await prisma.contentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentVersionDeleteManyArgs>(args?: SelectSubset<T, ContentVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentVersions
     * const contentVersion = await prisma.contentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentVersionUpdateManyArgs>(args: SelectSubset<T, ContentVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentVersions and returns the data updated in the database.
     * @param {ContentVersionUpdateManyAndReturnArgs} args - Arguments to update many ContentVersions.
     * @example
     * // Update many ContentVersions
     * const contentVersion = await prisma.contentVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentVersions and only return the `id`
     * const contentVersionWithIdOnly = await prisma.contentVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentVersion.
     * @param {ContentVersionUpsertArgs} args - Arguments to update or create a ContentVersion.
     * @example
     * // Update or create a ContentVersion
     * const contentVersion = await prisma.contentVersion.upsert({
     *   create: {
     *     // ... data to create a ContentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentVersion we want to update
     *   }
     * })
     */
    upsert<T extends ContentVersionUpsertArgs>(args: SelectSubset<T, ContentVersionUpsertArgs<ExtArgs>>): Prisma__ContentVersionClient<$Result.GetResult<Prisma.$ContentVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionCountArgs} args - Arguments to filter ContentVersions to count.
     * @example
     * // Count the number of ContentVersions
     * const count = await prisma.contentVersion.count({
     *   where: {
     *     // ... the filter for the ContentVersions we want to count
     *   }
     * })
    **/
    count<T extends ContentVersionCountArgs>(
      args?: Subset<T, ContentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentVersionAggregateArgs>(args: Subset<T, ContentVersionAggregateArgs>): Prisma.PrismaPromise<GetContentVersionAggregateType<T>>

    /**
     * Group by ContentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentVersionGroupByArgs['orderBy'] }
        : { orderBy?: ContentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentVersion model
   */
  readonly fields: ContentVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentVersion model
   */
  interface ContentVersionFieldRefs {
    readonly id: FieldRef<"ContentVersion", 'String'>
    readonly contentId: FieldRef<"ContentVersion", 'String'>
    readonly version: FieldRef<"ContentVersion", 'Int'>
    readonly data: FieldRef<"ContentVersion", 'Json'>
    readonly createdBy: FieldRef<"ContentVersion", 'String'>
    readonly createdAt: FieldRef<"ContentVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentVersion findUnique
   */
  export type ContentVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion findUniqueOrThrow
   */
  export type ContentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion findFirst
   */
  export type ContentVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentVersions.
     */
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion findFirstOrThrow
   */
  export type ContentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersion to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentVersions.
     */
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion findMany
   */
  export type ContentVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ContentVersions to fetch.
     */
    where?: ContentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentVersions to fetch.
     */
    orderBy?: ContentVersionOrderByWithRelationInput | ContentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentVersions.
     */
    cursor?: ContentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentVersions.
     */
    skip?: number
    distinct?: ContentVersionScalarFieldEnum | ContentVersionScalarFieldEnum[]
  }

  /**
   * ContentVersion create
   */
  export type ContentVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentVersion.
     */
    data: XOR<ContentVersionCreateInput, ContentVersionUncheckedCreateInput>
  }

  /**
   * ContentVersion createMany
   */
  export type ContentVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentVersions.
     */
    data: ContentVersionCreateManyInput | ContentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentVersion createManyAndReturn
   */
  export type ContentVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ContentVersions.
     */
    data: ContentVersionCreateManyInput | ContentVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentVersion update
   */
  export type ContentVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentVersion.
     */
    data: XOR<ContentVersionUpdateInput, ContentVersionUncheckedUpdateInput>
    /**
     * Choose, which ContentVersion to update.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion updateMany
   */
  export type ContentVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentVersions.
     */
    data: XOR<ContentVersionUpdateManyMutationInput, ContentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ContentVersions to update
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to update.
     */
    limit?: number
  }

  /**
   * ContentVersion updateManyAndReturn
   */
  export type ContentVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * The data used to update ContentVersions.
     */
    data: XOR<ContentVersionUpdateManyMutationInput, ContentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ContentVersions to update
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentVersion upsert
   */
  export type ContentVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentVersion to update in case it exists.
     */
    where: ContentVersionWhereUniqueInput
    /**
     * In case the ContentVersion found by the `where` argument doesn't exist, create a new ContentVersion with this data.
     */
    create: XOR<ContentVersionCreateInput, ContentVersionUncheckedCreateInput>
    /**
     * In case the ContentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentVersionUpdateInput, ContentVersionUncheckedUpdateInput>
  }

  /**
   * ContentVersion delete
   */
  export type ContentVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
    /**
     * Filter which ContentVersion to delete.
     */
    where: ContentVersionWhereUniqueInput
  }

  /**
   * ContentVersion deleteMany
   */
  export type ContentVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentVersions to delete
     */
    where?: ContentVersionWhereInput
    /**
     * Limit how many ContentVersions to delete.
     */
    limit?: number
  }

  /**
   * ContentVersion without action
   */
  export type ContentVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentVersion
     */
    select?: ContentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentVersion
     */
    omit?: ContentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentVersionInclude<ExtArgs> | null
  }


  /**
   * Model RealTimeNotification
   */

  export type AggregateRealTimeNotification = {
    _count: RealTimeNotificationCountAggregateOutputType | null
    _min: RealTimeNotificationMinAggregateOutputType | null
    _max: RealTimeNotificationMaxAggregateOutputType | null
  }

  export type RealTimeNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type RealTimeNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type RealTimeNotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type RealTimeNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type RealTimeNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type RealTimeNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type RealTimeNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealTimeNotification to aggregate.
     */
    where?: RealTimeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeNotifications to fetch.
     */
    orderBy?: RealTimeNotificationOrderByWithRelationInput | RealTimeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealTimeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealTimeNotifications
    **/
    _count?: true | RealTimeNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealTimeNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealTimeNotificationMaxAggregateInputType
  }

  export type GetRealTimeNotificationAggregateType<T extends RealTimeNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateRealTimeNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealTimeNotification[P]>
      : GetScalarType<T[P], AggregateRealTimeNotification[P]>
  }




  export type RealTimeNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealTimeNotificationWhereInput
    orderBy?: RealTimeNotificationOrderByWithAggregationInput | RealTimeNotificationOrderByWithAggregationInput[]
    by: RealTimeNotificationScalarFieldEnum[] | RealTimeNotificationScalarFieldEnum
    having?: RealTimeNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealTimeNotificationCountAggregateInputType | true
    _min?: RealTimeNotificationMinAggregateInputType
    _max?: RealTimeNotificationMaxAggregateInputType
  }

  export type RealTimeNotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    isRead: boolean
    createdAt: Date | null
    _count: RealTimeNotificationCountAggregateOutputType | null
    _min: RealTimeNotificationMinAggregateOutputType | null
    _max: RealTimeNotificationMaxAggregateOutputType | null
  }

  type GetRealTimeNotificationGroupByPayload<T extends RealTimeNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealTimeNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealTimeNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealTimeNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], RealTimeNotificationGroupByOutputType[P]>
        }
      >
    >


  export type RealTimeNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["realTimeNotification"]>

  export type RealTimeNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["realTimeNotification"]>

  export type RealTimeNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["realTimeNotification"]>

  export type RealTimeNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type RealTimeNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "createdAt", ExtArgs["result"]["realTimeNotification"]>

  export type $RealTimeNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealTimeNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      isRead: boolean
      createdAt: Date | null
    }, ExtArgs["result"]["realTimeNotification"]>
    composites: {}
  }

  type RealTimeNotificationGetPayload<S extends boolean | null | undefined | RealTimeNotificationDefaultArgs> = $Result.GetResult<Prisma.$RealTimeNotificationPayload, S>

  type RealTimeNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RealTimeNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RealTimeNotificationCountAggregateInputType | true
    }

  export interface RealTimeNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealTimeNotification'], meta: { name: 'RealTimeNotification' } }
    /**
     * Find zero or one RealTimeNotification that matches the filter.
     * @param {RealTimeNotificationFindUniqueArgs} args - Arguments to find a RealTimeNotification
     * @example
     * // Get one RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RealTimeNotificationFindUniqueArgs>(args: SelectSubset<T, RealTimeNotificationFindUniqueArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RealTimeNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RealTimeNotificationFindUniqueOrThrowArgs} args - Arguments to find a RealTimeNotification
     * @example
     * // Get one RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RealTimeNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, RealTimeNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RealTimeNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationFindFirstArgs} args - Arguments to find a RealTimeNotification
     * @example
     * // Get one RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RealTimeNotificationFindFirstArgs>(args?: SelectSubset<T, RealTimeNotificationFindFirstArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RealTimeNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationFindFirstOrThrowArgs} args - Arguments to find a RealTimeNotification
     * @example
     * // Get one RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RealTimeNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, RealTimeNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RealTimeNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealTimeNotifications
     * const realTimeNotifications = await prisma.realTimeNotification.findMany()
     * 
     * // Get first 10 RealTimeNotifications
     * const realTimeNotifications = await prisma.realTimeNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realTimeNotificationWithIdOnly = await prisma.realTimeNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RealTimeNotificationFindManyArgs>(args?: SelectSubset<T, RealTimeNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RealTimeNotification.
     * @param {RealTimeNotificationCreateArgs} args - Arguments to create a RealTimeNotification.
     * @example
     * // Create one RealTimeNotification
     * const RealTimeNotification = await prisma.realTimeNotification.create({
     *   data: {
     *     // ... data to create a RealTimeNotification
     *   }
     * })
     * 
     */
    create<T extends RealTimeNotificationCreateArgs>(args: SelectSubset<T, RealTimeNotificationCreateArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RealTimeNotifications.
     * @param {RealTimeNotificationCreateManyArgs} args - Arguments to create many RealTimeNotifications.
     * @example
     * // Create many RealTimeNotifications
     * const realTimeNotification = await prisma.realTimeNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RealTimeNotificationCreateManyArgs>(args?: SelectSubset<T, RealTimeNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RealTimeNotifications and returns the data saved in the database.
     * @param {RealTimeNotificationCreateManyAndReturnArgs} args - Arguments to create many RealTimeNotifications.
     * @example
     * // Create many RealTimeNotifications
     * const realTimeNotification = await prisma.realTimeNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RealTimeNotifications and only return the `id`
     * const realTimeNotificationWithIdOnly = await prisma.realTimeNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RealTimeNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, RealTimeNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RealTimeNotification.
     * @param {RealTimeNotificationDeleteArgs} args - Arguments to delete one RealTimeNotification.
     * @example
     * // Delete one RealTimeNotification
     * const RealTimeNotification = await prisma.realTimeNotification.delete({
     *   where: {
     *     // ... filter to delete one RealTimeNotification
     *   }
     * })
     * 
     */
    delete<T extends RealTimeNotificationDeleteArgs>(args: SelectSubset<T, RealTimeNotificationDeleteArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RealTimeNotification.
     * @param {RealTimeNotificationUpdateArgs} args - Arguments to update one RealTimeNotification.
     * @example
     * // Update one RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RealTimeNotificationUpdateArgs>(args: SelectSubset<T, RealTimeNotificationUpdateArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RealTimeNotifications.
     * @param {RealTimeNotificationDeleteManyArgs} args - Arguments to filter RealTimeNotifications to delete.
     * @example
     * // Delete a few RealTimeNotifications
     * const { count } = await prisma.realTimeNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RealTimeNotificationDeleteManyArgs>(args?: SelectSubset<T, RealTimeNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealTimeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealTimeNotifications
     * const realTimeNotification = await prisma.realTimeNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RealTimeNotificationUpdateManyArgs>(args: SelectSubset<T, RealTimeNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealTimeNotifications and returns the data updated in the database.
     * @param {RealTimeNotificationUpdateManyAndReturnArgs} args - Arguments to update many RealTimeNotifications.
     * @example
     * // Update many RealTimeNotifications
     * const realTimeNotification = await prisma.realTimeNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RealTimeNotifications and only return the `id`
     * const realTimeNotificationWithIdOnly = await prisma.realTimeNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RealTimeNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, RealTimeNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RealTimeNotification.
     * @param {RealTimeNotificationUpsertArgs} args - Arguments to update or create a RealTimeNotification.
     * @example
     * // Update or create a RealTimeNotification
     * const realTimeNotification = await prisma.realTimeNotification.upsert({
     *   create: {
     *     // ... data to create a RealTimeNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealTimeNotification we want to update
     *   }
     * })
     */
    upsert<T extends RealTimeNotificationUpsertArgs>(args: SelectSubset<T, RealTimeNotificationUpsertArgs<ExtArgs>>): Prisma__RealTimeNotificationClient<$Result.GetResult<Prisma.$RealTimeNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RealTimeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationCountArgs} args - Arguments to filter RealTimeNotifications to count.
     * @example
     * // Count the number of RealTimeNotifications
     * const count = await prisma.realTimeNotification.count({
     *   where: {
     *     // ... the filter for the RealTimeNotifications we want to count
     *   }
     * })
    **/
    count<T extends RealTimeNotificationCountArgs>(
      args?: Subset<T, RealTimeNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealTimeNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealTimeNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealTimeNotificationAggregateArgs>(args: Subset<T, RealTimeNotificationAggregateArgs>): Prisma.PrismaPromise<GetRealTimeNotificationAggregateType<T>>

    /**
     * Group by RealTimeNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealTimeNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealTimeNotificationGroupByArgs['orderBy'] }
        : { orderBy?: RealTimeNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealTimeNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealTimeNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealTimeNotification model
   */
  readonly fields: RealTimeNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealTimeNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealTimeNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RealTimeNotification model
   */
  interface RealTimeNotificationFieldRefs {
    readonly id: FieldRef<"RealTimeNotification", 'String'>
    readonly userId: FieldRef<"RealTimeNotification", 'String'>
    readonly type: FieldRef<"RealTimeNotification", 'String'>
    readonly title: FieldRef<"RealTimeNotification", 'String'>
    readonly message: FieldRef<"RealTimeNotification", 'String'>
    readonly isRead: FieldRef<"RealTimeNotification", 'Boolean'>
    readonly createdAt: FieldRef<"RealTimeNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealTimeNotification findUnique
   */
  export type RealTimeNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter, which RealTimeNotification to fetch.
     */
    where: RealTimeNotificationWhereUniqueInput
  }

  /**
   * RealTimeNotification findUniqueOrThrow
   */
  export type RealTimeNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter, which RealTimeNotification to fetch.
     */
    where: RealTimeNotificationWhereUniqueInput
  }

  /**
   * RealTimeNotification findFirst
   */
  export type RealTimeNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter, which RealTimeNotification to fetch.
     */
    where?: RealTimeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeNotifications to fetch.
     */
    orderBy?: RealTimeNotificationOrderByWithRelationInput | RealTimeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealTimeNotifications.
     */
    cursor?: RealTimeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealTimeNotifications.
     */
    distinct?: RealTimeNotificationScalarFieldEnum | RealTimeNotificationScalarFieldEnum[]
  }

  /**
   * RealTimeNotification findFirstOrThrow
   */
  export type RealTimeNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter, which RealTimeNotification to fetch.
     */
    where?: RealTimeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeNotifications to fetch.
     */
    orderBy?: RealTimeNotificationOrderByWithRelationInput | RealTimeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealTimeNotifications.
     */
    cursor?: RealTimeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealTimeNotifications.
     */
    distinct?: RealTimeNotificationScalarFieldEnum | RealTimeNotificationScalarFieldEnum[]
  }

  /**
   * RealTimeNotification findMany
   */
  export type RealTimeNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter, which RealTimeNotifications to fetch.
     */
    where?: RealTimeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeNotifications to fetch.
     */
    orderBy?: RealTimeNotificationOrderByWithRelationInput | RealTimeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealTimeNotifications.
     */
    cursor?: RealTimeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeNotifications.
     */
    skip?: number
    distinct?: RealTimeNotificationScalarFieldEnum | RealTimeNotificationScalarFieldEnum[]
  }

  /**
   * RealTimeNotification create
   */
  export type RealTimeNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a RealTimeNotification.
     */
    data: XOR<RealTimeNotificationCreateInput, RealTimeNotificationUncheckedCreateInput>
  }

  /**
   * RealTimeNotification createMany
   */
  export type RealTimeNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealTimeNotifications.
     */
    data: RealTimeNotificationCreateManyInput | RealTimeNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealTimeNotification createManyAndReturn
   */
  export type RealTimeNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many RealTimeNotifications.
     */
    data: RealTimeNotificationCreateManyInput | RealTimeNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealTimeNotification update
   */
  export type RealTimeNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a RealTimeNotification.
     */
    data: XOR<RealTimeNotificationUpdateInput, RealTimeNotificationUncheckedUpdateInput>
    /**
     * Choose, which RealTimeNotification to update.
     */
    where: RealTimeNotificationWhereUniqueInput
  }

  /**
   * RealTimeNotification updateMany
   */
  export type RealTimeNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealTimeNotifications.
     */
    data: XOR<RealTimeNotificationUpdateManyMutationInput, RealTimeNotificationUncheckedUpdateManyInput>
    /**
     * Filter which RealTimeNotifications to update
     */
    where?: RealTimeNotificationWhereInput
    /**
     * Limit how many RealTimeNotifications to update.
     */
    limit?: number
  }

  /**
   * RealTimeNotification updateManyAndReturn
   */
  export type RealTimeNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * The data used to update RealTimeNotifications.
     */
    data: XOR<RealTimeNotificationUpdateManyMutationInput, RealTimeNotificationUncheckedUpdateManyInput>
    /**
     * Filter which RealTimeNotifications to update
     */
    where?: RealTimeNotificationWhereInput
    /**
     * Limit how many RealTimeNotifications to update.
     */
    limit?: number
  }

  /**
   * RealTimeNotification upsert
   */
  export type RealTimeNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the RealTimeNotification to update in case it exists.
     */
    where: RealTimeNotificationWhereUniqueInput
    /**
     * In case the RealTimeNotification found by the `where` argument doesn't exist, create a new RealTimeNotification with this data.
     */
    create: XOR<RealTimeNotificationCreateInput, RealTimeNotificationUncheckedCreateInput>
    /**
     * In case the RealTimeNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealTimeNotificationUpdateInput, RealTimeNotificationUncheckedUpdateInput>
  }

  /**
   * RealTimeNotification delete
   */
  export type RealTimeNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
    /**
     * Filter which RealTimeNotification to delete.
     */
    where: RealTimeNotificationWhereUniqueInput
  }

  /**
   * RealTimeNotification deleteMany
   */
  export type RealTimeNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealTimeNotifications to delete
     */
    where?: RealTimeNotificationWhereInput
    /**
     * Limit how many RealTimeNotifications to delete.
     */
    limit?: number
  }

  /**
   * RealTimeNotification without action
   */
  export type RealTimeNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeNotification
     */
    select?: RealTimeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RealTimeNotification
     */
    omit?: RealTimeNotificationOmit<ExtArgs> | null
  }


  /**
   * Model AIContentLog
   */

  export type AggregateAIContentLog = {
    _count: AIContentLogCountAggregateOutputType | null
    _avg: AIContentLogAvgAggregateOutputType | null
    _sum: AIContentLogSumAggregateOutputType | null
    _min: AIContentLogMinAggregateOutputType | null
    _max: AIContentLogMaxAggregateOutputType | null
  }

  export type AIContentLogAvgAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
    duration: number | null
  }

  export type AIContentLogSumAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
    duration: number | null
  }

  export type AIContentLogMinAggregateOutputType = {
    id: string | null
    prompt: string | null
    response: string | null
    model: string | null
    tokensUsed: number | null
    cost: Decimal | null
    duration: number | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type AIContentLogMaxAggregateOutputType = {
    id: string | null
    prompt: string | null
    response: string | null
    model: string | null
    tokensUsed: number | null
    cost: Decimal | null
    duration: number | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type AIContentLogCountAggregateOutputType = {
    id: number
    prompt: number
    response: number
    model: number
    tokensUsed: number
    cost: number
    duration: number
    status: number
    error: number
    createdAt: number
    _all: number
  }


  export type AIContentLogAvgAggregateInputType = {
    tokensUsed?: true
    cost?: true
    duration?: true
  }

  export type AIContentLogSumAggregateInputType = {
    tokensUsed?: true
    cost?: true
    duration?: true
  }

  export type AIContentLogMinAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    model?: true
    tokensUsed?: true
    cost?: true
    duration?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type AIContentLogMaxAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    model?: true
    tokensUsed?: true
    cost?: true
    duration?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type AIContentLogCountAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    model?: true
    tokensUsed?: true
    cost?: true
    duration?: true
    status?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type AIContentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIContentLog to aggregate.
     */
    where?: AIContentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIContentLogs to fetch.
     */
    orderBy?: AIContentLogOrderByWithRelationInput | AIContentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIContentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIContentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIContentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIContentLogs
    **/
    _count?: true | AIContentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIContentLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIContentLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIContentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIContentLogMaxAggregateInputType
  }

  export type GetAIContentLogAggregateType<T extends AIContentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIContentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIContentLog[P]>
      : GetScalarType<T[P], AggregateAIContentLog[P]>
  }




  export type AIContentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIContentLogWhereInput
    orderBy?: AIContentLogOrderByWithAggregationInput | AIContentLogOrderByWithAggregationInput[]
    by: AIContentLogScalarFieldEnum[] | AIContentLogScalarFieldEnum
    having?: AIContentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIContentLogCountAggregateInputType | true
    _avg?: AIContentLogAvgAggregateInputType
    _sum?: AIContentLogSumAggregateInputType
    _min?: AIContentLogMinAggregateInputType
    _max?: AIContentLogMaxAggregateInputType
  }

  export type AIContentLogGroupByOutputType = {
    id: string
    prompt: string
    response: string
    model: string
    tokensUsed: number
    cost: Decimal | null
    duration: number | null
    status: string
    error: string | null
    createdAt: Date | null
    _count: AIContentLogCountAggregateOutputType | null
    _avg: AIContentLogAvgAggregateOutputType | null
    _sum: AIContentLogSumAggregateOutputType | null
    _min: AIContentLogMinAggregateOutputType | null
    _max: AIContentLogMaxAggregateOutputType | null
  }

  type GetAIContentLogGroupByPayload<T extends AIContentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIContentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIContentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIContentLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIContentLogGroupByOutputType[P]>
        }
      >
    >


  export type AIContentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    duration?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIContentLog"]>

  export type AIContentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    duration?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIContentLog"]>

  export type AIContentLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    duration?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIContentLog"]>

  export type AIContentLogSelectScalar = {
    id?: boolean
    prompt?: boolean
    response?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    duration?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type AIContentLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prompt" | "response" | "model" | "tokensUsed" | "cost" | "duration" | "status" | "error" | "createdAt", ExtArgs["result"]["aIContentLog"]>

  export type $AIContentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIContentLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prompt: string
      response: string
      model: string
      tokensUsed: number
      cost: Prisma.Decimal | null
      duration: number | null
      status: string
      error: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["aIContentLog"]>
    composites: {}
  }

  type AIContentLogGetPayload<S extends boolean | null | undefined | AIContentLogDefaultArgs> = $Result.GetResult<Prisma.$AIContentLogPayload, S>

  type AIContentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIContentLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIContentLogCountAggregateInputType | true
    }

  export interface AIContentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIContentLog'], meta: { name: 'AIContentLog' } }
    /**
     * Find zero or one AIContentLog that matches the filter.
     * @param {AIContentLogFindUniqueArgs} args - Arguments to find a AIContentLog
     * @example
     * // Get one AIContentLog
     * const aIContentLog = await prisma.aIContentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIContentLogFindUniqueArgs>(args: SelectSubset<T, AIContentLogFindUniqueArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIContentLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIContentLogFindUniqueOrThrowArgs} args - Arguments to find a AIContentLog
     * @example
     * // Get one AIContentLog
     * const aIContentLog = await prisma.aIContentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIContentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIContentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIContentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogFindFirstArgs} args - Arguments to find a AIContentLog
     * @example
     * // Get one AIContentLog
     * const aIContentLog = await prisma.aIContentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIContentLogFindFirstArgs>(args?: SelectSubset<T, AIContentLogFindFirstArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIContentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogFindFirstOrThrowArgs} args - Arguments to find a AIContentLog
     * @example
     * // Get one AIContentLog
     * const aIContentLog = await prisma.aIContentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIContentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIContentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIContentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIContentLogs
     * const aIContentLogs = await prisma.aIContentLog.findMany()
     * 
     * // Get first 10 AIContentLogs
     * const aIContentLogs = await prisma.aIContentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIContentLogWithIdOnly = await prisma.aIContentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIContentLogFindManyArgs>(args?: SelectSubset<T, AIContentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIContentLog.
     * @param {AIContentLogCreateArgs} args - Arguments to create a AIContentLog.
     * @example
     * // Create one AIContentLog
     * const AIContentLog = await prisma.aIContentLog.create({
     *   data: {
     *     // ... data to create a AIContentLog
     *   }
     * })
     * 
     */
    create<T extends AIContentLogCreateArgs>(args: SelectSubset<T, AIContentLogCreateArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIContentLogs.
     * @param {AIContentLogCreateManyArgs} args - Arguments to create many AIContentLogs.
     * @example
     * // Create many AIContentLogs
     * const aIContentLog = await prisma.aIContentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIContentLogCreateManyArgs>(args?: SelectSubset<T, AIContentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIContentLogs and returns the data saved in the database.
     * @param {AIContentLogCreateManyAndReturnArgs} args - Arguments to create many AIContentLogs.
     * @example
     * // Create many AIContentLogs
     * const aIContentLog = await prisma.aIContentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIContentLogs and only return the `id`
     * const aIContentLogWithIdOnly = await prisma.aIContentLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIContentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIContentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIContentLog.
     * @param {AIContentLogDeleteArgs} args - Arguments to delete one AIContentLog.
     * @example
     * // Delete one AIContentLog
     * const AIContentLog = await prisma.aIContentLog.delete({
     *   where: {
     *     // ... filter to delete one AIContentLog
     *   }
     * })
     * 
     */
    delete<T extends AIContentLogDeleteArgs>(args: SelectSubset<T, AIContentLogDeleteArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIContentLog.
     * @param {AIContentLogUpdateArgs} args - Arguments to update one AIContentLog.
     * @example
     * // Update one AIContentLog
     * const aIContentLog = await prisma.aIContentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIContentLogUpdateArgs>(args: SelectSubset<T, AIContentLogUpdateArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIContentLogs.
     * @param {AIContentLogDeleteManyArgs} args - Arguments to filter AIContentLogs to delete.
     * @example
     * // Delete a few AIContentLogs
     * const { count } = await prisma.aIContentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIContentLogDeleteManyArgs>(args?: SelectSubset<T, AIContentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIContentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIContentLogs
     * const aIContentLog = await prisma.aIContentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIContentLogUpdateManyArgs>(args: SelectSubset<T, AIContentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIContentLogs and returns the data updated in the database.
     * @param {AIContentLogUpdateManyAndReturnArgs} args - Arguments to update many AIContentLogs.
     * @example
     * // Update many AIContentLogs
     * const aIContentLog = await prisma.aIContentLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIContentLogs and only return the `id`
     * const aIContentLogWithIdOnly = await prisma.aIContentLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIContentLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AIContentLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIContentLog.
     * @param {AIContentLogUpsertArgs} args - Arguments to update or create a AIContentLog.
     * @example
     * // Update or create a AIContentLog
     * const aIContentLog = await prisma.aIContentLog.upsert({
     *   create: {
     *     // ... data to create a AIContentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIContentLog we want to update
     *   }
     * })
     */
    upsert<T extends AIContentLogUpsertArgs>(args: SelectSubset<T, AIContentLogUpsertArgs<ExtArgs>>): Prisma__AIContentLogClient<$Result.GetResult<Prisma.$AIContentLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIContentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogCountArgs} args - Arguments to filter AIContentLogs to count.
     * @example
     * // Count the number of AIContentLogs
     * const count = await prisma.aIContentLog.count({
     *   where: {
     *     // ... the filter for the AIContentLogs we want to count
     *   }
     * })
    **/
    count<T extends AIContentLogCountArgs>(
      args?: Subset<T, AIContentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIContentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIContentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIContentLogAggregateArgs>(args: Subset<T, AIContentLogAggregateArgs>): Prisma.PrismaPromise<GetAIContentLogAggregateType<T>>

    /**
     * Group by AIContentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIContentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIContentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIContentLogGroupByArgs['orderBy'] }
        : { orderBy?: AIContentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIContentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIContentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIContentLog model
   */
  readonly fields: AIContentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIContentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIContentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIContentLog model
   */
  interface AIContentLogFieldRefs {
    readonly id: FieldRef<"AIContentLog", 'String'>
    readonly prompt: FieldRef<"AIContentLog", 'String'>
    readonly response: FieldRef<"AIContentLog", 'String'>
    readonly model: FieldRef<"AIContentLog", 'String'>
    readonly tokensUsed: FieldRef<"AIContentLog", 'Int'>
    readonly cost: FieldRef<"AIContentLog", 'Decimal'>
    readonly duration: FieldRef<"AIContentLog", 'Int'>
    readonly status: FieldRef<"AIContentLog", 'String'>
    readonly error: FieldRef<"AIContentLog", 'String'>
    readonly createdAt: FieldRef<"AIContentLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIContentLog findUnique
   */
  export type AIContentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter, which AIContentLog to fetch.
     */
    where: AIContentLogWhereUniqueInput
  }

  /**
   * AIContentLog findUniqueOrThrow
   */
  export type AIContentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter, which AIContentLog to fetch.
     */
    where: AIContentLogWhereUniqueInput
  }

  /**
   * AIContentLog findFirst
   */
  export type AIContentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter, which AIContentLog to fetch.
     */
    where?: AIContentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIContentLogs to fetch.
     */
    orderBy?: AIContentLogOrderByWithRelationInput | AIContentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIContentLogs.
     */
    cursor?: AIContentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIContentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIContentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIContentLogs.
     */
    distinct?: AIContentLogScalarFieldEnum | AIContentLogScalarFieldEnum[]
  }

  /**
   * AIContentLog findFirstOrThrow
   */
  export type AIContentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter, which AIContentLog to fetch.
     */
    where?: AIContentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIContentLogs to fetch.
     */
    orderBy?: AIContentLogOrderByWithRelationInput | AIContentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIContentLogs.
     */
    cursor?: AIContentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIContentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIContentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIContentLogs.
     */
    distinct?: AIContentLogScalarFieldEnum | AIContentLogScalarFieldEnum[]
  }

  /**
   * AIContentLog findMany
   */
  export type AIContentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter, which AIContentLogs to fetch.
     */
    where?: AIContentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIContentLogs to fetch.
     */
    orderBy?: AIContentLogOrderByWithRelationInput | AIContentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIContentLogs.
     */
    cursor?: AIContentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIContentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIContentLogs.
     */
    skip?: number
    distinct?: AIContentLogScalarFieldEnum | AIContentLogScalarFieldEnum[]
  }

  /**
   * AIContentLog create
   */
  export type AIContentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AIContentLog.
     */
    data: XOR<AIContentLogCreateInput, AIContentLogUncheckedCreateInput>
  }

  /**
   * AIContentLog createMany
   */
  export type AIContentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIContentLogs.
     */
    data: AIContentLogCreateManyInput | AIContentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIContentLog createManyAndReturn
   */
  export type AIContentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIContentLogs.
     */
    data: AIContentLogCreateManyInput | AIContentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIContentLog update
   */
  export type AIContentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AIContentLog.
     */
    data: XOR<AIContentLogUpdateInput, AIContentLogUncheckedUpdateInput>
    /**
     * Choose, which AIContentLog to update.
     */
    where: AIContentLogWhereUniqueInput
  }

  /**
   * AIContentLog updateMany
   */
  export type AIContentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIContentLogs.
     */
    data: XOR<AIContentLogUpdateManyMutationInput, AIContentLogUncheckedUpdateManyInput>
    /**
     * Filter which AIContentLogs to update
     */
    where?: AIContentLogWhereInput
    /**
     * Limit how many AIContentLogs to update.
     */
    limit?: number
  }

  /**
   * AIContentLog updateManyAndReturn
   */
  export type AIContentLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * The data used to update AIContentLogs.
     */
    data: XOR<AIContentLogUpdateManyMutationInput, AIContentLogUncheckedUpdateManyInput>
    /**
     * Filter which AIContentLogs to update
     */
    where?: AIContentLogWhereInput
    /**
     * Limit how many AIContentLogs to update.
     */
    limit?: number
  }

  /**
   * AIContentLog upsert
   */
  export type AIContentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AIContentLog to update in case it exists.
     */
    where: AIContentLogWhereUniqueInput
    /**
     * In case the AIContentLog found by the `where` argument doesn't exist, create a new AIContentLog with this data.
     */
    create: XOR<AIContentLogCreateInput, AIContentLogUncheckedCreateInput>
    /**
     * In case the AIContentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIContentLogUpdateInput, AIContentLogUncheckedUpdateInput>
  }

  /**
   * AIContentLog delete
   */
  export type AIContentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
    /**
     * Filter which AIContentLog to delete.
     */
    where: AIContentLogWhereUniqueInput
  }

  /**
   * AIContentLog deleteMany
   */
  export type AIContentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIContentLogs to delete
     */
    where?: AIContentLogWhereInput
    /**
     * Limit how many AIContentLogs to delete.
     */
    limit?: number
  }

  /**
   * AIContentLog without action
   */
  export type AIContentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIContentLog
     */
    select?: AIContentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIContentLog
     */
    omit?: AIContentLogOmit<ExtArgs> | null
  }


  /**
   * Model BulkImport
   */

  export type AggregateBulkImport = {
    _count: BulkImportCountAggregateOutputType | null
    _avg: BulkImportAvgAggregateOutputType | null
    _sum: BulkImportSumAggregateOutputType | null
    _min: BulkImportMinAggregateOutputType | null
    _max: BulkImportMaxAggregateOutputType | null
  }

  export type BulkImportAvgAggregateOutputType = {
    totalRows: number | null
    processedRows: number | null
    errorRows: number | null
  }

  export type BulkImportSumAggregateOutputType = {
    totalRows: number | null
    processedRows: number | null
    errorRows: number | null
  }

  export type BulkImportMinAggregateOutputType = {
    id: string | null
    filename: string | null
    status: string | null
    totalRows: number | null
    processedRows: number | null
    errorRows: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BulkImportMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    status: string | null
    totalRows: number | null
    processedRows: number | null
    errorRows: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BulkImportCountAggregateOutputType = {
    id: number
    filename: number
    status: number
    totalRows: number
    processedRows: number
    errorRows: number
    errors: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type BulkImportAvgAggregateInputType = {
    totalRows?: true
    processedRows?: true
    errorRows?: true
  }

  export type BulkImportSumAggregateInputType = {
    totalRows?: true
    processedRows?: true
    errorRows?: true
  }

  export type BulkImportMinAggregateInputType = {
    id?: true
    filename?: true
    status?: true
    totalRows?: true
    processedRows?: true
    errorRows?: true
    createdAt?: true
    completedAt?: true
  }

  export type BulkImportMaxAggregateInputType = {
    id?: true
    filename?: true
    status?: true
    totalRows?: true
    processedRows?: true
    errorRows?: true
    createdAt?: true
    completedAt?: true
  }

  export type BulkImportCountAggregateInputType = {
    id?: true
    filename?: true
    status?: true
    totalRows?: true
    processedRows?: true
    errorRows?: true
    errors?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type BulkImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkImport to aggregate.
     */
    where?: BulkImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImports to fetch.
     */
    orderBy?: BulkImportOrderByWithRelationInput | BulkImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulkImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulkImports
    **/
    _count?: true | BulkImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulkImportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulkImportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulkImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulkImportMaxAggregateInputType
  }

  export type GetBulkImportAggregateType<T extends BulkImportAggregateArgs> = {
        [P in keyof T & keyof AggregateBulkImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulkImport[P]>
      : GetScalarType<T[P], AggregateBulkImport[P]>
  }




  export type BulkImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkImportWhereInput
    orderBy?: BulkImportOrderByWithAggregationInput | BulkImportOrderByWithAggregationInput[]
    by: BulkImportScalarFieldEnum[] | BulkImportScalarFieldEnum
    having?: BulkImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulkImportCountAggregateInputType | true
    _avg?: BulkImportAvgAggregateInputType
    _sum?: BulkImportSumAggregateInputType
    _min?: BulkImportMinAggregateInputType
    _max?: BulkImportMaxAggregateInputType
  }

  export type BulkImportGroupByOutputType = {
    id: string
    filename: string
    status: string
    totalRows: number
    processedRows: number
    errorRows: number
    errors: JsonValue | null
    createdAt: Date | null
    completedAt: Date | null
    _count: BulkImportCountAggregateOutputType | null
    _avg: BulkImportAvgAggregateOutputType | null
    _sum: BulkImportSumAggregateOutputType | null
    _min: BulkImportMinAggregateOutputType | null
    _max: BulkImportMaxAggregateOutputType | null
  }

  type GetBulkImportGroupByPayload<T extends BulkImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulkImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulkImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulkImportGroupByOutputType[P]>
            : GetScalarType<T[P], BulkImportGroupByOutputType[P]>
        }
      >
    >


  export type BulkImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    status?: boolean
    totalRows?: boolean
    processedRows?: boolean
    errorRows?: boolean
    errors?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["bulkImport"]>

  export type BulkImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    status?: boolean
    totalRows?: boolean
    processedRows?: boolean
    errorRows?: boolean
    errors?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["bulkImport"]>

  export type BulkImportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    status?: boolean
    totalRows?: boolean
    processedRows?: boolean
    errorRows?: boolean
    errors?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["bulkImport"]>

  export type BulkImportSelectScalar = {
    id?: boolean
    filename?: boolean
    status?: boolean
    totalRows?: boolean
    processedRows?: boolean
    errorRows?: boolean
    errors?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type BulkImportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "status" | "totalRows" | "processedRows" | "errorRows" | "errors" | "createdAt" | "completedAt", ExtArgs["result"]["bulkImport"]>

  export type $BulkImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulkImport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      status: string
      totalRows: number
      processedRows: number
      errorRows: number
      errors: Prisma.JsonValue | null
      createdAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["bulkImport"]>
    composites: {}
  }

  type BulkImportGetPayload<S extends boolean | null | undefined | BulkImportDefaultArgs> = $Result.GetResult<Prisma.$BulkImportPayload, S>

  type BulkImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BulkImportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BulkImportCountAggregateInputType | true
    }

  export interface BulkImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulkImport'], meta: { name: 'BulkImport' } }
    /**
     * Find zero or one BulkImport that matches the filter.
     * @param {BulkImportFindUniqueArgs} args - Arguments to find a BulkImport
     * @example
     * // Get one BulkImport
     * const bulkImport = await prisma.bulkImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulkImportFindUniqueArgs>(args: SelectSubset<T, BulkImportFindUniqueArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BulkImport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BulkImportFindUniqueOrThrowArgs} args - Arguments to find a BulkImport
     * @example
     * // Get one BulkImport
     * const bulkImport = await prisma.bulkImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulkImportFindUniqueOrThrowArgs>(args: SelectSubset<T, BulkImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportFindFirstArgs} args - Arguments to find a BulkImport
     * @example
     * // Get one BulkImport
     * const bulkImport = await prisma.bulkImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulkImportFindFirstArgs>(args?: SelectSubset<T, BulkImportFindFirstArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportFindFirstOrThrowArgs} args - Arguments to find a BulkImport
     * @example
     * // Get one BulkImport
     * const bulkImport = await prisma.bulkImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulkImportFindFirstOrThrowArgs>(args?: SelectSubset<T, BulkImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BulkImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulkImports
     * const bulkImports = await prisma.bulkImport.findMany()
     * 
     * // Get first 10 BulkImports
     * const bulkImports = await prisma.bulkImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulkImportWithIdOnly = await prisma.bulkImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulkImportFindManyArgs>(args?: SelectSubset<T, BulkImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BulkImport.
     * @param {BulkImportCreateArgs} args - Arguments to create a BulkImport.
     * @example
     * // Create one BulkImport
     * const BulkImport = await prisma.bulkImport.create({
     *   data: {
     *     // ... data to create a BulkImport
     *   }
     * })
     * 
     */
    create<T extends BulkImportCreateArgs>(args: SelectSubset<T, BulkImportCreateArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BulkImports.
     * @param {BulkImportCreateManyArgs} args - Arguments to create many BulkImports.
     * @example
     * // Create many BulkImports
     * const bulkImport = await prisma.bulkImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulkImportCreateManyArgs>(args?: SelectSubset<T, BulkImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulkImports and returns the data saved in the database.
     * @param {BulkImportCreateManyAndReturnArgs} args - Arguments to create many BulkImports.
     * @example
     * // Create many BulkImports
     * const bulkImport = await prisma.bulkImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulkImports and only return the `id`
     * const bulkImportWithIdOnly = await prisma.bulkImport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulkImportCreateManyAndReturnArgs>(args?: SelectSubset<T, BulkImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BulkImport.
     * @param {BulkImportDeleteArgs} args - Arguments to delete one BulkImport.
     * @example
     * // Delete one BulkImport
     * const BulkImport = await prisma.bulkImport.delete({
     *   where: {
     *     // ... filter to delete one BulkImport
     *   }
     * })
     * 
     */
    delete<T extends BulkImportDeleteArgs>(args: SelectSubset<T, BulkImportDeleteArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BulkImport.
     * @param {BulkImportUpdateArgs} args - Arguments to update one BulkImport.
     * @example
     * // Update one BulkImport
     * const bulkImport = await prisma.bulkImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulkImportUpdateArgs>(args: SelectSubset<T, BulkImportUpdateArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BulkImports.
     * @param {BulkImportDeleteManyArgs} args - Arguments to filter BulkImports to delete.
     * @example
     * // Delete a few BulkImports
     * const { count } = await prisma.bulkImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulkImportDeleteManyArgs>(args?: SelectSubset<T, BulkImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulkImports
     * const bulkImport = await prisma.bulkImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulkImportUpdateManyArgs>(args: SelectSubset<T, BulkImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkImports and returns the data updated in the database.
     * @param {BulkImportUpdateManyAndReturnArgs} args - Arguments to update many BulkImports.
     * @example
     * // Update many BulkImports
     * const bulkImport = await prisma.bulkImport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BulkImports and only return the `id`
     * const bulkImportWithIdOnly = await prisma.bulkImport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BulkImportUpdateManyAndReturnArgs>(args: SelectSubset<T, BulkImportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BulkImport.
     * @param {BulkImportUpsertArgs} args - Arguments to update or create a BulkImport.
     * @example
     * // Update or create a BulkImport
     * const bulkImport = await prisma.bulkImport.upsert({
     *   create: {
     *     // ... data to create a BulkImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulkImport we want to update
     *   }
     * })
     */
    upsert<T extends BulkImportUpsertArgs>(args: SelectSubset<T, BulkImportUpsertArgs<ExtArgs>>): Prisma__BulkImportClient<$Result.GetResult<Prisma.$BulkImportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BulkImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportCountArgs} args - Arguments to filter BulkImports to count.
     * @example
     * // Count the number of BulkImports
     * const count = await prisma.bulkImport.count({
     *   where: {
     *     // ... the filter for the BulkImports we want to count
     *   }
     * })
    **/
    count<T extends BulkImportCountArgs>(
      args?: Subset<T, BulkImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulkImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulkImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulkImportAggregateArgs>(args: Subset<T, BulkImportAggregateArgs>): Prisma.PrismaPromise<GetBulkImportAggregateType<T>>

    /**
     * Group by BulkImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulkImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulkImportGroupByArgs['orderBy'] }
        : { orderBy?: BulkImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulkImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulkImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulkImport model
   */
  readonly fields: BulkImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulkImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulkImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulkImport model
   */
  interface BulkImportFieldRefs {
    readonly id: FieldRef<"BulkImport", 'String'>
    readonly filename: FieldRef<"BulkImport", 'String'>
    readonly status: FieldRef<"BulkImport", 'String'>
    readonly totalRows: FieldRef<"BulkImport", 'Int'>
    readonly processedRows: FieldRef<"BulkImport", 'Int'>
    readonly errorRows: FieldRef<"BulkImport", 'Int'>
    readonly errors: FieldRef<"BulkImport", 'Json'>
    readonly createdAt: FieldRef<"BulkImport", 'DateTime'>
    readonly completedAt: FieldRef<"BulkImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BulkImport findUnique
   */
  export type BulkImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter, which BulkImport to fetch.
     */
    where: BulkImportWhereUniqueInput
  }

  /**
   * BulkImport findUniqueOrThrow
   */
  export type BulkImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter, which BulkImport to fetch.
     */
    where: BulkImportWhereUniqueInput
  }

  /**
   * BulkImport findFirst
   */
  export type BulkImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter, which BulkImport to fetch.
     */
    where?: BulkImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImports to fetch.
     */
    orderBy?: BulkImportOrderByWithRelationInput | BulkImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkImports.
     */
    cursor?: BulkImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkImports.
     */
    distinct?: BulkImportScalarFieldEnum | BulkImportScalarFieldEnum[]
  }

  /**
   * BulkImport findFirstOrThrow
   */
  export type BulkImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter, which BulkImport to fetch.
     */
    where?: BulkImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImports to fetch.
     */
    orderBy?: BulkImportOrderByWithRelationInput | BulkImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkImports.
     */
    cursor?: BulkImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkImports.
     */
    distinct?: BulkImportScalarFieldEnum | BulkImportScalarFieldEnum[]
  }

  /**
   * BulkImport findMany
   */
  export type BulkImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter, which BulkImports to fetch.
     */
    where?: BulkImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImports to fetch.
     */
    orderBy?: BulkImportOrderByWithRelationInput | BulkImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulkImports.
     */
    cursor?: BulkImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImports.
     */
    skip?: number
    distinct?: BulkImportScalarFieldEnum | BulkImportScalarFieldEnum[]
  }

  /**
   * BulkImport create
   */
  export type BulkImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * The data needed to create a BulkImport.
     */
    data: XOR<BulkImportCreateInput, BulkImportUncheckedCreateInput>
  }

  /**
   * BulkImport createMany
   */
  export type BulkImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulkImports.
     */
    data: BulkImportCreateManyInput | BulkImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkImport createManyAndReturn
   */
  export type BulkImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * The data used to create many BulkImports.
     */
    data: BulkImportCreateManyInput | BulkImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkImport update
   */
  export type BulkImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * The data needed to update a BulkImport.
     */
    data: XOR<BulkImportUpdateInput, BulkImportUncheckedUpdateInput>
    /**
     * Choose, which BulkImport to update.
     */
    where: BulkImportWhereUniqueInput
  }

  /**
   * BulkImport updateMany
   */
  export type BulkImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulkImports.
     */
    data: XOR<BulkImportUpdateManyMutationInput, BulkImportUncheckedUpdateManyInput>
    /**
     * Filter which BulkImports to update
     */
    where?: BulkImportWhereInput
    /**
     * Limit how many BulkImports to update.
     */
    limit?: number
  }

  /**
   * BulkImport updateManyAndReturn
   */
  export type BulkImportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * The data used to update BulkImports.
     */
    data: XOR<BulkImportUpdateManyMutationInput, BulkImportUncheckedUpdateManyInput>
    /**
     * Filter which BulkImports to update
     */
    where?: BulkImportWhereInput
    /**
     * Limit how many BulkImports to update.
     */
    limit?: number
  }

  /**
   * BulkImport upsert
   */
  export type BulkImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * The filter to search for the BulkImport to update in case it exists.
     */
    where: BulkImportWhereUniqueInput
    /**
     * In case the BulkImport found by the `where` argument doesn't exist, create a new BulkImport with this data.
     */
    create: XOR<BulkImportCreateInput, BulkImportUncheckedCreateInput>
    /**
     * In case the BulkImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulkImportUpdateInput, BulkImportUncheckedUpdateInput>
  }

  /**
   * BulkImport delete
   */
  export type BulkImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
    /**
     * Filter which BulkImport to delete.
     */
    where: BulkImportWhereUniqueInput
  }

  /**
   * BulkImport deleteMany
   */
  export type BulkImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkImports to delete
     */
    where?: BulkImportWhereInput
    /**
     * Limit how many BulkImports to delete.
     */
    limit?: number
  }

  /**
   * BulkImport without action
   */
  export type BulkImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImport
     */
    select?: BulkImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkImport
     */
    omit?: BulkImportOmit<ExtArgs> | null
  }


  /**
   * Model MakeWebhook
   */

  export type AggregateMakeWebhook = {
    _count: MakeWebhookCountAggregateOutputType | null
    _min: MakeWebhookMinAggregateOutputType | null
    _max: MakeWebhookMaxAggregateOutputType | null
  }

  export type MakeWebhookMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MakeWebhookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MakeWebhookCountAggregateOutputType = {
    id: number
    name: number
    url: number
    secret: number
    isActive: number
    events: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MakeWebhookMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MakeWebhookMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MakeWebhookCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    events?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MakeWebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MakeWebhook to aggregate.
     */
    where?: MakeWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MakeWebhooks to fetch.
     */
    orderBy?: MakeWebhookOrderByWithRelationInput | MakeWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MakeWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MakeWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MakeWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MakeWebhooks
    **/
    _count?: true | MakeWebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MakeWebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MakeWebhookMaxAggregateInputType
  }

  export type GetMakeWebhookAggregateType<T extends MakeWebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateMakeWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMakeWebhook[P]>
      : GetScalarType<T[P], AggregateMakeWebhook[P]>
  }




  export type MakeWebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MakeWebhookWhereInput
    orderBy?: MakeWebhookOrderByWithAggregationInput | MakeWebhookOrderByWithAggregationInput[]
    by: MakeWebhookScalarFieldEnum[] | MakeWebhookScalarFieldEnum
    having?: MakeWebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MakeWebhookCountAggregateInputType | true
    _min?: MakeWebhookMinAggregateInputType
    _max?: MakeWebhookMaxAggregateInputType
  }

  export type MakeWebhookGroupByOutputType = {
    id: string
    name: string
    url: string
    secret: string
    isActive: boolean
    events: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MakeWebhookCountAggregateOutputType | null
    _min: MakeWebhookMinAggregateOutputType | null
    _max: MakeWebhookMaxAggregateOutputType | null
  }

  type GetMakeWebhookGroupByPayload<T extends MakeWebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MakeWebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MakeWebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MakeWebhookGroupByOutputType[P]>
            : GetScalarType<T[P], MakeWebhookGroupByOutputType[P]>
        }
      >
    >


  export type MakeWebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["makeWebhook"]>

  export type MakeWebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["makeWebhook"]>

  export type MakeWebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["makeWebhook"]>

  export type MakeWebhookSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MakeWebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "secret" | "isActive" | "events" | "createdAt" | "updatedAt", ExtArgs["result"]["makeWebhook"]>

  export type $MakeWebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MakeWebhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      secret: string
      isActive: boolean
      events: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["makeWebhook"]>
    composites: {}
  }

  type MakeWebhookGetPayload<S extends boolean | null | undefined | MakeWebhookDefaultArgs> = $Result.GetResult<Prisma.$MakeWebhookPayload, S>

  type MakeWebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MakeWebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MakeWebhookCountAggregateInputType | true
    }

  export interface MakeWebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MakeWebhook'], meta: { name: 'MakeWebhook' } }
    /**
     * Find zero or one MakeWebhook that matches the filter.
     * @param {MakeWebhookFindUniqueArgs} args - Arguments to find a MakeWebhook
     * @example
     * // Get one MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MakeWebhookFindUniqueArgs>(args: SelectSubset<T, MakeWebhookFindUniqueArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MakeWebhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MakeWebhookFindUniqueOrThrowArgs} args - Arguments to find a MakeWebhook
     * @example
     * // Get one MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MakeWebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, MakeWebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MakeWebhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookFindFirstArgs} args - Arguments to find a MakeWebhook
     * @example
     * // Get one MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MakeWebhookFindFirstArgs>(args?: SelectSubset<T, MakeWebhookFindFirstArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MakeWebhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookFindFirstOrThrowArgs} args - Arguments to find a MakeWebhook
     * @example
     * // Get one MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MakeWebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, MakeWebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MakeWebhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MakeWebhooks
     * const makeWebhooks = await prisma.makeWebhook.findMany()
     * 
     * // Get first 10 MakeWebhooks
     * const makeWebhooks = await prisma.makeWebhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const makeWebhookWithIdOnly = await prisma.makeWebhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MakeWebhookFindManyArgs>(args?: SelectSubset<T, MakeWebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MakeWebhook.
     * @param {MakeWebhookCreateArgs} args - Arguments to create a MakeWebhook.
     * @example
     * // Create one MakeWebhook
     * const MakeWebhook = await prisma.makeWebhook.create({
     *   data: {
     *     // ... data to create a MakeWebhook
     *   }
     * })
     * 
     */
    create<T extends MakeWebhookCreateArgs>(args: SelectSubset<T, MakeWebhookCreateArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MakeWebhooks.
     * @param {MakeWebhookCreateManyArgs} args - Arguments to create many MakeWebhooks.
     * @example
     * // Create many MakeWebhooks
     * const makeWebhook = await prisma.makeWebhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MakeWebhookCreateManyArgs>(args?: SelectSubset<T, MakeWebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MakeWebhooks and returns the data saved in the database.
     * @param {MakeWebhookCreateManyAndReturnArgs} args - Arguments to create many MakeWebhooks.
     * @example
     * // Create many MakeWebhooks
     * const makeWebhook = await prisma.makeWebhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MakeWebhooks and only return the `id`
     * const makeWebhookWithIdOnly = await prisma.makeWebhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MakeWebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, MakeWebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MakeWebhook.
     * @param {MakeWebhookDeleteArgs} args - Arguments to delete one MakeWebhook.
     * @example
     * // Delete one MakeWebhook
     * const MakeWebhook = await prisma.makeWebhook.delete({
     *   where: {
     *     // ... filter to delete one MakeWebhook
     *   }
     * })
     * 
     */
    delete<T extends MakeWebhookDeleteArgs>(args: SelectSubset<T, MakeWebhookDeleteArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MakeWebhook.
     * @param {MakeWebhookUpdateArgs} args - Arguments to update one MakeWebhook.
     * @example
     * // Update one MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MakeWebhookUpdateArgs>(args: SelectSubset<T, MakeWebhookUpdateArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MakeWebhooks.
     * @param {MakeWebhookDeleteManyArgs} args - Arguments to filter MakeWebhooks to delete.
     * @example
     * // Delete a few MakeWebhooks
     * const { count } = await prisma.makeWebhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MakeWebhookDeleteManyArgs>(args?: SelectSubset<T, MakeWebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MakeWebhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MakeWebhooks
     * const makeWebhook = await prisma.makeWebhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MakeWebhookUpdateManyArgs>(args: SelectSubset<T, MakeWebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MakeWebhooks and returns the data updated in the database.
     * @param {MakeWebhookUpdateManyAndReturnArgs} args - Arguments to update many MakeWebhooks.
     * @example
     * // Update many MakeWebhooks
     * const makeWebhook = await prisma.makeWebhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MakeWebhooks and only return the `id`
     * const makeWebhookWithIdOnly = await prisma.makeWebhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MakeWebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, MakeWebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MakeWebhook.
     * @param {MakeWebhookUpsertArgs} args - Arguments to update or create a MakeWebhook.
     * @example
     * // Update or create a MakeWebhook
     * const makeWebhook = await prisma.makeWebhook.upsert({
     *   create: {
     *     // ... data to create a MakeWebhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MakeWebhook we want to update
     *   }
     * })
     */
    upsert<T extends MakeWebhookUpsertArgs>(args: SelectSubset<T, MakeWebhookUpsertArgs<ExtArgs>>): Prisma__MakeWebhookClient<$Result.GetResult<Prisma.$MakeWebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MakeWebhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookCountArgs} args - Arguments to filter MakeWebhooks to count.
     * @example
     * // Count the number of MakeWebhooks
     * const count = await prisma.makeWebhook.count({
     *   where: {
     *     // ... the filter for the MakeWebhooks we want to count
     *   }
     * })
    **/
    count<T extends MakeWebhookCountArgs>(
      args?: Subset<T, MakeWebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MakeWebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MakeWebhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MakeWebhookAggregateArgs>(args: Subset<T, MakeWebhookAggregateArgs>): Prisma.PrismaPromise<GetMakeWebhookAggregateType<T>>

    /**
     * Group by MakeWebhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MakeWebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MakeWebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MakeWebhookGroupByArgs['orderBy'] }
        : { orderBy?: MakeWebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MakeWebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMakeWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MakeWebhook model
   */
  readonly fields: MakeWebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MakeWebhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MakeWebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MakeWebhook model
   */
  interface MakeWebhookFieldRefs {
    readonly id: FieldRef<"MakeWebhook", 'String'>
    readonly name: FieldRef<"MakeWebhook", 'String'>
    readonly url: FieldRef<"MakeWebhook", 'String'>
    readonly secret: FieldRef<"MakeWebhook", 'String'>
    readonly isActive: FieldRef<"MakeWebhook", 'Boolean'>
    readonly events: FieldRef<"MakeWebhook", 'Json'>
    readonly createdAt: FieldRef<"MakeWebhook", 'DateTime'>
    readonly updatedAt: FieldRef<"MakeWebhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MakeWebhook findUnique
   */
  export type MakeWebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter, which MakeWebhook to fetch.
     */
    where: MakeWebhookWhereUniqueInput
  }

  /**
   * MakeWebhook findUniqueOrThrow
   */
  export type MakeWebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter, which MakeWebhook to fetch.
     */
    where: MakeWebhookWhereUniqueInput
  }

  /**
   * MakeWebhook findFirst
   */
  export type MakeWebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter, which MakeWebhook to fetch.
     */
    where?: MakeWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MakeWebhooks to fetch.
     */
    orderBy?: MakeWebhookOrderByWithRelationInput | MakeWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MakeWebhooks.
     */
    cursor?: MakeWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MakeWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MakeWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MakeWebhooks.
     */
    distinct?: MakeWebhookScalarFieldEnum | MakeWebhookScalarFieldEnum[]
  }

  /**
   * MakeWebhook findFirstOrThrow
   */
  export type MakeWebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter, which MakeWebhook to fetch.
     */
    where?: MakeWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MakeWebhooks to fetch.
     */
    orderBy?: MakeWebhookOrderByWithRelationInput | MakeWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MakeWebhooks.
     */
    cursor?: MakeWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MakeWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MakeWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MakeWebhooks.
     */
    distinct?: MakeWebhookScalarFieldEnum | MakeWebhookScalarFieldEnum[]
  }

  /**
   * MakeWebhook findMany
   */
  export type MakeWebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter, which MakeWebhooks to fetch.
     */
    where?: MakeWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MakeWebhooks to fetch.
     */
    orderBy?: MakeWebhookOrderByWithRelationInput | MakeWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MakeWebhooks.
     */
    cursor?: MakeWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MakeWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MakeWebhooks.
     */
    skip?: number
    distinct?: MakeWebhookScalarFieldEnum | MakeWebhookScalarFieldEnum[]
  }

  /**
   * MakeWebhook create
   */
  export type MakeWebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * The data needed to create a MakeWebhook.
     */
    data: XOR<MakeWebhookCreateInput, MakeWebhookUncheckedCreateInput>
  }

  /**
   * MakeWebhook createMany
   */
  export type MakeWebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MakeWebhooks.
     */
    data: MakeWebhookCreateManyInput | MakeWebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MakeWebhook createManyAndReturn
   */
  export type MakeWebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * The data used to create many MakeWebhooks.
     */
    data: MakeWebhookCreateManyInput | MakeWebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MakeWebhook update
   */
  export type MakeWebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * The data needed to update a MakeWebhook.
     */
    data: XOR<MakeWebhookUpdateInput, MakeWebhookUncheckedUpdateInput>
    /**
     * Choose, which MakeWebhook to update.
     */
    where: MakeWebhookWhereUniqueInput
  }

  /**
   * MakeWebhook updateMany
   */
  export type MakeWebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MakeWebhooks.
     */
    data: XOR<MakeWebhookUpdateManyMutationInput, MakeWebhookUncheckedUpdateManyInput>
    /**
     * Filter which MakeWebhooks to update
     */
    where?: MakeWebhookWhereInput
    /**
     * Limit how many MakeWebhooks to update.
     */
    limit?: number
  }

  /**
   * MakeWebhook updateManyAndReturn
   */
  export type MakeWebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * The data used to update MakeWebhooks.
     */
    data: XOR<MakeWebhookUpdateManyMutationInput, MakeWebhookUncheckedUpdateManyInput>
    /**
     * Filter which MakeWebhooks to update
     */
    where?: MakeWebhookWhereInput
    /**
     * Limit how many MakeWebhooks to update.
     */
    limit?: number
  }

  /**
   * MakeWebhook upsert
   */
  export type MakeWebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * The filter to search for the MakeWebhook to update in case it exists.
     */
    where: MakeWebhookWhereUniqueInput
    /**
     * In case the MakeWebhook found by the `where` argument doesn't exist, create a new MakeWebhook with this data.
     */
    create: XOR<MakeWebhookCreateInput, MakeWebhookUncheckedCreateInput>
    /**
     * In case the MakeWebhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MakeWebhookUpdateInput, MakeWebhookUncheckedUpdateInput>
  }

  /**
   * MakeWebhook delete
   */
  export type MakeWebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
    /**
     * Filter which MakeWebhook to delete.
     */
    where: MakeWebhookWhereUniqueInput
  }

  /**
   * MakeWebhook deleteMany
   */
  export type MakeWebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MakeWebhooks to delete
     */
    where?: MakeWebhookWhereInput
    /**
     * Limit how many MakeWebhooks to delete.
     */
    limit?: number
  }

  /**
   * MakeWebhook without action
   */
  export type MakeWebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MakeWebhook
     */
    select?: MakeWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MakeWebhook
     */
    omit?: MakeWebhookOmit<ExtArgs> | null
  }


  /**
   * Model CookieConsent
   */

  export type AggregateCookieConsent = {
    _count: CookieConsentCountAggregateOutputType | null
    _min: CookieConsentMinAggregateOutputType | null
    _max: CookieConsentMaxAggregateOutputType | null
  }

  export type CookieConsentMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    consentedAt: Date | null
  }

  export type CookieConsentMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    consentedAt: Date | null
  }

  export type CookieConsentCountAggregateOutputType = {
    id: number
    sessionId: number
    preferences: number
    consentedAt: number
    _all: number
  }


  export type CookieConsentMinAggregateInputType = {
    id?: true
    sessionId?: true
    consentedAt?: true
  }

  export type CookieConsentMaxAggregateInputType = {
    id?: true
    sessionId?: true
    consentedAt?: true
  }

  export type CookieConsentCountAggregateInputType = {
    id?: true
    sessionId?: true
    preferences?: true
    consentedAt?: true
    _all?: true
  }

  export type CookieConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CookieConsent to aggregate.
     */
    where?: CookieConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CookieConsents to fetch.
     */
    orderBy?: CookieConsentOrderByWithRelationInput | CookieConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CookieConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CookieConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CookieConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CookieConsents
    **/
    _count?: true | CookieConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CookieConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CookieConsentMaxAggregateInputType
  }

  export type GetCookieConsentAggregateType<T extends CookieConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateCookieConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCookieConsent[P]>
      : GetScalarType<T[P], AggregateCookieConsent[P]>
  }




  export type CookieConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CookieConsentWhereInput
    orderBy?: CookieConsentOrderByWithAggregationInput | CookieConsentOrderByWithAggregationInput[]
    by: CookieConsentScalarFieldEnum[] | CookieConsentScalarFieldEnum
    having?: CookieConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CookieConsentCountAggregateInputType | true
    _min?: CookieConsentMinAggregateInputType
    _max?: CookieConsentMaxAggregateInputType
  }

  export type CookieConsentGroupByOutputType = {
    id: string
    sessionId: string
    preferences: JsonValue
    consentedAt: Date | null
    _count: CookieConsentCountAggregateOutputType | null
    _min: CookieConsentMinAggregateOutputType | null
    _max: CookieConsentMaxAggregateOutputType | null
  }

  type GetCookieConsentGroupByPayload<T extends CookieConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CookieConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CookieConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CookieConsentGroupByOutputType[P]>
            : GetScalarType<T[P], CookieConsentGroupByOutputType[P]>
        }
      >
    >


  export type CookieConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    preferences?: boolean
    consentedAt?: boolean
  }, ExtArgs["result"]["cookieConsent"]>

  export type CookieConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    preferences?: boolean
    consentedAt?: boolean
  }, ExtArgs["result"]["cookieConsent"]>

  export type CookieConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    preferences?: boolean
    consentedAt?: boolean
  }, ExtArgs["result"]["cookieConsent"]>

  export type CookieConsentSelectScalar = {
    id?: boolean
    sessionId?: boolean
    preferences?: boolean
    consentedAt?: boolean
  }

  export type CookieConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "preferences" | "consentedAt", ExtArgs["result"]["cookieConsent"]>

  export type $CookieConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CookieConsent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      preferences: Prisma.JsonValue
      consentedAt: Date | null
    }, ExtArgs["result"]["cookieConsent"]>
    composites: {}
  }

  type CookieConsentGetPayload<S extends boolean | null | undefined | CookieConsentDefaultArgs> = $Result.GetResult<Prisma.$CookieConsentPayload, S>

  type CookieConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CookieConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CookieConsentCountAggregateInputType | true
    }

  export interface CookieConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CookieConsent'], meta: { name: 'CookieConsent' } }
    /**
     * Find zero or one CookieConsent that matches the filter.
     * @param {CookieConsentFindUniqueArgs} args - Arguments to find a CookieConsent
     * @example
     * // Get one CookieConsent
     * const cookieConsent = await prisma.cookieConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CookieConsentFindUniqueArgs>(args: SelectSubset<T, CookieConsentFindUniqueArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CookieConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CookieConsentFindUniqueOrThrowArgs} args - Arguments to find a CookieConsent
     * @example
     * // Get one CookieConsent
     * const cookieConsent = await prisma.cookieConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CookieConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, CookieConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CookieConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentFindFirstArgs} args - Arguments to find a CookieConsent
     * @example
     * // Get one CookieConsent
     * const cookieConsent = await prisma.cookieConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CookieConsentFindFirstArgs>(args?: SelectSubset<T, CookieConsentFindFirstArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CookieConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentFindFirstOrThrowArgs} args - Arguments to find a CookieConsent
     * @example
     * // Get one CookieConsent
     * const cookieConsent = await prisma.cookieConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CookieConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, CookieConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CookieConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CookieConsents
     * const cookieConsents = await prisma.cookieConsent.findMany()
     * 
     * // Get first 10 CookieConsents
     * const cookieConsents = await prisma.cookieConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cookieConsentWithIdOnly = await prisma.cookieConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CookieConsentFindManyArgs>(args?: SelectSubset<T, CookieConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CookieConsent.
     * @param {CookieConsentCreateArgs} args - Arguments to create a CookieConsent.
     * @example
     * // Create one CookieConsent
     * const CookieConsent = await prisma.cookieConsent.create({
     *   data: {
     *     // ... data to create a CookieConsent
     *   }
     * })
     * 
     */
    create<T extends CookieConsentCreateArgs>(args: SelectSubset<T, CookieConsentCreateArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CookieConsents.
     * @param {CookieConsentCreateManyArgs} args - Arguments to create many CookieConsents.
     * @example
     * // Create many CookieConsents
     * const cookieConsent = await prisma.cookieConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CookieConsentCreateManyArgs>(args?: SelectSubset<T, CookieConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CookieConsents and returns the data saved in the database.
     * @param {CookieConsentCreateManyAndReturnArgs} args - Arguments to create many CookieConsents.
     * @example
     * // Create many CookieConsents
     * const cookieConsent = await prisma.cookieConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CookieConsents and only return the `id`
     * const cookieConsentWithIdOnly = await prisma.cookieConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CookieConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, CookieConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CookieConsent.
     * @param {CookieConsentDeleteArgs} args - Arguments to delete one CookieConsent.
     * @example
     * // Delete one CookieConsent
     * const CookieConsent = await prisma.cookieConsent.delete({
     *   where: {
     *     // ... filter to delete one CookieConsent
     *   }
     * })
     * 
     */
    delete<T extends CookieConsentDeleteArgs>(args: SelectSubset<T, CookieConsentDeleteArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CookieConsent.
     * @param {CookieConsentUpdateArgs} args - Arguments to update one CookieConsent.
     * @example
     * // Update one CookieConsent
     * const cookieConsent = await prisma.cookieConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CookieConsentUpdateArgs>(args: SelectSubset<T, CookieConsentUpdateArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CookieConsents.
     * @param {CookieConsentDeleteManyArgs} args - Arguments to filter CookieConsents to delete.
     * @example
     * // Delete a few CookieConsents
     * const { count } = await prisma.cookieConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CookieConsentDeleteManyArgs>(args?: SelectSubset<T, CookieConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CookieConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CookieConsents
     * const cookieConsent = await prisma.cookieConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CookieConsentUpdateManyArgs>(args: SelectSubset<T, CookieConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CookieConsents and returns the data updated in the database.
     * @param {CookieConsentUpdateManyAndReturnArgs} args - Arguments to update many CookieConsents.
     * @example
     * // Update many CookieConsents
     * const cookieConsent = await prisma.cookieConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CookieConsents and only return the `id`
     * const cookieConsentWithIdOnly = await prisma.cookieConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CookieConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, CookieConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CookieConsent.
     * @param {CookieConsentUpsertArgs} args - Arguments to update or create a CookieConsent.
     * @example
     * // Update or create a CookieConsent
     * const cookieConsent = await prisma.cookieConsent.upsert({
     *   create: {
     *     // ... data to create a CookieConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CookieConsent we want to update
     *   }
     * })
     */
    upsert<T extends CookieConsentUpsertArgs>(args: SelectSubset<T, CookieConsentUpsertArgs<ExtArgs>>): Prisma__CookieConsentClient<$Result.GetResult<Prisma.$CookieConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CookieConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentCountArgs} args - Arguments to filter CookieConsents to count.
     * @example
     * // Count the number of CookieConsents
     * const count = await prisma.cookieConsent.count({
     *   where: {
     *     // ... the filter for the CookieConsents we want to count
     *   }
     * })
    **/
    count<T extends CookieConsentCountArgs>(
      args?: Subset<T, CookieConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CookieConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CookieConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CookieConsentAggregateArgs>(args: Subset<T, CookieConsentAggregateArgs>): Prisma.PrismaPromise<GetCookieConsentAggregateType<T>>

    /**
     * Group by CookieConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CookieConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CookieConsentGroupByArgs['orderBy'] }
        : { orderBy?: CookieConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CookieConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCookieConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CookieConsent model
   */
  readonly fields: CookieConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CookieConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CookieConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CookieConsent model
   */
  interface CookieConsentFieldRefs {
    readonly id: FieldRef<"CookieConsent", 'String'>
    readonly sessionId: FieldRef<"CookieConsent", 'String'>
    readonly preferences: FieldRef<"CookieConsent", 'Json'>
    readonly consentedAt: FieldRef<"CookieConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CookieConsent findUnique
   */
  export type CookieConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter, which CookieConsent to fetch.
     */
    where: CookieConsentWhereUniqueInput
  }

  /**
   * CookieConsent findUniqueOrThrow
   */
  export type CookieConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter, which CookieConsent to fetch.
     */
    where: CookieConsentWhereUniqueInput
  }

  /**
   * CookieConsent findFirst
   */
  export type CookieConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter, which CookieConsent to fetch.
     */
    where?: CookieConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CookieConsents to fetch.
     */
    orderBy?: CookieConsentOrderByWithRelationInput | CookieConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CookieConsents.
     */
    cursor?: CookieConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CookieConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CookieConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CookieConsents.
     */
    distinct?: CookieConsentScalarFieldEnum | CookieConsentScalarFieldEnum[]
  }

  /**
   * CookieConsent findFirstOrThrow
   */
  export type CookieConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter, which CookieConsent to fetch.
     */
    where?: CookieConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CookieConsents to fetch.
     */
    orderBy?: CookieConsentOrderByWithRelationInput | CookieConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CookieConsents.
     */
    cursor?: CookieConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CookieConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CookieConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CookieConsents.
     */
    distinct?: CookieConsentScalarFieldEnum | CookieConsentScalarFieldEnum[]
  }

  /**
   * CookieConsent findMany
   */
  export type CookieConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter, which CookieConsents to fetch.
     */
    where?: CookieConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CookieConsents to fetch.
     */
    orderBy?: CookieConsentOrderByWithRelationInput | CookieConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CookieConsents.
     */
    cursor?: CookieConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CookieConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CookieConsents.
     */
    skip?: number
    distinct?: CookieConsentScalarFieldEnum | CookieConsentScalarFieldEnum[]
  }

  /**
   * CookieConsent create
   */
  export type CookieConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * The data needed to create a CookieConsent.
     */
    data: XOR<CookieConsentCreateInput, CookieConsentUncheckedCreateInput>
  }

  /**
   * CookieConsent createMany
   */
  export type CookieConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CookieConsents.
     */
    data: CookieConsentCreateManyInput | CookieConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CookieConsent createManyAndReturn
   */
  export type CookieConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * The data used to create many CookieConsents.
     */
    data: CookieConsentCreateManyInput | CookieConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CookieConsent update
   */
  export type CookieConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * The data needed to update a CookieConsent.
     */
    data: XOR<CookieConsentUpdateInput, CookieConsentUncheckedUpdateInput>
    /**
     * Choose, which CookieConsent to update.
     */
    where: CookieConsentWhereUniqueInput
  }

  /**
   * CookieConsent updateMany
   */
  export type CookieConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CookieConsents.
     */
    data: XOR<CookieConsentUpdateManyMutationInput, CookieConsentUncheckedUpdateManyInput>
    /**
     * Filter which CookieConsents to update
     */
    where?: CookieConsentWhereInput
    /**
     * Limit how many CookieConsents to update.
     */
    limit?: number
  }

  /**
   * CookieConsent updateManyAndReturn
   */
  export type CookieConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * The data used to update CookieConsents.
     */
    data: XOR<CookieConsentUpdateManyMutationInput, CookieConsentUncheckedUpdateManyInput>
    /**
     * Filter which CookieConsents to update
     */
    where?: CookieConsentWhereInput
    /**
     * Limit how many CookieConsents to update.
     */
    limit?: number
  }

  /**
   * CookieConsent upsert
   */
  export type CookieConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * The filter to search for the CookieConsent to update in case it exists.
     */
    where: CookieConsentWhereUniqueInput
    /**
     * In case the CookieConsent found by the `where` argument doesn't exist, create a new CookieConsent with this data.
     */
    create: XOR<CookieConsentCreateInput, CookieConsentUncheckedCreateInput>
    /**
     * In case the CookieConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CookieConsentUpdateInput, CookieConsentUncheckedUpdateInput>
  }

  /**
   * CookieConsent delete
   */
  export type CookieConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
    /**
     * Filter which CookieConsent to delete.
     */
    where: CookieConsentWhereUniqueInput
  }

  /**
   * CookieConsent deleteMany
   */
  export type CookieConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CookieConsents to delete
     */
    where?: CookieConsentWhereInput
    /**
     * Limit how many CookieConsents to delete.
     */
    limit?: number
  }

  /**
   * CookieConsent without action
   */
  export type CookieConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CookieConsent
     */
    select?: CookieConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CookieConsent
     */
    omit?: CookieConsentOmit<ExtArgs> | null
  }


  /**
   * Model AdSpace
   */

  export type AggregateAdSpace = {
    _count: AdSpaceCountAggregateOutputType | null
    _min: AdSpaceMinAggregateOutputType | null
    _max: AdSpaceMaxAggregateOutputType | null
  }

  export type AdSpaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    adType: string | null
    isActive: boolean | null
    adCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdSpaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    adType: string | null
    isActive: boolean | null
    adCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdSpaceCountAggregateOutputType = {
    id: number
    name: number
    location: number
    adType: number
    isActive: number
    adCode: number
    dimensions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdSpaceMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    adType?: true
    isActive?: true
    adCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdSpaceMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    adType?: true
    isActive?: true
    adCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdSpaceCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    adType?: true
    isActive?: true
    adCode?: true
    dimensions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdSpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSpace to aggregate.
     */
    where?: AdSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSpaces to fetch.
     */
    orderBy?: AdSpaceOrderByWithRelationInput | AdSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdSpaces
    **/
    _count?: true | AdSpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdSpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdSpaceMaxAggregateInputType
  }

  export type GetAdSpaceAggregateType<T extends AdSpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdSpace[P]>
      : GetScalarType<T[P], AggregateAdSpace[P]>
  }




  export type AdSpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSpaceWhereInput
    orderBy?: AdSpaceOrderByWithAggregationInput | AdSpaceOrderByWithAggregationInput[]
    by: AdSpaceScalarFieldEnum[] | AdSpaceScalarFieldEnum
    having?: AdSpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdSpaceCountAggregateInputType | true
    _min?: AdSpaceMinAggregateInputType
    _max?: AdSpaceMaxAggregateInputType
  }

  export type AdSpaceGroupByOutputType = {
    id: string
    name: string
    location: string
    adType: string
    isActive: boolean
    adCode: string | null
    dimensions: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AdSpaceCountAggregateOutputType | null
    _min: AdSpaceMinAggregateOutputType | null
    _max: AdSpaceMaxAggregateOutputType | null
  }

  type GetAdSpaceGroupByPayload<T extends AdSpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdSpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdSpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdSpaceGroupByOutputType[P]>
            : GetScalarType<T[P], AdSpaceGroupByOutputType[P]>
        }
      >
    >


  export type AdSpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    adType?: boolean
    isActive?: boolean
    adCode?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adSpace"]>

  export type AdSpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    adType?: boolean
    isActive?: boolean
    adCode?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adSpace"]>

  export type AdSpaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    adType?: boolean
    isActive?: boolean
    adCode?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adSpace"]>

  export type AdSpaceSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    adType?: boolean
    isActive?: boolean
    adCode?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdSpaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "adType" | "isActive" | "adCode" | "dimensions" | "createdAt" | "updatedAt", ExtArgs["result"]["adSpace"]>

  export type $AdSpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdSpace"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      adType: string
      isActive: boolean
      adCode: string | null
      dimensions: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["adSpace"]>
    composites: {}
  }

  type AdSpaceGetPayload<S extends boolean | null | undefined | AdSpaceDefaultArgs> = $Result.GetResult<Prisma.$AdSpacePayload, S>

  type AdSpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdSpaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdSpaceCountAggregateInputType | true
    }

  export interface AdSpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdSpace'], meta: { name: 'AdSpace' } }
    /**
     * Find zero or one AdSpace that matches the filter.
     * @param {AdSpaceFindUniqueArgs} args - Arguments to find a AdSpace
     * @example
     * // Get one AdSpace
     * const adSpace = await prisma.adSpace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdSpaceFindUniqueArgs>(args: SelectSubset<T, AdSpaceFindUniqueArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdSpace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdSpaceFindUniqueOrThrowArgs} args - Arguments to find a AdSpace
     * @example
     * // Get one AdSpace
     * const adSpace = await prisma.adSpace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdSpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, AdSpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSpace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceFindFirstArgs} args - Arguments to find a AdSpace
     * @example
     * // Get one AdSpace
     * const adSpace = await prisma.adSpace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdSpaceFindFirstArgs>(args?: SelectSubset<T, AdSpaceFindFirstArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSpace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceFindFirstOrThrowArgs} args - Arguments to find a AdSpace
     * @example
     * // Get one AdSpace
     * const adSpace = await prisma.adSpace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdSpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, AdSpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdSpaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdSpaces
     * const adSpaces = await prisma.adSpace.findMany()
     * 
     * // Get first 10 AdSpaces
     * const adSpaces = await prisma.adSpace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adSpaceWithIdOnly = await prisma.adSpace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdSpaceFindManyArgs>(args?: SelectSubset<T, AdSpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdSpace.
     * @param {AdSpaceCreateArgs} args - Arguments to create a AdSpace.
     * @example
     * // Create one AdSpace
     * const AdSpace = await prisma.adSpace.create({
     *   data: {
     *     // ... data to create a AdSpace
     *   }
     * })
     * 
     */
    create<T extends AdSpaceCreateArgs>(args: SelectSubset<T, AdSpaceCreateArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdSpaces.
     * @param {AdSpaceCreateManyArgs} args - Arguments to create many AdSpaces.
     * @example
     * // Create many AdSpaces
     * const adSpace = await prisma.adSpace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdSpaceCreateManyArgs>(args?: SelectSubset<T, AdSpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdSpaces and returns the data saved in the database.
     * @param {AdSpaceCreateManyAndReturnArgs} args - Arguments to create many AdSpaces.
     * @example
     * // Create many AdSpaces
     * const adSpace = await prisma.adSpace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdSpaces and only return the `id`
     * const adSpaceWithIdOnly = await prisma.adSpace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdSpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, AdSpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdSpace.
     * @param {AdSpaceDeleteArgs} args - Arguments to delete one AdSpace.
     * @example
     * // Delete one AdSpace
     * const AdSpace = await prisma.adSpace.delete({
     *   where: {
     *     // ... filter to delete one AdSpace
     *   }
     * })
     * 
     */
    delete<T extends AdSpaceDeleteArgs>(args: SelectSubset<T, AdSpaceDeleteArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdSpace.
     * @param {AdSpaceUpdateArgs} args - Arguments to update one AdSpace.
     * @example
     * // Update one AdSpace
     * const adSpace = await prisma.adSpace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdSpaceUpdateArgs>(args: SelectSubset<T, AdSpaceUpdateArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdSpaces.
     * @param {AdSpaceDeleteManyArgs} args - Arguments to filter AdSpaces to delete.
     * @example
     * // Delete a few AdSpaces
     * const { count } = await prisma.adSpace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdSpaceDeleteManyArgs>(args?: SelectSubset<T, AdSpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdSpaces
     * const adSpace = await prisma.adSpace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdSpaceUpdateManyArgs>(args: SelectSubset<T, AdSpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSpaces and returns the data updated in the database.
     * @param {AdSpaceUpdateManyAndReturnArgs} args - Arguments to update many AdSpaces.
     * @example
     * // Update many AdSpaces
     * const adSpace = await prisma.adSpace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdSpaces and only return the `id`
     * const adSpaceWithIdOnly = await prisma.adSpace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdSpaceUpdateManyAndReturnArgs>(args: SelectSubset<T, AdSpaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdSpace.
     * @param {AdSpaceUpsertArgs} args - Arguments to update or create a AdSpace.
     * @example
     * // Update or create a AdSpace
     * const adSpace = await prisma.adSpace.upsert({
     *   create: {
     *     // ... data to create a AdSpace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdSpace we want to update
     *   }
     * })
     */
    upsert<T extends AdSpaceUpsertArgs>(args: SelectSubset<T, AdSpaceUpsertArgs<ExtArgs>>): Prisma__AdSpaceClient<$Result.GetResult<Prisma.$AdSpacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceCountArgs} args - Arguments to filter AdSpaces to count.
     * @example
     * // Count the number of AdSpaces
     * const count = await prisma.adSpace.count({
     *   where: {
     *     // ... the filter for the AdSpaces we want to count
     *   }
     * })
    **/
    count<T extends AdSpaceCountArgs>(
      args?: Subset<T, AdSpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdSpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdSpaceAggregateArgs>(args: Subset<T, AdSpaceAggregateArgs>): Prisma.PrismaPromise<GetAdSpaceAggregateType<T>>

    /**
     * Group by AdSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdSpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdSpaceGroupByArgs['orderBy'] }
        : { orderBy?: AdSpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdSpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdSpace model
   */
  readonly fields: AdSpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdSpace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdSpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdSpace model
   */
  interface AdSpaceFieldRefs {
    readonly id: FieldRef<"AdSpace", 'String'>
    readonly name: FieldRef<"AdSpace", 'String'>
    readonly location: FieldRef<"AdSpace", 'String'>
    readonly adType: FieldRef<"AdSpace", 'String'>
    readonly isActive: FieldRef<"AdSpace", 'Boolean'>
    readonly adCode: FieldRef<"AdSpace", 'String'>
    readonly dimensions: FieldRef<"AdSpace", 'Json'>
    readonly createdAt: FieldRef<"AdSpace", 'DateTime'>
    readonly updatedAt: FieldRef<"AdSpace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdSpace findUnique
   */
  export type AdSpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter, which AdSpace to fetch.
     */
    where: AdSpaceWhereUniqueInput
  }

  /**
   * AdSpace findUniqueOrThrow
   */
  export type AdSpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter, which AdSpace to fetch.
     */
    where: AdSpaceWhereUniqueInput
  }

  /**
   * AdSpace findFirst
   */
  export type AdSpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter, which AdSpace to fetch.
     */
    where?: AdSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSpaces to fetch.
     */
    orderBy?: AdSpaceOrderByWithRelationInput | AdSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSpaces.
     */
    cursor?: AdSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSpaces.
     */
    distinct?: AdSpaceScalarFieldEnum | AdSpaceScalarFieldEnum[]
  }

  /**
   * AdSpace findFirstOrThrow
   */
  export type AdSpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter, which AdSpace to fetch.
     */
    where?: AdSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSpaces to fetch.
     */
    orderBy?: AdSpaceOrderByWithRelationInput | AdSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSpaces.
     */
    cursor?: AdSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSpaces.
     */
    distinct?: AdSpaceScalarFieldEnum | AdSpaceScalarFieldEnum[]
  }

  /**
   * AdSpace findMany
   */
  export type AdSpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter, which AdSpaces to fetch.
     */
    where?: AdSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSpaces to fetch.
     */
    orderBy?: AdSpaceOrderByWithRelationInput | AdSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdSpaces.
     */
    cursor?: AdSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSpaces.
     */
    skip?: number
    distinct?: AdSpaceScalarFieldEnum | AdSpaceScalarFieldEnum[]
  }

  /**
   * AdSpace create
   */
  export type AdSpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * The data needed to create a AdSpace.
     */
    data: XOR<AdSpaceCreateInput, AdSpaceUncheckedCreateInput>
  }

  /**
   * AdSpace createMany
   */
  export type AdSpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdSpaces.
     */
    data: AdSpaceCreateManyInput | AdSpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdSpace createManyAndReturn
   */
  export type AdSpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * The data used to create many AdSpaces.
     */
    data: AdSpaceCreateManyInput | AdSpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdSpace update
   */
  export type AdSpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * The data needed to update a AdSpace.
     */
    data: XOR<AdSpaceUpdateInput, AdSpaceUncheckedUpdateInput>
    /**
     * Choose, which AdSpace to update.
     */
    where: AdSpaceWhereUniqueInput
  }

  /**
   * AdSpace updateMany
   */
  export type AdSpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdSpaces.
     */
    data: XOR<AdSpaceUpdateManyMutationInput, AdSpaceUncheckedUpdateManyInput>
    /**
     * Filter which AdSpaces to update
     */
    where?: AdSpaceWhereInput
    /**
     * Limit how many AdSpaces to update.
     */
    limit?: number
  }

  /**
   * AdSpace updateManyAndReturn
   */
  export type AdSpaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * The data used to update AdSpaces.
     */
    data: XOR<AdSpaceUpdateManyMutationInput, AdSpaceUncheckedUpdateManyInput>
    /**
     * Filter which AdSpaces to update
     */
    where?: AdSpaceWhereInput
    /**
     * Limit how many AdSpaces to update.
     */
    limit?: number
  }

  /**
   * AdSpace upsert
   */
  export type AdSpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * The filter to search for the AdSpace to update in case it exists.
     */
    where: AdSpaceWhereUniqueInput
    /**
     * In case the AdSpace found by the `where` argument doesn't exist, create a new AdSpace with this data.
     */
    create: XOR<AdSpaceCreateInput, AdSpaceUncheckedCreateInput>
    /**
     * In case the AdSpace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdSpaceUpdateInput, AdSpaceUncheckedUpdateInput>
  }

  /**
   * AdSpace delete
   */
  export type AdSpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
    /**
     * Filter which AdSpace to delete.
     */
    where: AdSpaceWhereUniqueInput
  }

  /**
   * AdSpace deleteMany
   */
  export type AdSpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSpaces to delete
     */
    where?: AdSpaceWhereInput
    /**
     * Limit how many AdSpaces to delete.
     */
    limit?: number
  }

  /**
   * AdSpace without action
   */
  export type AdSpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSpace
     */
    select?: AdSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSpace
     */
    omit?: AdSpaceOmit<ExtArgs> | null
  }


  /**
   * Model CustomNiche
   */

  export type AggregateCustomNiche = {
    _count: CustomNicheCountAggregateOutputType | null
    _avg: CustomNicheAvgAggregateOutputType | null
    _sum: CustomNicheSumAggregateOutputType | null
    _min: CustomNicheMinAggregateOutputType | null
    _max: CustomNicheMaxAggregateOutputType | null
  }

  export type CustomNicheAvgAggregateOutputType = {
    profitabilityScore: number | null
  }

  export type CustomNicheSumAggregateOutputType = {
    profitabilityScore: number | null
  }

  export type CustomNicheMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetAudience: string | null
    competitionLevel: string | null
    profitabilityScore: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomNicheMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetAudience: string | null
    competitionLevel: string | null
    profitabilityScore: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomNicheCountAggregateOutputType = {
    id: number
    name: number
    description: number
    keywords: number
    categories: number
    targetAudience: number
    competitionLevel: number
    profitabilityScore: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomNicheAvgAggregateInputType = {
    profitabilityScore?: true
  }

  export type CustomNicheSumAggregateInputType = {
    profitabilityScore?: true
  }

  export type CustomNicheMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetAudience?: true
    competitionLevel?: true
    profitabilityScore?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomNicheMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetAudience?: true
    competitionLevel?: true
    profitabilityScore?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomNicheCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    keywords?: true
    categories?: true
    targetAudience?: true
    competitionLevel?: true
    profitabilityScore?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomNicheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomNiche to aggregate.
     */
    where?: CustomNicheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomNiches to fetch.
     */
    orderBy?: CustomNicheOrderByWithRelationInput | CustomNicheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomNicheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomNiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomNiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomNiches
    **/
    _count?: true | CustomNicheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomNicheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomNicheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomNicheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomNicheMaxAggregateInputType
  }

  export type GetCustomNicheAggregateType<T extends CustomNicheAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomNiche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomNiche[P]>
      : GetScalarType<T[P], AggregateCustomNiche[P]>
  }




  export type CustomNicheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomNicheWhereInput
    orderBy?: CustomNicheOrderByWithAggregationInput | CustomNicheOrderByWithAggregationInput[]
    by: CustomNicheScalarFieldEnum[] | CustomNicheScalarFieldEnum
    having?: CustomNicheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomNicheCountAggregateInputType | true
    _avg?: CustomNicheAvgAggregateInputType
    _sum?: CustomNicheSumAggregateInputType
    _min?: CustomNicheMinAggregateInputType
    _max?: CustomNicheMaxAggregateInputType
  }

  export type CustomNicheGroupByOutputType = {
    id: string
    name: string
    description: string | null
    keywords: JsonValue | null
    categories: JsonValue | null
    targetAudience: string | null
    competitionLevel: string | null
    profitabilityScore: number | null
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: CustomNicheCountAggregateOutputType | null
    _avg: CustomNicheAvgAggregateOutputType | null
    _sum: CustomNicheSumAggregateOutputType | null
    _min: CustomNicheMinAggregateOutputType | null
    _max: CustomNicheMaxAggregateOutputType | null
  }

  type GetCustomNicheGroupByPayload<T extends CustomNicheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomNicheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomNicheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomNicheGroupByOutputType[P]>
            : GetScalarType<T[P], CustomNicheGroupByOutputType[P]>
        }
      >
    >


  export type CustomNicheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
    categories?: boolean
    targetAudience?: boolean
    competitionLevel?: boolean
    profitabilityScore?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | CustomNiche$sitesArgs<ExtArgs>
    _count?: boolean | CustomNicheCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customNiche"]>

  export type CustomNicheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
    categories?: boolean
    targetAudience?: boolean
    competitionLevel?: boolean
    profitabilityScore?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customNiche"]>

  export type CustomNicheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
    categories?: boolean
    targetAudience?: boolean
    competitionLevel?: boolean
    profitabilityScore?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customNiche"]>

  export type CustomNicheSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    keywords?: boolean
    categories?: boolean
    targetAudience?: boolean
    competitionLevel?: boolean
    profitabilityScore?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomNicheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "keywords" | "categories" | "targetAudience" | "competitionLevel" | "profitabilityScore" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customNiche"]>
  export type CustomNicheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | CustomNiche$sitesArgs<ExtArgs>
    _count?: boolean | CustomNicheCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomNicheIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomNicheIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomNichePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomNiche"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      keywords: Prisma.JsonValue | null
      categories: Prisma.JsonValue | null
      targetAudience: string | null
      competitionLevel: string | null
      profitabilityScore: number | null
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["customNiche"]>
    composites: {}
  }

  type CustomNicheGetPayload<S extends boolean | null | undefined | CustomNicheDefaultArgs> = $Result.GetResult<Prisma.$CustomNichePayload, S>

  type CustomNicheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomNicheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomNicheCountAggregateInputType | true
    }

  export interface CustomNicheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomNiche'], meta: { name: 'CustomNiche' } }
    /**
     * Find zero or one CustomNiche that matches the filter.
     * @param {CustomNicheFindUniqueArgs} args - Arguments to find a CustomNiche
     * @example
     * // Get one CustomNiche
     * const customNiche = await prisma.customNiche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomNicheFindUniqueArgs>(args: SelectSubset<T, CustomNicheFindUniqueArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomNiche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomNicheFindUniqueOrThrowArgs} args - Arguments to find a CustomNiche
     * @example
     * // Get one CustomNiche
     * const customNiche = await prisma.customNiche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomNicheFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomNicheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomNiche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheFindFirstArgs} args - Arguments to find a CustomNiche
     * @example
     * // Get one CustomNiche
     * const customNiche = await prisma.customNiche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomNicheFindFirstArgs>(args?: SelectSubset<T, CustomNicheFindFirstArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomNiche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheFindFirstOrThrowArgs} args - Arguments to find a CustomNiche
     * @example
     * // Get one CustomNiche
     * const customNiche = await prisma.customNiche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomNicheFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomNicheFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomNiches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomNiches
     * const customNiches = await prisma.customNiche.findMany()
     * 
     * // Get first 10 CustomNiches
     * const customNiches = await prisma.customNiche.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customNicheWithIdOnly = await prisma.customNiche.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomNicheFindManyArgs>(args?: SelectSubset<T, CustomNicheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomNiche.
     * @param {CustomNicheCreateArgs} args - Arguments to create a CustomNiche.
     * @example
     * // Create one CustomNiche
     * const CustomNiche = await prisma.customNiche.create({
     *   data: {
     *     // ... data to create a CustomNiche
     *   }
     * })
     * 
     */
    create<T extends CustomNicheCreateArgs>(args: SelectSubset<T, CustomNicheCreateArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomNiches.
     * @param {CustomNicheCreateManyArgs} args - Arguments to create many CustomNiches.
     * @example
     * // Create many CustomNiches
     * const customNiche = await prisma.customNiche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomNicheCreateManyArgs>(args?: SelectSubset<T, CustomNicheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomNiches and returns the data saved in the database.
     * @param {CustomNicheCreateManyAndReturnArgs} args - Arguments to create many CustomNiches.
     * @example
     * // Create many CustomNiches
     * const customNiche = await prisma.customNiche.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomNiches and only return the `id`
     * const customNicheWithIdOnly = await prisma.customNiche.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomNicheCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomNicheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomNiche.
     * @param {CustomNicheDeleteArgs} args - Arguments to delete one CustomNiche.
     * @example
     * // Delete one CustomNiche
     * const CustomNiche = await prisma.customNiche.delete({
     *   where: {
     *     // ... filter to delete one CustomNiche
     *   }
     * })
     * 
     */
    delete<T extends CustomNicheDeleteArgs>(args: SelectSubset<T, CustomNicheDeleteArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomNiche.
     * @param {CustomNicheUpdateArgs} args - Arguments to update one CustomNiche.
     * @example
     * // Update one CustomNiche
     * const customNiche = await prisma.customNiche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomNicheUpdateArgs>(args: SelectSubset<T, CustomNicheUpdateArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomNiches.
     * @param {CustomNicheDeleteManyArgs} args - Arguments to filter CustomNiches to delete.
     * @example
     * // Delete a few CustomNiches
     * const { count } = await prisma.customNiche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomNicheDeleteManyArgs>(args?: SelectSubset<T, CustomNicheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomNiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomNiches
     * const customNiche = await prisma.customNiche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomNicheUpdateManyArgs>(args: SelectSubset<T, CustomNicheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomNiches and returns the data updated in the database.
     * @param {CustomNicheUpdateManyAndReturnArgs} args - Arguments to update many CustomNiches.
     * @example
     * // Update many CustomNiches
     * const customNiche = await prisma.customNiche.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomNiches and only return the `id`
     * const customNicheWithIdOnly = await prisma.customNiche.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomNicheUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomNicheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomNiche.
     * @param {CustomNicheUpsertArgs} args - Arguments to update or create a CustomNiche.
     * @example
     * // Update or create a CustomNiche
     * const customNiche = await prisma.customNiche.upsert({
     *   create: {
     *     // ... data to create a CustomNiche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomNiche we want to update
     *   }
     * })
     */
    upsert<T extends CustomNicheUpsertArgs>(args: SelectSubset<T, CustomNicheUpsertArgs<ExtArgs>>): Prisma__CustomNicheClient<$Result.GetResult<Prisma.$CustomNichePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomNiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheCountArgs} args - Arguments to filter CustomNiches to count.
     * @example
     * // Count the number of CustomNiches
     * const count = await prisma.customNiche.count({
     *   where: {
     *     // ... the filter for the CustomNiches we want to count
     *   }
     * })
    **/
    count<T extends CustomNicheCountArgs>(
      args?: Subset<T, CustomNicheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomNicheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomNiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomNicheAggregateArgs>(args: Subset<T, CustomNicheAggregateArgs>): Prisma.PrismaPromise<GetCustomNicheAggregateType<T>>

    /**
     * Group by CustomNiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomNicheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomNicheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomNicheGroupByArgs['orderBy'] }
        : { orderBy?: CustomNicheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomNicheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomNicheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomNiche model
   */
  readonly fields: CustomNicheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomNiche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomNicheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends CustomNiche$sitesArgs<ExtArgs> = {}>(args?: Subset<T, CustomNiche$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomNiche model
   */
  interface CustomNicheFieldRefs {
    readonly id: FieldRef<"CustomNiche", 'String'>
    readonly name: FieldRef<"CustomNiche", 'String'>
    readonly description: FieldRef<"CustomNiche", 'String'>
    readonly keywords: FieldRef<"CustomNiche", 'Json'>
    readonly categories: FieldRef<"CustomNiche", 'Json'>
    readonly targetAudience: FieldRef<"CustomNiche", 'String'>
    readonly competitionLevel: FieldRef<"CustomNiche", 'String'>
    readonly profitabilityScore: FieldRef<"CustomNiche", 'Int'>
    readonly isActive: FieldRef<"CustomNiche", 'Boolean'>
    readonly createdAt: FieldRef<"CustomNiche", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomNiche", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomNiche findUnique
   */
  export type CustomNicheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter, which CustomNiche to fetch.
     */
    where: CustomNicheWhereUniqueInput
  }

  /**
   * CustomNiche findUniqueOrThrow
   */
  export type CustomNicheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter, which CustomNiche to fetch.
     */
    where: CustomNicheWhereUniqueInput
  }

  /**
   * CustomNiche findFirst
   */
  export type CustomNicheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter, which CustomNiche to fetch.
     */
    where?: CustomNicheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomNiches to fetch.
     */
    orderBy?: CustomNicheOrderByWithRelationInput | CustomNicheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomNiches.
     */
    cursor?: CustomNicheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomNiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomNiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomNiches.
     */
    distinct?: CustomNicheScalarFieldEnum | CustomNicheScalarFieldEnum[]
  }

  /**
   * CustomNiche findFirstOrThrow
   */
  export type CustomNicheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter, which CustomNiche to fetch.
     */
    where?: CustomNicheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomNiches to fetch.
     */
    orderBy?: CustomNicheOrderByWithRelationInput | CustomNicheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomNiches.
     */
    cursor?: CustomNicheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomNiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomNiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomNiches.
     */
    distinct?: CustomNicheScalarFieldEnum | CustomNicheScalarFieldEnum[]
  }

  /**
   * CustomNiche findMany
   */
  export type CustomNicheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter, which CustomNiches to fetch.
     */
    where?: CustomNicheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomNiches to fetch.
     */
    orderBy?: CustomNicheOrderByWithRelationInput | CustomNicheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomNiches.
     */
    cursor?: CustomNicheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomNiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomNiches.
     */
    skip?: number
    distinct?: CustomNicheScalarFieldEnum | CustomNicheScalarFieldEnum[]
  }

  /**
   * CustomNiche create
   */
  export type CustomNicheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomNiche.
     */
    data: XOR<CustomNicheCreateInput, CustomNicheUncheckedCreateInput>
  }

  /**
   * CustomNiche createMany
   */
  export type CustomNicheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomNiches.
     */
    data: CustomNicheCreateManyInput | CustomNicheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomNiche createManyAndReturn
   */
  export type CustomNicheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * The data used to create many CustomNiches.
     */
    data: CustomNicheCreateManyInput | CustomNicheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomNiche update
   */
  export type CustomNicheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomNiche.
     */
    data: XOR<CustomNicheUpdateInput, CustomNicheUncheckedUpdateInput>
    /**
     * Choose, which CustomNiche to update.
     */
    where: CustomNicheWhereUniqueInput
  }

  /**
   * CustomNiche updateMany
   */
  export type CustomNicheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomNiches.
     */
    data: XOR<CustomNicheUpdateManyMutationInput, CustomNicheUncheckedUpdateManyInput>
    /**
     * Filter which CustomNiches to update
     */
    where?: CustomNicheWhereInput
    /**
     * Limit how many CustomNiches to update.
     */
    limit?: number
  }

  /**
   * CustomNiche updateManyAndReturn
   */
  export type CustomNicheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * The data used to update CustomNiches.
     */
    data: XOR<CustomNicheUpdateManyMutationInput, CustomNicheUncheckedUpdateManyInput>
    /**
     * Filter which CustomNiches to update
     */
    where?: CustomNicheWhereInput
    /**
     * Limit how many CustomNiches to update.
     */
    limit?: number
  }

  /**
   * CustomNiche upsert
   */
  export type CustomNicheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomNiche to update in case it exists.
     */
    where: CustomNicheWhereUniqueInput
    /**
     * In case the CustomNiche found by the `where` argument doesn't exist, create a new CustomNiche with this data.
     */
    create: XOR<CustomNicheCreateInput, CustomNicheUncheckedCreateInput>
    /**
     * In case the CustomNiche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomNicheUpdateInput, CustomNicheUncheckedUpdateInput>
  }

  /**
   * CustomNiche delete
   */
  export type CustomNicheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
    /**
     * Filter which CustomNiche to delete.
     */
    where: CustomNicheWhereUniqueInput
  }

  /**
   * CustomNiche deleteMany
   */
  export type CustomNicheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomNiches to delete
     */
    where?: CustomNicheWhereInput
    /**
     * Limit how many CustomNiches to delete.
     */
    limit?: number
  }

  /**
   * CustomNiche.sites
   */
  export type CustomNiche$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * CustomNiche without action
   */
  export type CustomNicheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomNiche
     */
    select?: CustomNicheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomNiche
     */
    omit?: CustomNicheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomNicheInclude<ExtArgs> | null
  }


  /**
   * Model AutoBlogPost
   */

  export type AggregateAutoBlogPost = {
    _count: AutoBlogPostCountAggregateOutputType | null
    _avg: AutoBlogPostAvgAggregateOutputType | null
    _sum: AutoBlogPostSumAggregateOutputType | null
    _min: AutoBlogPostMinAggregateOutputType | null
    _max: AutoBlogPostMaxAggregateOutputType | null
  }

  export type AutoBlogPostAvgAggregateOutputType = {
    wordCount: number | null
    readingTime: number | null
    generationCost: Decimal | null
  }

  export type AutoBlogPostSumAggregateOutputType = {
    wordCount: number | null
    readingTime: number | null
    generationCost: Decimal | null
  }

  export type AutoBlogPostMinAggregateOutputType = {
    id: string | null
    siteId: string | null
    title: string | null
    content: string | null
    summary: string | null
    featuredImage: string | null
    status: string | null
    publishedAt: Date | null
    scheduledAt: Date | null
    category: string | null
    postType: string | null
    wordCount: number | null
    readingTime: number | null
    aiProvider: string | null
    generationCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoBlogPostMaxAggregateOutputType = {
    id: string | null
    siteId: string | null
    title: string | null
    content: string | null
    summary: string | null
    featuredImage: string | null
    status: string | null
    publishedAt: Date | null
    scheduledAt: Date | null
    category: string | null
    postType: string | null
    wordCount: number | null
    readingTime: number | null
    aiProvider: string | null
    generationCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoBlogPostCountAggregateOutputType = {
    id: number
    siteId: number
    title: number
    content: number
    summary: number
    keyTakeaways: number
    featuredImage: number
    status: number
    publishedAt: number
    scheduledAt: number
    seoData: number
    tags: number
    category: number
    postType: number
    wordCount: number
    readingTime: number
    affiliateLinks: number
    internalLinks: number
    externalLinks: number
    aiProvider: number
    generationCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutoBlogPostAvgAggregateInputType = {
    wordCount?: true
    readingTime?: true
    generationCost?: true
  }

  export type AutoBlogPostSumAggregateInputType = {
    wordCount?: true
    readingTime?: true
    generationCost?: true
  }

  export type AutoBlogPostMinAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    content?: true
    summary?: true
    featuredImage?: true
    status?: true
    publishedAt?: true
    scheduledAt?: true
    category?: true
    postType?: true
    wordCount?: true
    readingTime?: true
    aiProvider?: true
    generationCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoBlogPostMaxAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    content?: true
    summary?: true
    featuredImage?: true
    status?: true
    publishedAt?: true
    scheduledAt?: true
    category?: true
    postType?: true
    wordCount?: true
    readingTime?: true
    aiProvider?: true
    generationCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoBlogPostCountAggregateInputType = {
    id?: true
    siteId?: true
    title?: true
    content?: true
    summary?: true
    keyTakeaways?: true
    featuredImage?: true
    status?: true
    publishedAt?: true
    scheduledAt?: true
    seoData?: true
    tags?: true
    category?: true
    postType?: true
    wordCount?: true
    readingTime?: true
    affiliateLinks?: true
    internalLinks?: true
    externalLinks?: true
    aiProvider?: true
    generationCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutoBlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoBlogPost to aggregate.
     */
    where?: AutoBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoBlogPosts to fetch.
     */
    orderBy?: AutoBlogPostOrderByWithRelationInput | AutoBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoBlogPosts
    **/
    _count?: true | AutoBlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoBlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoBlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoBlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoBlogPostMaxAggregateInputType
  }

  export type GetAutoBlogPostAggregateType<T extends AutoBlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoBlogPost[P]>
      : GetScalarType<T[P], AggregateAutoBlogPost[P]>
  }




  export type AutoBlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoBlogPostWhereInput
    orderBy?: AutoBlogPostOrderByWithAggregationInput | AutoBlogPostOrderByWithAggregationInput[]
    by: AutoBlogPostScalarFieldEnum[] | AutoBlogPostScalarFieldEnum
    having?: AutoBlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoBlogPostCountAggregateInputType | true
    _avg?: AutoBlogPostAvgAggregateInputType
    _sum?: AutoBlogPostSumAggregateInputType
    _min?: AutoBlogPostMinAggregateInputType
    _max?: AutoBlogPostMaxAggregateInputType
  }

  export type AutoBlogPostGroupByOutputType = {
    id: string
    siteId: string
    title: string
    content: string
    summary: string | null
    keyTakeaways: JsonValue | null
    featuredImage: string | null
    status: string
    publishedAt: Date | null
    scheduledAt: Date | null
    seoData: JsonValue | null
    tags: JsonValue | null
    category: string | null
    postType: string
    wordCount: number | null
    readingTime: number | null
    affiliateLinks: JsonValue | null
    internalLinks: JsonValue | null
    externalLinks: JsonValue | null
    aiProvider: string | null
    generationCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AutoBlogPostCountAggregateOutputType | null
    _avg: AutoBlogPostAvgAggregateOutputType | null
    _sum: AutoBlogPostSumAggregateOutputType | null
    _min: AutoBlogPostMinAggregateOutputType | null
    _max: AutoBlogPostMaxAggregateOutputType | null
  }

  type GetAutoBlogPostGroupByPayload<T extends AutoBlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoBlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoBlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoBlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], AutoBlogPostGroupByOutputType[P]>
        }
      >
    >


  export type AutoBlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    keyTakeaways?: boolean
    featuredImage?: boolean
    status?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    seoData?: boolean
    tags?: boolean
    category?: boolean
    postType?: boolean
    wordCount?: boolean
    readingTime?: boolean
    affiliateLinks?: boolean
    internalLinks?: boolean
    externalLinks?: boolean
    aiProvider?: boolean
    generationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoBlogPost"]>

  export type AutoBlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    keyTakeaways?: boolean
    featuredImage?: boolean
    status?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    seoData?: boolean
    tags?: boolean
    category?: boolean
    postType?: boolean
    wordCount?: boolean
    readingTime?: boolean
    affiliateLinks?: boolean
    internalLinks?: boolean
    externalLinks?: boolean
    aiProvider?: boolean
    generationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoBlogPost"]>

  export type AutoBlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    keyTakeaways?: boolean
    featuredImage?: boolean
    status?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    seoData?: boolean
    tags?: boolean
    category?: boolean
    postType?: boolean
    wordCount?: boolean
    readingTime?: boolean
    affiliateLinks?: boolean
    internalLinks?: boolean
    externalLinks?: boolean
    aiProvider?: boolean
    generationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoBlogPost"]>

  export type AutoBlogPostSelectScalar = {
    id?: boolean
    siteId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    keyTakeaways?: boolean
    featuredImage?: boolean
    status?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    seoData?: boolean
    tags?: boolean
    category?: boolean
    postType?: boolean
    wordCount?: boolean
    readingTime?: boolean
    affiliateLinks?: boolean
    internalLinks?: boolean
    externalLinks?: boolean
    aiProvider?: boolean
    generationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutoBlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "title" | "content" | "summary" | "keyTakeaways" | "featuredImage" | "status" | "publishedAt" | "scheduledAt" | "seoData" | "tags" | "category" | "postType" | "wordCount" | "readingTime" | "affiliateLinks" | "internalLinks" | "externalLinks" | "aiProvider" | "generationCost" | "createdAt" | "updatedAt", ExtArgs["result"]["autoBlogPost"]>
  export type AutoBlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type AutoBlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type AutoBlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $AutoBlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoBlogPost"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: string
      title: string
      content: string
      summary: string | null
      keyTakeaways: Prisma.JsonValue | null
      featuredImage: string | null
      status: string
      publishedAt: Date | null
      scheduledAt: Date | null
      seoData: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      category: string | null
      postType: string
      wordCount: number | null
      readingTime: number | null
      affiliateLinks: Prisma.JsonValue | null
      internalLinks: Prisma.JsonValue | null
      externalLinks: Prisma.JsonValue | null
      aiProvider: string | null
      generationCost: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["autoBlogPost"]>
    composites: {}
  }

  type AutoBlogPostGetPayload<S extends boolean | null | undefined | AutoBlogPostDefaultArgs> = $Result.GetResult<Prisma.$AutoBlogPostPayload, S>

  type AutoBlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoBlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoBlogPostCountAggregateInputType | true
    }

  export interface AutoBlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoBlogPost'], meta: { name: 'AutoBlogPost' } }
    /**
     * Find zero or one AutoBlogPost that matches the filter.
     * @param {AutoBlogPostFindUniqueArgs} args - Arguments to find a AutoBlogPost
     * @example
     * // Get one AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoBlogPostFindUniqueArgs>(args: SelectSubset<T, AutoBlogPostFindUniqueArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoBlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoBlogPostFindUniqueOrThrowArgs} args - Arguments to find a AutoBlogPost
     * @example
     * // Get one AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoBlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoBlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoBlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostFindFirstArgs} args - Arguments to find a AutoBlogPost
     * @example
     * // Get one AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoBlogPostFindFirstArgs>(args?: SelectSubset<T, AutoBlogPostFindFirstArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoBlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostFindFirstOrThrowArgs} args - Arguments to find a AutoBlogPost
     * @example
     * // Get one AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoBlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoBlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoBlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoBlogPosts
     * const autoBlogPosts = await prisma.autoBlogPost.findMany()
     * 
     * // Get first 10 AutoBlogPosts
     * const autoBlogPosts = await prisma.autoBlogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoBlogPostWithIdOnly = await prisma.autoBlogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoBlogPostFindManyArgs>(args?: SelectSubset<T, AutoBlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoBlogPost.
     * @param {AutoBlogPostCreateArgs} args - Arguments to create a AutoBlogPost.
     * @example
     * // Create one AutoBlogPost
     * const AutoBlogPost = await prisma.autoBlogPost.create({
     *   data: {
     *     // ... data to create a AutoBlogPost
     *   }
     * })
     * 
     */
    create<T extends AutoBlogPostCreateArgs>(args: SelectSubset<T, AutoBlogPostCreateArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoBlogPosts.
     * @param {AutoBlogPostCreateManyArgs} args - Arguments to create many AutoBlogPosts.
     * @example
     * // Create many AutoBlogPosts
     * const autoBlogPost = await prisma.autoBlogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoBlogPostCreateManyArgs>(args?: SelectSubset<T, AutoBlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoBlogPosts and returns the data saved in the database.
     * @param {AutoBlogPostCreateManyAndReturnArgs} args - Arguments to create many AutoBlogPosts.
     * @example
     * // Create many AutoBlogPosts
     * const autoBlogPost = await prisma.autoBlogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoBlogPosts and only return the `id`
     * const autoBlogPostWithIdOnly = await prisma.autoBlogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoBlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoBlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutoBlogPost.
     * @param {AutoBlogPostDeleteArgs} args - Arguments to delete one AutoBlogPost.
     * @example
     * // Delete one AutoBlogPost
     * const AutoBlogPost = await prisma.autoBlogPost.delete({
     *   where: {
     *     // ... filter to delete one AutoBlogPost
     *   }
     * })
     * 
     */
    delete<T extends AutoBlogPostDeleteArgs>(args: SelectSubset<T, AutoBlogPostDeleteArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoBlogPost.
     * @param {AutoBlogPostUpdateArgs} args - Arguments to update one AutoBlogPost.
     * @example
     * // Update one AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoBlogPostUpdateArgs>(args: SelectSubset<T, AutoBlogPostUpdateArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoBlogPosts.
     * @param {AutoBlogPostDeleteManyArgs} args - Arguments to filter AutoBlogPosts to delete.
     * @example
     * // Delete a few AutoBlogPosts
     * const { count } = await prisma.autoBlogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoBlogPostDeleteManyArgs>(args?: SelectSubset<T, AutoBlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoBlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoBlogPosts
     * const autoBlogPost = await prisma.autoBlogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoBlogPostUpdateManyArgs>(args: SelectSubset<T, AutoBlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoBlogPosts and returns the data updated in the database.
     * @param {AutoBlogPostUpdateManyAndReturnArgs} args - Arguments to update many AutoBlogPosts.
     * @example
     * // Update many AutoBlogPosts
     * const autoBlogPost = await prisma.autoBlogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutoBlogPosts and only return the `id`
     * const autoBlogPostWithIdOnly = await prisma.autoBlogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutoBlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, AutoBlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutoBlogPost.
     * @param {AutoBlogPostUpsertArgs} args - Arguments to update or create a AutoBlogPost.
     * @example
     * // Update or create a AutoBlogPost
     * const autoBlogPost = await prisma.autoBlogPost.upsert({
     *   create: {
     *     // ... data to create a AutoBlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoBlogPost we want to update
     *   }
     * })
     */
    upsert<T extends AutoBlogPostUpsertArgs>(args: SelectSubset<T, AutoBlogPostUpsertArgs<ExtArgs>>): Prisma__AutoBlogPostClient<$Result.GetResult<Prisma.$AutoBlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutoBlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostCountArgs} args - Arguments to filter AutoBlogPosts to count.
     * @example
     * // Count the number of AutoBlogPosts
     * const count = await prisma.autoBlogPost.count({
     *   where: {
     *     // ... the filter for the AutoBlogPosts we want to count
     *   }
     * })
    **/
    count<T extends AutoBlogPostCountArgs>(
      args?: Subset<T, AutoBlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoBlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoBlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoBlogPostAggregateArgs>(args: Subset<T, AutoBlogPostAggregateArgs>): Prisma.PrismaPromise<GetAutoBlogPostAggregateType<T>>

    /**
     * Group by AutoBlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoBlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoBlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoBlogPostGroupByArgs['orderBy'] }
        : { orderBy?: AutoBlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoBlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoBlogPost model
   */
  readonly fields: AutoBlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoBlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoBlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoBlogPost model
   */
  interface AutoBlogPostFieldRefs {
    readonly id: FieldRef<"AutoBlogPost", 'String'>
    readonly siteId: FieldRef<"AutoBlogPost", 'String'>
    readonly title: FieldRef<"AutoBlogPost", 'String'>
    readonly content: FieldRef<"AutoBlogPost", 'String'>
    readonly summary: FieldRef<"AutoBlogPost", 'String'>
    readonly keyTakeaways: FieldRef<"AutoBlogPost", 'Json'>
    readonly featuredImage: FieldRef<"AutoBlogPost", 'String'>
    readonly status: FieldRef<"AutoBlogPost", 'String'>
    readonly publishedAt: FieldRef<"AutoBlogPost", 'DateTime'>
    readonly scheduledAt: FieldRef<"AutoBlogPost", 'DateTime'>
    readonly seoData: FieldRef<"AutoBlogPost", 'Json'>
    readonly tags: FieldRef<"AutoBlogPost", 'Json'>
    readonly category: FieldRef<"AutoBlogPost", 'String'>
    readonly postType: FieldRef<"AutoBlogPost", 'String'>
    readonly wordCount: FieldRef<"AutoBlogPost", 'Int'>
    readonly readingTime: FieldRef<"AutoBlogPost", 'Int'>
    readonly affiliateLinks: FieldRef<"AutoBlogPost", 'Json'>
    readonly internalLinks: FieldRef<"AutoBlogPost", 'Json'>
    readonly externalLinks: FieldRef<"AutoBlogPost", 'Json'>
    readonly aiProvider: FieldRef<"AutoBlogPost", 'String'>
    readonly generationCost: FieldRef<"AutoBlogPost", 'Decimal'>
    readonly createdAt: FieldRef<"AutoBlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"AutoBlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoBlogPost findUnique
   */
  export type AutoBlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which AutoBlogPost to fetch.
     */
    where: AutoBlogPostWhereUniqueInput
  }

  /**
   * AutoBlogPost findUniqueOrThrow
   */
  export type AutoBlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which AutoBlogPost to fetch.
     */
    where: AutoBlogPostWhereUniqueInput
  }

  /**
   * AutoBlogPost findFirst
   */
  export type AutoBlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which AutoBlogPost to fetch.
     */
    where?: AutoBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoBlogPosts to fetch.
     */
    orderBy?: AutoBlogPostOrderByWithRelationInput | AutoBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoBlogPosts.
     */
    cursor?: AutoBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoBlogPosts.
     */
    distinct?: AutoBlogPostScalarFieldEnum | AutoBlogPostScalarFieldEnum[]
  }

  /**
   * AutoBlogPost findFirstOrThrow
   */
  export type AutoBlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which AutoBlogPost to fetch.
     */
    where?: AutoBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoBlogPosts to fetch.
     */
    orderBy?: AutoBlogPostOrderByWithRelationInput | AutoBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoBlogPosts.
     */
    cursor?: AutoBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoBlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoBlogPosts.
     */
    distinct?: AutoBlogPostScalarFieldEnum | AutoBlogPostScalarFieldEnum[]
  }

  /**
   * AutoBlogPost findMany
   */
  export type AutoBlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter, which AutoBlogPosts to fetch.
     */
    where?: AutoBlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoBlogPosts to fetch.
     */
    orderBy?: AutoBlogPostOrderByWithRelationInput | AutoBlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoBlogPosts.
     */
    cursor?: AutoBlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoBlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoBlogPosts.
     */
    skip?: number
    distinct?: AutoBlogPostScalarFieldEnum | AutoBlogPostScalarFieldEnum[]
  }

  /**
   * AutoBlogPost create
   */
  export type AutoBlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoBlogPost.
     */
    data: XOR<AutoBlogPostCreateInput, AutoBlogPostUncheckedCreateInput>
  }

  /**
   * AutoBlogPost createMany
   */
  export type AutoBlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoBlogPosts.
     */
    data: AutoBlogPostCreateManyInput | AutoBlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoBlogPost createManyAndReturn
   */
  export type AutoBlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many AutoBlogPosts.
     */
    data: AutoBlogPostCreateManyInput | AutoBlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoBlogPost update
   */
  export type AutoBlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoBlogPost.
     */
    data: XOR<AutoBlogPostUpdateInput, AutoBlogPostUncheckedUpdateInput>
    /**
     * Choose, which AutoBlogPost to update.
     */
    where: AutoBlogPostWhereUniqueInput
  }

  /**
   * AutoBlogPost updateMany
   */
  export type AutoBlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoBlogPosts.
     */
    data: XOR<AutoBlogPostUpdateManyMutationInput, AutoBlogPostUncheckedUpdateManyInput>
    /**
     * Filter which AutoBlogPosts to update
     */
    where?: AutoBlogPostWhereInput
    /**
     * Limit how many AutoBlogPosts to update.
     */
    limit?: number
  }

  /**
   * AutoBlogPost updateManyAndReturn
   */
  export type AutoBlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * The data used to update AutoBlogPosts.
     */
    data: XOR<AutoBlogPostUpdateManyMutationInput, AutoBlogPostUncheckedUpdateManyInput>
    /**
     * Filter which AutoBlogPosts to update
     */
    where?: AutoBlogPostWhereInput
    /**
     * Limit how many AutoBlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoBlogPost upsert
   */
  export type AutoBlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoBlogPost to update in case it exists.
     */
    where: AutoBlogPostWhereUniqueInput
    /**
     * In case the AutoBlogPost found by the `where` argument doesn't exist, create a new AutoBlogPost with this data.
     */
    create: XOR<AutoBlogPostCreateInput, AutoBlogPostUncheckedCreateInput>
    /**
     * In case the AutoBlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoBlogPostUpdateInput, AutoBlogPostUncheckedUpdateInput>
  }

  /**
   * AutoBlogPost delete
   */
  export type AutoBlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
    /**
     * Filter which AutoBlogPost to delete.
     */
    where: AutoBlogPostWhereUniqueInput
  }

  /**
   * AutoBlogPost deleteMany
   */
  export type AutoBlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoBlogPosts to delete
     */
    where?: AutoBlogPostWhereInput
    /**
     * Limit how many AutoBlogPosts to delete.
     */
    limit?: number
  }

  /**
   * AutoBlogPost without action
   */
  export type AutoBlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoBlogPost
     */
    select?: AutoBlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoBlogPost
     */
    omit?: AutoBlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoBlogPostInclude<ExtArgs> | null
  }


  /**
   * Model ContentSchedule
   */

  export type AggregateContentSchedule = {
    _count: ContentScheduleCountAggregateOutputType | null
    _avg: ContentScheduleAvgAggregateOutputType | null
    _sum: ContentScheduleSumAggregateOutputType | null
    _min: ContentScheduleMinAggregateOutputType | null
    _max: ContentScheduleMaxAggregateOutputType | null
  }

  export type ContentScheduleAvgAggregateOutputType = {
    interval: number | null
  }

  export type ContentScheduleSumAggregateOutputType = {
    interval: number | null
  }

  export type ContentScheduleMinAggregateOutputType = {
    id: string | null
    siteId: string | null
    name: string | null
    description: string | null
    frequency: string | null
    interval: number | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentScheduleMaxAggregateOutputType = {
    id: string | null
    siteId: string | null
    name: string | null
    description: string | null
    frequency: string | null
    interval: number | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentScheduleCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    description: number
    frequency: number
    interval: number
    postTypes: number
    categories: number
    keywords: number
    isActive: number
    lastRunAt: number
    nextRunAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentScheduleAvgAggregateInputType = {
    interval?: true
  }

  export type ContentScheduleSumAggregateInputType = {
    interval?: true
  }

  export type ContentScheduleMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    frequency?: true
    interval?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentScheduleMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    frequency?: true
    interval?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentScheduleCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    frequency?: true
    interval?: true
    postTypes?: true
    categories?: true
    keywords?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSchedule to aggregate.
     */
    where?: ContentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSchedules to fetch.
     */
    orderBy?: ContentScheduleOrderByWithRelationInput | ContentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentSchedules
    **/
    _count?: true | ContentScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentScheduleMaxAggregateInputType
  }

  export type GetContentScheduleAggregateType<T extends ContentScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateContentSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentSchedule[P]>
      : GetScalarType<T[P], AggregateContentSchedule[P]>
  }




  export type ContentScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentScheduleWhereInput
    orderBy?: ContentScheduleOrderByWithAggregationInput | ContentScheduleOrderByWithAggregationInput[]
    by: ContentScheduleScalarFieldEnum[] | ContentScheduleScalarFieldEnum
    having?: ContentScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentScheduleCountAggregateInputType | true
    _avg?: ContentScheduleAvgAggregateInputType
    _sum?: ContentScheduleSumAggregateInputType
    _min?: ContentScheduleMinAggregateInputType
    _max?: ContentScheduleMaxAggregateInputType
  }

  export type ContentScheduleGroupByOutputType = {
    id: string
    siteId: string
    name: string
    description: string | null
    frequency: string
    interval: number
    postTypes: JsonValue
    categories: JsonValue
    keywords: JsonValue
    isActive: boolean
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ContentScheduleCountAggregateOutputType | null
    _avg: ContentScheduleAvgAggregateOutputType | null
    _sum: ContentScheduleSumAggregateOutputType | null
    _min: ContentScheduleMinAggregateOutputType | null
    _max: ContentScheduleMaxAggregateOutputType | null
  }

  type GetContentScheduleGroupByPayload<T extends ContentScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ContentScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ContentScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    interval?: boolean
    postTypes?: boolean
    categories?: boolean
    keywords?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSchedule"]>

  export type ContentScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    interval?: boolean
    postTypes?: boolean
    categories?: boolean
    keywords?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSchedule"]>

  export type ContentScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    interval?: boolean
    postTypes?: boolean
    categories?: boolean
    keywords?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSchedule"]>

  export type ContentScheduleSelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    interval?: boolean
    postTypes?: boolean
    categories?: boolean
    keywords?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "name" | "description" | "frequency" | "interval" | "postTypes" | "categories" | "keywords" | "isActive" | "lastRunAt" | "nextRunAt" | "createdAt" | "updatedAt", ExtArgs["result"]["contentSchedule"]>
  export type ContentScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type ContentScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type ContentScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $ContentSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentSchedule"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: string
      name: string
      description: string | null
      frequency: string
      interval: number
      postTypes: Prisma.JsonValue
      categories: Prisma.JsonValue
      keywords: Prisma.JsonValue
      isActive: boolean
      lastRunAt: Date | null
      nextRunAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["contentSchedule"]>
    composites: {}
  }

  type ContentScheduleGetPayload<S extends boolean | null | undefined | ContentScheduleDefaultArgs> = $Result.GetResult<Prisma.$ContentSchedulePayload, S>

  type ContentScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentScheduleCountAggregateInputType | true
    }

  export interface ContentScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentSchedule'], meta: { name: 'ContentSchedule' } }
    /**
     * Find zero or one ContentSchedule that matches the filter.
     * @param {ContentScheduleFindUniqueArgs} args - Arguments to find a ContentSchedule
     * @example
     * // Get one ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentScheduleFindUniqueArgs>(args: SelectSubset<T, ContentScheduleFindUniqueArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentScheduleFindUniqueOrThrowArgs} args - Arguments to find a ContentSchedule
     * @example
     * // Get one ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleFindFirstArgs} args - Arguments to find a ContentSchedule
     * @example
     * // Get one ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentScheduleFindFirstArgs>(args?: SelectSubset<T, ContentScheduleFindFirstArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleFindFirstOrThrowArgs} args - Arguments to find a ContentSchedule
     * @example
     * // Get one ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentSchedules
     * const contentSchedules = await prisma.contentSchedule.findMany()
     * 
     * // Get first 10 ContentSchedules
     * const contentSchedules = await prisma.contentSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentScheduleWithIdOnly = await prisma.contentSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentScheduleFindManyArgs>(args?: SelectSubset<T, ContentScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentSchedule.
     * @param {ContentScheduleCreateArgs} args - Arguments to create a ContentSchedule.
     * @example
     * // Create one ContentSchedule
     * const ContentSchedule = await prisma.contentSchedule.create({
     *   data: {
     *     // ... data to create a ContentSchedule
     *   }
     * })
     * 
     */
    create<T extends ContentScheduleCreateArgs>(args: SelectSubset<T, ContentScheduleCreateArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentSchedules.
     * @param {ContentScheduleCreateManyArgs} args - Arguments to create many ContentSchedules.
     * @example
     * // Create many ContentSchedules
     * const contentSchedule = await prisma.contentSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentScheduleCreateManyArgs>(args?: SelectSubset<T, ContentScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentSchedules and returns the data saved in the database.
     * @param {ContentScheduleCreateManyAndReturnArgs} args - Arguments to create many ContentSchedules.
     * @example
     * // Create many ContentSchedules
     * const contentSchedule = await prisma.contentSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentSchedules and only return the `id`
     * const contentScheduleWithIdOnly = await prisma.contentSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentSchedule.
     * @param {ContentScheduleDeleteArgs} args - Arguments to delete one ContentSchedule.
     * @example
     * // Delete one ContentSchedule
     * const ContentSchedule = await prisma.contentSchedule.delete({
     *   where: {
     *     // ... filter to delete one ContentSchedule
     *   }
     * })
     * 
     */
    delete<T extends ContentScheduleDeleteArgs>(args: SelectSubset<T, ContentScheduleDeleteArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentSchedule.
     * @param {ContentScheduleUpdateArgs} args - Arguments to update one ContentSchedule.
     * @example
     * // Update one ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentScheduleUpdateArgs>(args: SelectSubset<T, ContentScheduleUpdateArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentSchedules.
     * @param {ContentScheduleDeleteManyArgs} args - Arguments to filter ContentSchedules to delete.
     * @example
     * // Delete a few ContentSchedules
     * const { count } = await prisma.contentSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentScheduleDeleteManyArgs>(args?: SelectSubset<T, ContentScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentSchedules
     * const contentSchedule = await prisma.contentSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentScheduleUpdateManyArgs>(args: SelectSubset<T, ContentScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSchedules and returns the data updated in the database.
     * @param {ContentScheduleUpdateManyAndReturnArgs} args - Arguments to update many ContentSchedules.
     * @example
     * // Update many ContentSchedules
     * const contentSchedule = await prisma.contentSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentSchedules and only return the `id`
     * const contentScheduleWithIdOnly = await prisma.contentSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentSchedule.
     * @param {ContentScheduleUpsertArgs} args - Arguments to update or create a ContentSchedule.
     * @example
     * // Update or create a ContentSchedule
     * const contentSchedule = await prisma.contentSchedule.upsert({
     *   create: {
     *     // ... data to create a ContentSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ContentScheduleUpsertArgs>(args: SelectSubset<T, ContentScheduleUpsertArgs<ExtArgs>>): Prisma__ContentScheduleClient<$Result.GetResult<Prisma.$ContentSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleCountArgs} args - Arguments to filter ContentSchedules to count.
     * @example
     * // Count the number of ContentSchedules
     * const count = await prisma.contentSchedule.count({
     *   where: {
     *     // ... the filter for the ContentSchedules we want to count
     *   }
     * })
    **/
    count<T extends ContentScheduleCountArgs>(
      args?: Subset<T, ContentScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentScheduleAggregateArgs>(args: Subset<T, ContentScheduleAggregateArgs>): Prisma.PrismaPromise<GetContentScheduleAggregateType<T>>

    /**
     * Group by ContentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ContentScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentSchedule model
   */
  readonly fields: ContentScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentSchedule model
   */
  interface ContentScheduleFieldRefs {
    readonly id: FieldRef<"ContentSchedule", 'String'>
    readonly siteId: FieldRef<"ContentSchedule", 'String'>
    readonly name: FieldRef<"ContentSchedule", 'String'>
    readonly description: FieldRef<"ContentSchedule", 'String'>
    readonly frequency: FieldRef<"ContentSchedule", 'String'>
    readonly interval: FieldRef<"ContentSchedule", 'Int'>
    readonly postTypes: FieldRef<"ContentSchedule", 'Json'>
    readonly categories: FieldRef<"ContentSchedule", 'Json'>
    readonly keywords: FieldRef<"ContentSchedule", 'Json'>
    readonly isActive: FieldRef<"ContentSchedule", 'Boolean'>
    readonly lastRunAt: FieldRef<"ContentSchedule", 'DateTime'>
    readonly nextRunAt: FieldRef<"ContentSchedule", 'DateTime'>
    readonly createdAt: FieldRef<"ContentSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentSchedule findUnique
   */
  export type ContentScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ContentSchedule to fetch.
     */
    where: ContentScheduleWhereUniqueInput
  }

  /**
   * ContentSchedule findUniqueOrThrow
   */
  export type ContentScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ContentSchedule to fetch.
     */
    where: ContentScheduleWhereUniqueInput
  }

  /**
   * ContentSchedule findFirst
   */
  export type ContentScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ContentSchedule to fetch.
     */
    where?: ContentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSchedules to fetch.
     */
    orderBy?: ContentScheduleOrderByWithRelationInput | ContentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSchedules.
     */
    cursor?: ContentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSchedules.
     */
    distinct?: ContentScheduleScalarFieldEnum | ContentScheduleScalarFieldEnum[]
  }

  /**
   * ContentSchedule findFirstOrThrow
   */
  export type ContentScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ContentSchedule to fetch.
     */
    where?: ContentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSchedules to fetch.
     */
    orderBy?: ContentScheduleOrderByWithRelationInput | ContentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSchedules.
     */
    cursor?: ContentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSchedules.
     */
    distinct?: ContentScheduleScalarFieldEnum | ContentScheduleScalarFieldEnum[]
  }

  /**
   * ContentSchedule findMany
   */
  export type ContentScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ContentSchedules to fetch.
     */
    where?: ContentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSchedules to fetch.
     */
    orderBy?: ContentScheduleOrderByWithRelationInput | ContentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentSchedules.
     */
    cursor?: ContentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSchedules.
     */
    skip?: number
    distinct?: ContentScheduleScalarFieldEnum | ContentScheduleScalarFieldEnum[]
  }

  /**
   * ContentSchedule create
   */
  export type ContentScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentSchedule.
     */
    data: XOR<ContentScheduleCreateInput, ContentScheduleUncheckedCreateInput>
  }

  /**
   * ContentSchedule createMany
   */
  export type ContentScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentSchedules.
     */
    data: ContentScheduleCreateManyInput | ContentScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentSchedule createManyAndReturn
   */
  export type ContentScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many ContentSchedules.
     */
    data: ContentScheduleCreateManyInput | ContentScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSchedule update
   */
  export type ContentScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentSchedule.
     */
    data: XOR<ContentScheduleUpdateInput, ContentScheduleUncheckedUpdateInput>
    /**
     * Choose, which ContentSchedule to update.
     */
    where: ContentScheduleWhereUniqueInput
  }

  /**
   * ContentSchedule updateMany
   */
  export type ContentScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentSchedules.
     */
    data: XOR<ContentScheduleUpdateManyMutationInput, ContentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ContentSchedules to update
     */
    where?: ContentScheduleWhereInput
    /**
     * Limit how many ContentSchedules to update.
     */
    limit?: number
  }

  /**
   * ContentSchedule updateManyAndReturn
   */
  export type ContentScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * The data used to update ContentSchedules.
     */
    data: XOR<ContentScheduleUpdateManyMutationInput, ContentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ContentSchedules to update
     */
    where?: ContentScheduleWhereInput
    /**
     * Limit how many ContentSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSchedule upsert
   */
  export type ContentScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentSchedule to update in case it exists.
     */
    where: ContentScheduleWhereUniqueInput
    /**
     * In case the ContentSchedule found by the `where` argument doesn't exist, create a new ContentSchedule with this data.
     */
    create: XOR<ContentScheduleCreateInput, ContentScheduleUncheckedCreateInput>
    /**
     * In case the ContentSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentScheduleUpdateInput, ContentScheduleUncheckedUpdateInput>
  }

  /**
   * ContentSchedule delete
   */
  export type ContentScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
    /**
     * Filter which ContentSchedule to delete.
     */
    where: ContentScheduleWhereUniqueInput
  }

  /**
   * ContentSchedule deleteMany
   */
  export type ContentScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSchedules to delete
     */
    where?: ContentScheduleWhereInput
    /**
     * Limit how many ContentSchedules to delete.
     */
    limit?: number
  }

  /**
   * ContentSchedule without action
   */
  export type ContentScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSchedule
     */
    select?: ContentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSchedule
     */
    omit?: ContentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    siteId: string | null
    name: string | null
    description: string | null
    slug: string | null
    parentId: string | null
    displayOrder: number | null
    isActive: boolean | null
    seoTitle: string | null
    seoDescription: string | null
    seoKeywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    siteId: string | null
    name: string | null
    description: string | null
    slug: string | null
    parentId: string | null
    displayOrder: number | null
    isActive: boolean | null
    seoTitle: string | null
    seoDescription: string | null
    seoKeywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    description: number
    slug: number
    parentId: number
    displayOrder: number
    isActive: number
    seoTitle: number
    seoDescription: number
    seoKeywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ProductCategorySumAggregateInputType = {
    displayOrder?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    displayOrder?: true
    isActive?: true
    seoTitle?: true
    seoDescription?: true
    seoKeywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    displayOrder?: true
    isActive?: true
    seoTitle?: true
    seoDescription?: true
    seoKeywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    slug?: true
    parentId?: true
    displayOrder?: true
    isActive?: true
    seoTitle?: true
    seoDescription?: true
    seoKeywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    siteId: string
    name: string
    description: string | null
    slug: string
    parentId: string | null
    displayOrder: number
    isActive: boolean
    seoTitle: string | null
    seoDescription: string | null
    seoKeywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    displayOrder?: boolean
    isActive?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    displayOrder?: boolean
    isActive?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    displayOrder?: boolean
    isActive?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    parentId?: boolean
    displayOrder?: boolean
    isActive?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    seoKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "name" | "description" | "slug" | "parentId" | "displayOrder" | "isActive" | "seoTitle" | "seoDescription" | "seoKeywords" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      parent: Prisma.$ProductCategoryPayload<ExtArgs> | null
      children: Prisma.$ProductCategoryPayload<ExtArgs>[]
      site: Prisma.$SitePayload<ExtArgs>
      products: Prisma.$SiteProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: string
      name: string
      description: string | null
      slug: string
      parentId: string | null
      displayOrder: number
      isActive: boolean
      seoTitle: string | null
      seoDescription: string | null
      seoKeywords: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ProductCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$parentArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ProductCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly siteId: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly parentId: FieldRef<"ProductCategory", 'String'>
    readonly displayOrder: FieldRef<"ProductCategory", 'Int'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly seoTitle: FieldRef<"ProductCategory", 'String'>
    readonly seoDescription: FieldRef<"ProductCategory", 'String'>
    readonly seoKeywords: FieldRef<"ProductCategory", 'String'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.parent
   */
  export type ProductCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.children
   */
  export type ProductCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteProduct
     */
    select?: SiteProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteProduct
     */
    omit?: SiteProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteProductInclude<ExtArgs> | null
    where?: SiteProductWhereInput
    orderBy?: SiteProductOrderByWithRelationInput | SiteProductOrderByWithRelationInput[]
    cursor?: SiteProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteProductScalarFieldEnum | SiteProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ContentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    contentTypeId: 'contentTypeId',
    data: 'data',
    status: 'status',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    version: 'version',
    scheduledPublishAt: 'scheduledPublishAt'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ContentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    schema: 'schema',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentTypeScalarFieldEnum = (typeof ContentTypeScalarFieldEnum)[keyof typeof ContentTypeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ContentCategoryScalarFieldEnum: {
    contentId: 'contentId',
    categoryId: 'categoryId'
  };

  export type ContentCategoryScalarFieldEnum = (typeof ContentCategoryScalarFieldEnum)[keyof typeof ContentCategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ContentTagScalarFieldEnum: {
    contentId: 'contentId',
    tagId: 'tagId'
  };

  export type ContentTagScalarFieldEnum = (typeof ContentTagScalarFieldEnum)[keyof typeof ContentTagScalarFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    logoUrl: 'logoUrl',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    nicheType: 'nicheType',
    customNicheId: 'customNicheId',
    nicheKeywords: 'nicheKeywords',
    targetAudience: 'targetAudience',
    siteTitle: 'siteTitle',
    siteDescription: 'siteDescription',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    aboutTitle: 'aboutTitle',
    aboutDescription: 'aboutDescription',
    contactEmail: 'contactEmail',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    featuredPostsTitle: 'featuredPostsTitle',
    featuredPostsSubtitle: 'featuredPostsSubtitle',
    featuredProductsTitle: 'featuredProductsTitle',
    featuredProductsSubtitle: 'featuredProductsSubtitle',
    newsletterTitle: 'newsletterTitle',
    newsletterSubtitle: 'newsletterSubtitle',
    autoBlogEnabled: 'autoBlogEnabled',
    autoBlogFrequency: 'autoBlogFrequency',
    autoBlogPostTypes: 'autoBlogPostTypes',
    autoBlogCategories: 'autoBlogCategories',
    footerText: 'footerText',
    socialLinks: 'socialLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const SiteContentScalarFieldEnum: {
    siteId: 'siteId',
    contentId: 'contentId'
  };

  export type SiteContentScalarFieldEnum = (typeof SiteContentScalarFieldEnum)[keyof typeof SiteContentScalarFieldEnum]


  export const MediaAssetScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    altText: 'altText',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


  export const SiteMediaScalarFieldEnum: {
    siteId: 'siteId',
    contentId: 'contentId',
    mediaAssetId: 'mediaAssetId'
  };

  export type SiteMediaScalarFieldEnum = (typeof SiteMediaScalarFieldEnum)[keyof typeof SiteMediaScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    manufacturer: 'manufacturer',
    basePrice: 'basePrice',
    mainImageUrl: 'mainImageUrl',
    specifications: 'specifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SiteProductScalarFieldEnum: {
    siteId: 'siteId',
    productId: 'productId',
    price: 'price',
    discount: 'discount',
    inStock: 'inStock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId'
  };

  export type SiteProductScalarFieldEnum = (typeof SiteProductScalarFieldEnum)[keyof typeof SiteProductScalarFieldEnum]


  export const ProductCustomFieldScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    siteId: 'siteId',
    fieldName: 'fieldName',
    fieldType: 'fieldType',
    fieldValue: 'fieldValue',
    displayOrder: 'displayOrder',
    isRequired: 'isRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCustomFieldScalarFieldEnum = (typeof ProductCustomFieldScalarFieldEnum)[keyof typeof ProductCustomFieldScalarFieldEnum]


  export const ProductPriceHistoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    price: 'price',
    currency: 'currency',
    source: 'source',
    recordedAt: 'recordedAt'
  };

  export type ProductPriceHistoryScalarFieldEnum = (typeof ProductPriceHistoryScalarFieldEnum)[keyof typeof ProductPriceHistoryScalarFieldEnum]


  export const PriceAlertScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    productId: 'productId',
    alertType: 'alertType',
    threshold: 'threshold',
    isActive: 'isActive',
    createdAt: 'createdAt',
    triggeredAt: 'triggeredAt'
  };

  export type PriceAlertScalarFieldEnum = (typeof PriceAlertScalarFieldEnum)[keyof typeof PriceAlertScalarFieldEnum]


  export const InteractiveQuizScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    title: 'title',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InteractiveQuizScalarFieldEnum = (typeof InteractiveQuizScalarFieldEnum)[keyof typeof InteractiveQuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    question: 'question',
    questionType: 'questionType',
    order: 'order',
    isRequired: 'isRequired',
    createdAt: 'createdAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizQuestionOptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    optionText: 'optionText',
    optionValue: 'optionValue',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type QuizQuestionOptionScalarFieldEnum = (typeof QuizQuestionOptionScalarFieldEnum)[keyof typeof QuizQuestionOptionScalarFieldEnum]


  export const QuizResultScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    sessionId: 'sessionId',
    answers: 'answers',
    recommendations: 'recommendations',
    completedAt: 'completedAt'
  };

  export type QuizResultScalarFieldEnum = (typeof QuizResultScalarFieldEnum)[keyof typeof QuizResultScalarFieldEnum]


  export const QuizAnswerScalarFieldEnum: {
    id: 'id',
    resultId: 'resultId',
    questionId: 'questionId',
    answer: 'answer',
    createdAt: 'createdAt'
  };

  export type QuizAnswerScalarFieldEnum = (typeof QuizAnswerScalarFieldEnum)[keyof typeof QuizAnswerScalarFieldEnum]


  export const AffiliateLinkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalUrl: 'originalUrl',
    affiliateUrl: 'affiliateUrl',
    siteId: 'siteId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId',
    merchantId: 'merchantId',
    displayText: 'displayText',
    trackingId: 'trackingId',
    status: 'status',
    commissionInfo: 'commissionInfo',
    expirationDate: 'expirationDate'
  };

  export type AffiliateLinkScalarFieldEnum = (typeof AffiliateLinkScalarFieldEnum)[keyof typeof AffiliateLinkScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    website: 'website',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const LinkClickScalarFieldEnum: {
    id: 'id',
    affiliateLinkId: 'affiliateLinkId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referrer: 'referrer',
    clickedAt: 'clickedAt',
    conversionStatus: 'conversionStatus',
    conversionValue: 'conversionValue'
  };

  export type LinkClickScalarFieldEnum = (typeof LinkClickScalarFieldEnum)[keyof typeof LinkClickScalarFieldEnum]


  export const ConversionScalarFieldEnum: {
    id: 'id',
    affiliateLinkId: 'affiliateLinkId',
    orderId: 'orderId',
    orderValue: 'orderValue',
    commission: 'commission',
    currency: 'currency',
    conversionDate: 'conversionDate',
    status: 'status',
    notes: 'notes'
  };

  export type ConversionScalarFieldEnum = (typeof ConversionScalarFieldEnum)[keyof typeof ConversionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId',
    siteId: 'siteId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    tableName: 'tableName',
    recordId: 'recordId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NewsletterSubscriberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    isActive: 'isActive',
    subscribedAt: 'subscribedAt',
    unsubscribedAt: 'unsubscribedAt',
    preferences: 'preferences',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsletterSubscriberScalarFieldEnum = (typeof NewsletterSubscriberScalarFieldEnum)[keyof typeof NewsletterSubscriberScalarFieldEnum]


  export const NewsletterCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    content: 'content',
    status: 'status',
    sentAt: 'sentAt',
    sentCount: 'sentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsletterCampaignScalarFieldEnum = (typeof NewsletterCampaignScalarFieldEnum)[keyof typeof NewsletterCampaignScalarFieldEnum]


  export const NewsletterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsletterScalarFieldEnum = (typeof NewsletterScalarFieldEnum)[keyof typeof NewsletterScalarFieldEnum]


  export const SocialMediaAccountScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    username: 'username',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialMediaAccountScalarFieldEnum = (typeof SocialMediaAccountScalarFieldEnum)[keyof typeof SocialMediaAccountScalarFieldEnum]


  export const SocialMediaPostScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    content: 'content',
    mediaUrls: 'mediaUrls',
    status: 'status',
    scheduledAt: 'scheduledAt',
    publishedAt: 'publishedAt',
    engagement: 'engagement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialMediaPostScalarFieldEnum = (typeof SocialMediaPostScalarFieldEnum)[keyof typeof SocialMediaPostScalarFieldEnum]


  export const AffiliateProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    affiliateUrl: 'affiliateUrl',
    merchant: 'merchant',
    category: 'category',
    tags: 'tags',
    images: 'images',
    specifications: 'specifications',
    availability: 'availability',
    rating: 'rating',
    reviewCount: 'reviewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliateProductScalarFieldEnum = (typeof AffiliateProductScalarFieldEnum)[keyof typeof AffiliateProductScalarFieldEnum]


  export const AffiliateLinkClickScalarFieldEnum: {
    id: 'id',
    affiliateUrl: 'affiliateUrl',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referrer: 'referrer',
    clickedAt: 'clickedAt',
    conversionValue: 'conversionValue'
  };

  export type AffiliateLinkClickScalarFieldEnum = (typeof AffiliateLinkClickScalarFieldEnum)[keyof typeof AffiliateLinkClickScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    prepTime: 'prepTime',
    cookTime: 'cookTime',
    servings: 'servings',
    difficulty: 'difficulty',
    cuisine: 'cuisine',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeIngredientScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    name: 'name',
    amount: 'amount',
    unit: 'unit',
    notes: 'notes',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type RecipeIngredientScalarFieldEnum = (typeof RecipeIngredientScalarFieldEnum)[keyof typeof RecipeIngredientScalarFieldEnum]


  export const RecipeInstructionScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    stepNumber: 'stepNumber',
    instruction: 'instruction',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type RecipeInstructionScalarFieldEnum = (typeof RecipeInstructionScalarFieldEnum)[keyof typeof RecipeInstructionScalarFieldEnum]


  export const ContentVersionScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    version: 'version',
    data: 'data',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ContentVersionScalarFieldEnum = (typeof ContentVersionScalarFieldEnum)[keyof typeof ContentVersionScalarFieldEnum]


  export const RealTimeNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type RealTimeNotificationScalarFieldEnum = (typeof RealTimeNotificationScalarFieldEnum)[keyof typeof RealTimeNotificationScalarFieldEnum]


  export const AIContentLogScalarFieldEnum: {
    id: 'id',
    prompt: 'prompt',
    response: 'response',
    model: 'model',
    tokensUsed: 'tokensUsed',
    cost: 'cost',
    duration: 'duration',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type AIContentLogScalarFieldEnum = (typeof AIContentLogScalarFieldEnum)[keyof typeof AIContentLogScalarFieldEnum]


  export const BulkImportScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    status: 'status',
    totalRows: 'totalRows',
    processedRows: 'processedRows',
    errorRows: 'errorRows',
    errors: 'errors',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type BulkImportScalarFieldEnum = (typeof BulkImportScalarFieldEnum)[keyof typeof BulkImportScalarFieldEnum]


  export const MakeWebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    secret: 'secret',
    isActive: 'isActive',
    events: 'events',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MakeWebhookScalarFieldEnum = (typeof MakeWebhookScalarFieldEnum)[keyof typeof MakeWebhookScalarFieldEnum]


  export const CookieConsentScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    preferences: 'preferences',
    consentedAt: 'consentedAt'
  };

  export type CookieConsentScalarFieldEnum = (typeof CookieConsentScalarFieldEnum)[keyof typeof CookieConsentScalarFieldEnum]


  export const AdSpaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    adType: 'adType',
    isActive: 'isActive',
    adCode: 'adCode',
    dimensions: 'dimensions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdSpaceScalarFieldEnum = (typeof AdSpaceScalarFieldEnum)[keyof typeof AdSpaceScalarFieldEnum]


  export const CustomNicheScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    keywords: 'keywords',
    categories: 'categories',
    targetAudience: 'targetAudience',
    competitionLevel: 'competitionLevel',
    profitabilityScore: 'profitabilityScore',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomNicheScalarFieldEnum = (typeof CustomNicheScalarFieldEnum)[keyof typeof CustomNicheScalarFieldEnum]


  export const AutoBlogPostScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    title: 'title',
    content: 'content',
    summary: 'summary',
    keyTakeaways: 'keyTakeaways',
    featuredImage: 'featuredImage',
    status: 'status',
    publishedAt: 'publishedAt',
    scheduledAt: 'scheduledAt',
    seoData: 'seoData',
    tags: 'tags',
    category: 'category',
    postType: 'postType',
    wordCount: 'wordCount',
    readingTime: 'readingTime',
    affiliateLinks: 'affiliateLinks',
    internalLinks: 'internalLinks',
    externalLinks: 'externalLinks',
    aiProvider: 'aiProvider',
    generationCost: 'generationCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutoBlogPostScalarFieldEnum = (typeof AutoBlogPostScalarFieldEnum)[keyof typeof AutoBlogPostScalarFieldEnum]


  export const ContentScheduleScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    description: 'description',
    frequency: 'frequency',
    interval: 'interval',
    postTypes: 'postTypes',
    categories: 'categories',
    keywords: 'keywords',
    isActive: 'isActive',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentScheduleScalarFieldEnum = (typeof ContentScheduleScalarFieldEnum)[keyof typeof ContentScheduleScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    description: 'description',
    slug: 'slug',
    parentId: 'parentId',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription',
    seoKeywords: 'seoKeywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: UuidFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    slug?: StringFilter<"Content"> | string
    contentTypeId?: IntFilter<"Content"> | number
    data?: JsonFilter<"Content">
    status?: StringFilter<"Content"> | string
    createdBy?: UuidNullableFilter<"Content"> | string | null
    updatedBy?: UuidNullableFilter<"Content"> | string | null
    createdAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    version?: IntNullableFilter<"Content"> | number | null
    scheduledPublishAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    contentType?: XOR<ContentTypeScalarRelationFilter, ContentTypeWhereInput>
    categories?: ContentCategoryListRelationFilter
    tags?: ContentTagListRelationFilter
    versions?: ContentVersionListRelationFilter
    siteContent?: SiteContentListRelationFilter
    media?: SiteMediaListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    contentTypeId?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    scheduledPublishAt?: SortOrderInput | SortOrder
    contentType?: ContentTypeOrderByWithRelationInput
    categories?: ContentCategoryOrderByRelationAggregateInput
    tags?: ContentTagOrderByRelationAggregateInput
    versions?: ContentVersionOrderByRelationAggregateInput
    siteContent?: SiteContentOrderByRelationAggregateInput
    media?: SiteMediaOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    title?: StringFilter<"Content"> | string
    slug?: StringFilter<"Content"> | string
    contentTypeId?: IntFilter<"Content"> | number
    data?: JsonFilter<"Content">
    status?: StringFilter<"Content"> | string
    createdBy?: UuidNullableFilter<"Content"> | string | null
    updatedBy?: UuidNullableFilter<"Content"> | string | null
    createdAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    version?: IntNullableFilter<"Content"> | number | null
    scheduledPublishAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    contentType?: XOR<ContentTypeScalarRelationFilter, ContentTypeWhereInput>
    categories?: ContentCategoryListRelationFilter
    tags?: ContentTagListRelationFilter
    versions?: ContentVersionListRelationFilter
    siteContent?: SiteContentListRelationFilter
    media?: SiteMediaListRelationFilter
  }, "id">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    contentTypeId?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    scheduledPublishAt?: SortOrderInput | SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Content"> | string
    title?: StringWithAggregatesFilter<"Content"> | string
    slug?: StringWithAggregatesFilter<"Content"> | string
    contentTypeId?: IntWithAggregatesFilter<"Content"> | number
    data?: JsonWithAggregatesFilter<"Content">
    status?: StringWithAggregatesFilter<"Content"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"Content"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Content"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
    version?: IntNullableWithAggregatesFilter<"Content"> | number | null
    scheduledPublishAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
  }

  export type ContentTypeWhereInput = {
    AND?: ContentTypeWhereInput | ContentTypeWhereInput[]
    OR?: ContentTypeWhereInput[]
    NOT?: ContentTypeWhereInput | ContentTypeWhereInput[]
    id?: IntFilter<"ContentType"> | number
    name?: StringFilter<"ContentType"> | string
    description?: StringNullableFilter<"ContentType"> | string | null
    schema?: JsonNullableFilter<"ContentType">
    createdAt?: DateTimeNullableFilter<"ContentType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ContentType"> | Date | string | null
    content?: ContentListRelationFilter
  }

  export type ContentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schema?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: ContentOrderByRelationAggregateInput
  }

  export type ContentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentTypeWhereInput | ContentTypeWhereInput[]
    OR?: ContentTypeWhereInput[]
    NOT?: ContentTypeWhereInput | ContentTypeWhereInput[]
    name?: StringFilter<"ContentType"> | string
    description?: StringNullableFilter<"ContentType"> | string | null
    schema?: JsonNullableFilter<"ContentType">
    createdAt?: DateTimeNullableFilter<"ContentType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ContentType"> | Date | string | null
    content?: ContentListRelationFilter
  }, "id">

  export type ContentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schema?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ContentTypeCountOrderByAggregateInput
    _avg?: ContentTypeAvgOrderByAggregateInput
    _max?: ContentTypeMaxOrderByAggregateInput
    _min?: ContentTypeMinOrderByAggregateInput
    _sum?: ContentTypeSumOrderByAggregateInput
  }

  export type ContentTypeScalarWhereWithAggregatesInput = {
    AND?: ContentTypeScalarWhereWithAggregatesInput | ContentTypeScalarWhereWithAggregatesInput[]
    OR?: ContentTypeScalarWhereWithAggregatesInput[]
    NOT?: ContentTypeScalarWhereWithAggregatesInput | ContentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentType"> | number
    name?: StringWithAggregatesFilter<"ContentType"> | string
    description?: StringNullableWithAggregatesFilter<"ContentType"> | string | null
    schema?: JsonNullableWithAggregatesFilter<"ContentType">
    createdAt?: DateTimeNullableWithAggregatesFilter<"ContentType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ContentType"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    parentId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    content?: ContentCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    content?: ContentCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    parentId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    content?: ContentCategoryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    slug?: StringWithAggregatesFilter<"Category"> | string
    parentId?: IntNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type ContentCategoryWhereInput = {
    AND?: ContentCategoryWhereInput | ContentCategoryWhereInput[]
    OR?: ContentCategoryWhereInput[]
    NOT?: ContentCategoryWhereInput | ContentCategoryWhereInput[]
    contentId?: UuidFilter<"ContentCategory"> | string
    categoryId?: IntFilter<"ContentCategory"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }

  export type ContentCategoryOrderByWithRelationInput = {
    contentId?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    content?: ContentOrderByWithRelationInput
  }

  export type ContentCategoryWhereUniqueInput = Prisma.AtLeast<{
    contentId_categoryId?: ContentCategoryContentIdCategoryIdCompoundUniqueInput
    AND?: ContentCategoryWhereInput | ContentCategoryWhereInput[]
    OR?: ContentCategoryWhereInput[]
    NOT?: ContentCategoryWhereInput | ContentCategoryWhereInput[]
    contentId?: UuidFilter<"ContentCategory"> | string
    categoryId?: IntFilter<"ContentCategory"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }, "contentId_categoryId">

  export type ContentCategoryOrderByWithAggregationInput = {
    contentId?: SortOrder
    categoryId?: SortOrder
    _count?: ContentCategoryCountOrderByAggregateInput
    _avg?: ContentCategoryAvgOrderByAggregateInput
    _max?: ContentCategoryMaxOrderByAggregateInput
    _min?: ContentCategoryMinOrderByAggregateInput
    _sum?: ContentCategorySumOrderByAggregateInput
  }

  export type ContentCategoryScalarWhereWithAggregatesInput = {
    AND?: ContentCategoryScalarWhereWithAggregatesInput | ContentCategoryScalarWhereWithAggregatesInput[]
    OR?: ContentCategoryScalarWhereWithAggregatesInput[]
    NOT?: ContentCategoryScalarWhereWithAggregatesInput | ContentCategoryScalarWhereWithAggregatesInput[]
    contentId?: UuidWithAggregatesFilter<"ContentCategory"> | string
    categoryId?: IntWithAggregatesFilter<"ContentCategory"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    slug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    content?: ContentTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: ContentTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    slug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    content?: ContentTagListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    slug?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
  }

  export type ContentTagWhereInput = {
    AND?: ContentTagWhereInput | ContentTagWhereInput[]
    OR?: ContentTagWhereInput[]
    NOT?: ContentTagWhereInput | ContentTagWhereInput[]
    contentId?: UuidFilter<"ContentTag"> | string
    tagId?: IntFilter<"ContentTag"> | number
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ContentTagOrderByWithRelationInput = {
    contentId?: SortOrder
    tagId?: SortOrder
    content?: ContentOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ContentTagWhereUniqueInput = Prisma.AtLeast<{
    contentId_tagId?: ContentTagContentIdTagIdCompoundUniqueInput
    AND?: ContentTagWhereInput | ContentTagWhereInput[]
    OR?: ContentTagWhereInput[]
    NOT?: ContentTagWhereInput | ContentTagWhereInput[]
    contentId?: UuidFilter<"ContentTag"> | string
    tagId?: IntFilter<"ContentTag"> | number
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "contentId_tagId">

  export type ContentTagOrderByWithAggregationInput = {
    contentId?: SortOrder
    tagId?: SortOrder
    _count?: ContentTagCountOrderByAggregateInput
    _avg?: ContentTagAvgOrderByAggregateInput
    _max?: ContentTagMaxOrderByAggregateInput
    _min?: ContentTagMinOrderByAggregateInput
    _sum?: ContentTagSumOrderByAggregateInput
  }

  export type ContentTagScalarWhereWithAggregatesInput = {
    AND?: ContentTagScalarWhereWithAggregatesInput | ContentTagScalarWhereWithAggregatesInput[]
    OR?: ContentTagScalarWhereWithAggregatesInput[]
    NOT?: ContentTagScalarWhereWithAggregatesInput | ContentTagScalarWhereWithAggregatesInput[]
    contentId?: UuidWithAggregatesFilter<"ContentTag"> | string
    tagId?: IntWithAggregatesFilter<"ContentTag"> | number
  }

  export type SiteWhereInput = {
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    id?: UuidFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    domain?: StringFilter<"Site"> | string
    logoUrl?: StringNullableFilter<"Site"> | string | null
    primaryColor?: StringNullableFilter<"Site"> | string | null
    secondaryColor?: StringNullableFilter<"Site"> | string | null
    nicheType?: StringFilter<"Site"> | string
    customNicheId?: UuidNullableFilter<"Site"> | string | null
    nicheKeywords?: JsonNullableFilter<"Site">
    targetAudience?: StringNullableFilter<"Site"> | string | null
    siteTitle?: StringNullableFilter<"Site"> | string | null
    siteDescription?: StringNullableFilter<"Site"> | string | null
    heroTitle?: StringNullableFilter<"Site"> | string | null
    heroSubtitle?: StringNullableFilter<"Site"> | string | null
    aboutTitle?: StringNullableFilter<"Site"> | string | null
    aboutDescription?: StringNullableFilter<"Site"> | string | null
    contactEmail?: StringNullableFilter<"Site"> | string | null
    metaTitle?: StringNullableFilter<"Site"> | string | null
    metaDescription?: StringNullableFilter<"Site"> | string | null
    metaKeywords?: StringNullableFilter<"Site"> | string | null
    featuredPostsTitle?: StringNullableFilter<"Site"> | string | null
    featuredPostsSubtitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsTitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsSubtitle?: StringNullableFilter<"Site"> | string | null
    newsletterTitle?: StringNullableFilter<"Site"> | string | null
    newsletterSubtitle?: StringNullableFilter<"Site"> | string | null
    autoBlogEnabled?: BoolFilter<"Site"> | boolean
    autoBlogFrequency?: StringNullableFilter<"Site"> | string | null
    autoBlogPostTypes?: JsonNullableFilter<"Site">
    autoBlogCategories?: JsonNullableFilter<"Site">
    footerText?: StringNullableFilter<"Site"> | string | null
    socialLinks?: JsonNullableFilter<"Site">
    createdAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
    autoBlogPosts?: AutoBlogPostListRelationFilter
    contentSchedules?: ContentScheduleListRelationFilter
    quizzes?: InteractiveQuizListRelationFilter
    priceAlerts?: PriceAlertListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    customFields?: ProductCustomFieldListRelationFilter
    content?: SiteContentListRelationFilter
    media?: SiteMediaListRelationFilter
    products?: SiteProductListRelationFilter
    customNiche?: XOR<CustomNicheNullableScalarRelationFilter, CustomNicheWhereInput> | null
  }

  export type SiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    nicheType?: SortOrder
    customNicheId?: SortOrderInput | SortOrder
    nicheKeywords?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    siteTitle?: SortOrderInput | SortOrder
    siteDescription?: SortOrderInput | SortOrder
    heroTitle?: SortOrderInput | SortOrder
    heroSubtitle?: SortOrderInput | SortOrder
    aboutTitle?: SortOrderInput | SortOrder
    aboutDescription?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    featuredPostsTitle?: SortOrderInput | SortOrder
    featuredPostsSubtitle?: SortOrderInput | SortOrder
    featuredProductsTitle?: SortOrderInput | SortOrder
    featuredProductsSubtitle?: SortOrderInput | SortOrder
    newsletterTitle?: SortOrderInput | SortOrder
    newsletterSubtitle?: SortOrderInput | SortOrder
    autoBlogEnabled?: SortOrder
    autoBlogFrequency?: SortOrderInput | SortOrder
    autoBlogPostTypes?: SortOrderInput | SortOrder
    autoBlogCategories?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    affiliateLinks?: AffiliateLinkOrderByRelationAggregateInput
    autoBlogPosts?: AutoBlogPostOrderByRelationAggregateInput
    contentSchedules?: ContentScheduleOrderByRelationAggregateInput
    quizzes?: InteractiveQuizOrderByRelationAggregateInput
    priceAlerts?: PriceAlertOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    customFields?: ProductCustomFieldOrderByRelationAggregateInput
    content?: SiteContentOrderByRelationAggregateInput
    media?: SiteMediaOrderByRelationAggregateInput
    products?: SiteProductOrderByRelationAggregateInput
    customNiche?: CustomNicheOrderByWithRelationInput
  }

  export type SiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    name?: StringFilter<"Site"> | string
    domain?: StringFilter<"Site"> | string
    logoUrl?: StringNullableFilter<"Site"> | string | null
    primaryColor?: StringNullableFilter<"Site"> | string | null
    secondaryColor?: StringNullableFilter<"Site"> | string | null
    nicheType?: StringFilter<"Site"> | string
    customNicheId?: UuidNullableFilter<"Site"> | string | null
    nicheKeywords?: JsonNullableFilter<"Site">
    targetAudience?: StringNullableFilter<"Site"> | string | null
    siteTitle?: StringNullableFilter<"Site"> | string | null
    siteDescription?: StringNullableFilter<"Site"> | string | null
    heroTitle?: StringNullableFilter<"Site"> | string | null
    heroSubtitle?: StringNullableFilter<"Site"> | string | null
    aboutTitle?: StringNullableFilter<"Site"> | string | null
    aboutDescription?: StringNullableFilter<"Site"> | string | null
    contactEmail?: StringNullableFilter<"Site"> | string | null
    metaTitle?: StringNullableFilter<"Site"> | string | null
    metaDescription?: StringNullableFilter<"Site"> | string | null
    metaKeywords?: StringNullableFilter<"Site"> | string | null
    featuredPostsTitle?: StringNullableFilter<"Site"> | string | null
    featuredPostsSubtitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsTitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsSubtitle?: StringNullableFilter<"Site"> | string | null
    newsletterTitle?: StringNullableFilter<"Site"> | string | null
    newsletterSubtitle?: StringNullableFilter<"Site"> | string | null
    autoBlogEnabled?: BoolFilter<"Site"> | boolean
    autoBlogFrequency?: StringNullableFilter<"Site"> | string | null
    autoBlogPostTypes?: JsonNullableFilter<"Site">
    autoBlogCategories?: JsonNullableFilter<"Site">
    footerText?: StringNullableFilter<"Site"> | string | null
    socialLinks?: JsonNullableFilter<"Site">
    createdAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
    autoBlogPosts?: AutoBlogPostListRelationFilter
    contentSchedules?: ContentScheduleListRelationFilter
    quizzes?: InteractiveQuizListRelationFilter
    priceAlerts?: PriceAlertListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    customFields?: ProductCustomFieldListRelationFilter
    content?: SiteContentListRelationFilter
    media?: SiteMediaListRelationFilter
    products?: SiteProductListRelationFilter
    customNiche?: XOR<CustomNicheNullableScalarRelationFilter, CustomNicheWhereInput> | null
  }, "id">

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    nicheType?: SortOrder
    customNicheId?: SortOrderInput | SortOrder
    nicheKeywords?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    siteTitle?: SortOrderInput | SortOrder
    siteDescription?: SortOrderInput | SortOrder
    heroTitle?: SortOrderInput | SortOrder
    heroSubtitle?: SortOrderInput | SortOrder
    aboutTitle?: SortOrderInput | SortOrder
    aboutDescription?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    featuredPostsTitle?: SortOrderInput | SortOrder
    featuredPostsSubtitle?: SortOrderInput | SortOrder
    featuredProductsTitle?: SortOrderInput | SortOrder
    featuredProductsSubtitle?: SortOrderInput | SortOrder
    newsletterTitle?: SortOrderInput | SortOrder
    newsletterSubtitle?: SortOrderInput | SortOrder
    autoBlogEnabled?: SortOrder
    autoBlogFrequency?: SortOrderInput | SortOrder
    autoBlogPostTypes?: SortOrderInput | SortOrder
    autoBlogCategories?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SiteCountOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    OR?: SiteScalarWhereWithAggregatesInput[]
    NOT?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Site"> | string
    name?: StringWithAggregatesFilter<"Site"> | string
    domain?: StringWithAggregatesFilter<"Site"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Site"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Site"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Site"> | string | null
    nicheType?: StringWithAggregatesFilter<"Site"> | string
    customNicheId?: UuidNullableWithAggregatesFilter<"Site"> | string | null
    nicheKeywords?: JsonNullableWithAggregatesFilter<"Site">
    targetAudience?: StringNullableWithAggregatesFilter<"Site"> | string | null
    siteTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    siteDescription?: StringNullableWithAggregatesFilter<"Site"> | string | null
    heroTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    heroSubtitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    aboutTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    aboutDescription?: StringNullableWithAggregatesFilter<"Site"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Site"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Site"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Site"> | string | null
    featuredPostsTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    featuredPostsSubtitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    featuredProductsTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    featuredProductsSubtitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    newsletterTitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    newsletterSubtitle?: StringNullableWithAggregatesFilter<"Site"> | string | null
    autoBlogEnabled?: BoolWithAggregatesFilter<"Site"> | boolean
    autoBlogFrequency?: StringNullableWithAggregatesFilter<"Site"> | string | null
    autoBlogPostTypes?: JsonNullableWithAggregatesFilter<"Site">
    autoBlogCategories?: JsonNullableWithAggregatesFilter<"Site">
    footerText?: StringNullableWithAggregatesFilter<"Site"> | string | null
    socialLinks?: JsonNullableWithAggregatesFilter<"Site">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Site"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Site"> | Date | string | null
  }

  export type SiteContentWhereInput = {
    AND?: SiteContentWhereInput | SiteContentWhereInput[]
    OR?: SiteContentWhereInput[]
    NOT?: SiteContentWhereInput | SiteContentWhereInput[]
    siteId?: UuidFilter<"SiteContent"> | string
    contentId?: UuidFilter<"SiteContent"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type SiteContentOrderByWithRelationInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    content?: ContentOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type SiteContentWhereUniqueInput = Prisma.AtLeast<{
    siteId_contentId?: SiteContentSiteIdContentIdCompoundUniqueInput
    AND?: SiteContentWhereInput | SiteContentWhereInput[]
    OR?: SiteContentWhereInput[]
    NOT?: SiteContentWhereInput | SiteContentWhereInput[]
    siteId?: UuidFilter<"SiteContent"> | string
    contentId?: UuidFilter<"SiteContent"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "siteId_contentId">

  export type SiteContentOrderByWithAggregationInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    _count?: SiteContentCountOrderByAggregateInput
    _max?: SiteContentMaxOrderByAggregateInput
    _min?: SiteContentMinOrderByAggregateInput
  }

  export type SiteContentScalarWhereWithAggregatesInput = {
    AND?: SiteContentScalarWhereWithAggregatesInput | SiteContentScalarWhereWithAggregatesInput[]
    OR?: SiteContentScalarWhereWithAggregatesInput[]
    NOT?: SiteContentScalarWhereWithAggregatesInput | SiteContentScalarWhereWithAggregatesInput[]
    siteId?: UuidWithAggregatesFilter<"SiteContent"> | string
    contentId?: UuidWithAggregatesFilter<"SiteContent"> | string
  }

  export type MediaAssetWhereInput = {
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    id?: UuidFilter<"MediaAsset"> | string
    filename?: StringFilter<"MediaAsset"> | string
    originalName?: StringFilter<"MediaAsset"> | string
    mimeType?: StringFilter<"MediaAsset"> | string
    size?: IntFilter<"MediaAsset"> | number
    url?: StringFilter<"MediaAsset"> | string
    altText?: StringNullableFilter<"MediaAsset"> | string | null
    metadata?: JsonNullableFilter<"MediaAsset">
    createdAt?: DateTimeNullableFilter<"MediaAsset"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MediaAsset"> | Date | string | null
    siteMedia?: SiteMediaListRelationFilter
  }

  export type MediaAssetOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    siteMedia?: SiteMediaOrderByRelationAggregateInput
  }

  export type MediaAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    filename?: StringFilter<"MediaAsset"> | string
    originalName?: StringFilter<"MediaAsset"> | string
    mimeType?: StringFilter<"MediaAsset"> | string
    size?: IntFilter<"MediaAsset"> | number
    url?: StringFilter<"MediaAsset"> | string
    altText?: StringNullableFilter<"MediaAsset"> | string | null
    metadata?: JsonNullableFilter<"MediaAsset">
    createdAt?: DateTimeNullableFilter<"MediaAsset"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MediaAsset"> | Date | string | null
    siteMedia?: SiteMediaListRelationFilter
  }, "id">

  export type MediaAssetOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MediaAssetCountOrderByAggregateInput
    _avg?: MediaAssetAvgOrderByAggregateInput
    _max?: MediaAssetMaxOrderByAggregateInput
    _min?: MediaAssetMinOrderByAggregateInput
    _sum?: MediaAssetSumOrderByAggregateInput
  }

  export type MediaAssetScalarWhereWithAggregatesInput = {
    AND?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    OR?: MediaAssetScalarWhereWithAggregatesInput[]
    NOT?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaAsset"> | string
    filename?: StringWithAggregatesFilter<"MediaAsset"> | string
    originalName?: StringWithAggregatesFilter<"MediaAsset"> | string
    mimeType?: StringWithAggregatesFilter<"MediaAsset"> | string
    size?: IntWithAggregatesFilter<"MediaAsset"> | number
    url?: StringWithAggregatesFilter<"MediaAsset"> | string
    altText?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"MediaAsset">
    createdAt?: DateTimeNullableWithAggregatesFilter<"MediaAsset"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MediaAsset"> | Date | string | null
  }

  export type SiteMediaWhereInput = {
    AND?: SiteMediaWhereInput | SiteMediaWhereInput[]
    OR?: SiteMediaWhereInput[]
    NOT?: SiteMediaWhereInput | SiteMediaWhereInput[]
    siteId?: UuidFilter<"SiteMedia"> | string
    contentId?: UuidFilter<"SiteMedia"> | string
    mediaAssetId?: UuidFilter<"SiteMedia"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    mediaAsset?: XOR<MediaAssetScalarRelationFilter, MediaAssetWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type SiteMediaOrderByWithRelationInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    mediaAssetId?: SortOrder
    content?: ContentOrderByWithRelationInput
    mediaAsset?: MediaAssetOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type SiteMediaWhereUniqueInput = Prisma.AtLeast<{
    siteId_contentId_mediaAssetId?: SiteMediaSiteIdContentIdMediaAssetIdCompoundUniqueInput
    AND?: SiteMediaWhereInput | SiteMediaWhereInput[]
    OR?: SiteMediaWhereInput[]
    NOT?: SiteMediaWhereInput | SiteMediaWhereInput[]
    siteId?: UuidFilter<"SiteMedia"> | string
    contentId?: UuidFilter<"SiteMedia"> | string
    mediaAssetId?: UuidFilter<"SiteMedia"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    mediaAsset?: XOR<MediaAssetScalarRelationFilter, MediaAssetWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "siteId_contentId_mediaAssetId">

  export type SiteMediaOrderByWithAggregationInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    mediaAssetId?: SortOrder
    _count?: SiteMediaCountOrderByAggregateInput
    _max?: SiteMediaMaxOrderByAggregateInput
    _min?: SiteMediaMinOrderByAggregateInput
  }

  export type SiteMediaScalarWhereWithAggregatesInput = {
    AND?: SiteMediaScalarWhereWithAggregatesInput | SiteMediaScalarWhereWithAggregatesInput[]
    OR?: SiteMediaScalarWhereWithAggregatesInput[]
    NOT?: SiteMediaScalarWhereWithAggregatesInput | SiteMediaScalarWhereWithAggregatesInput[]
    siteId?: UuidWithAggregatesFilter<"SiteMedia"> | string
    contentId?: UuidWithAggregatesFilter<"SiteMedia"> | string
    mediaAssetId?: UuidWithAggregatesFilter<"SiteMedia"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    basePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    mainImageUrl?: StringNullableFilter<"Product"> | string | null
    specifications?: JsonNullableFilter<"Product">
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
    customFields?: ProductCustomFieldListRelationFilter
    priceHistory?: ProductPriceHistoryListRelationFilter
    siteProducts?: SiteProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    affiliateLinks?: AffiliateLinkOrderByRelationAggregateInput
    customFields?: ProductCustomFieldOrderByRelationAggregateInput
    priceHistory?: ProductPriceHistoryOrderByRelationAggregateInput
    siteProducts?: SiteProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    basePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    mainImageUrl?: StringNullableFilter<"Product"> | string | null
    specifications?: JsonNullableFilter<"Product">
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
    customFields?: ProductCustomFieldListRelationFilter
    priceHistory?: ProductPriceHistoryListRelationFilter
    siteProducts?: SiteProductListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Product"> | string | null
    basePrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    mainImageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    specifications?: JsonNullableWithAggregatesFilter<"Product">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type SiteProductWhereInput = {
    AND?: SiteProductWhereInput | SiteProductWhereInput[]
    OR?: SiteProductWhereInput[]
    NOT?: SiteProductWhereInput | SiteProductWhereInput[]
    siteId?: UuidFilter<"SiteProduct"> | string
    productId?: UuidFilter<"SiteProduct"> | string
    price?: DecimalFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFilter<"SiteProduct"> | boolean
    createdAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    categoryId?: UuidNullableFilter<"SiteProduct"> | string | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type SiteProductOrderByWithRelationInput = {
    siteId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    discount?: SortOrderInput | SortOrder
    inStock?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    category?: ProductCategoryOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type SiteProductWhereUniqueInput = Prisma.AtLeast<{
    siteId_productId?: SiteProductSiteIdProductIdCompoundUniqueInput
    AND?: SiteProductWhereInput | SiteProductWhereInput[]
    OR?: SiteProductWhereInput[]
    NOT?: SiteProductWhereInput | SiteProductWhereInput[]
    siteId?: UuidFilter<"SiteProduct"> | string
    productId?: UuidFilter<"SiteProduct"> | string
    price?: DecimalFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFilter<"SiteProduct"> | boolean
    createdAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    categoryId?: UuidNullableFilter<"SiteProduct"> | string | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "siteId_productId">

  export type SiteProductOrderByWithAggregationInput = {
    siteId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    discount?: SortOrderInput | SortOrder
    inStock?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: SiteProductCountOrderByAggregateInput
    _avg?: SiteProductAvgOrderByAggregateInput
    _max?: SiteProductMaxOrderByAggregateInput
    _min?: SiteProductMinOrderByAggregateInput
    _sum?: SiteProductSumOrderByAggregateInput
  }

  export type SiteProductScalarWhereWithAggregatesInput = {
    AND?: SiteProductScalarWhereWithAggregatesInput | SiteProductScalarWhereWithAggregatesInput[]
    OR?: SiteProductScalarWhereWithAggregatesInput[]
    NOT?: SiteProductScalarWhereWithAggregatesInput | SiteProductScalarWhereWithAggregatesInput[]
    siteId?: UuidWithAggregatesFilter<"SiteProduct"> | string
    productId?: UuidWithAggregatesFilter<"SiteProduct"> | string
    price?: DecimalWithAggregatesFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableWithAggregatesFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolWithAggregatesFilter<"SiteProduct"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"SiteProduct"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SiteProduct"> | Date | string | null
    categoryId?: UuidNullableWithAggregatesFilter<"SiteProduct"> | string | null
  }

  export type ProductCustomFieldWhereInput = {
    AND?: ProductCustomFieldWhereInput | ProductCustomFieldWhereInput[]
    OR?: ProductCustomFieldWhereInput[]
    NOT?: ProductCustomFieldWhereInput | ProductCustomFieldWhereInput[]
    id?: UuidFilter<"ProductCustomField"> | string
    productId?: UuidFilter<"ProductCustomField"> | string
    siteId?: UuidFilter<"ProductCustomField"> | string
    fieldName?: StringFilter<"ProductCustomField"> | string
    fieldType?: StringFilter<"ProductCustomField"> | string
    fieldValue?: StringFilter<"ProductCustomField"> | string
    displayOrder?: IntFilter<"ProductCustomField"> | number
    isRequired?: BoolFilter<"ProductCustomField"> | boolean
    createdAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type ProductCustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    siteId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    displayOrder?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type ProductCustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCustomFieldWhereInput | ProductCustomFieldWhereInput[]
    OR?: ProductCustomFieldWhereInput[]
    NOT?: ProductCustomFieldWhereInput | ProductCustomFieldWhereInput[]
    productId?: UuidFilter<"ProductCustomField"> | string
    siteId?: UuidFilter<"ProductCustomField"> | string
    fieldName?: StringFilter<"ProductCustomField"> | string
    fieldType?: StringFilter<"ProductCustomField"> | string
    fieldValue?: StringFilter<"ProductCustomField"> | string
    displayOrder?: IntFilter<"ProductCustomField"> | number
    isRequired?: BoolFilter<"ProductCustomField"> | boolean
    createdAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type ProductCustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    siteId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    displayOrder?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductCustomFieldCountOrderByAggregateInput
    _avg?: ProductCustomFieldAvgOrderByAggregateInput
    _max?: ProductCustomFieldMaxOrderByAggregateInput
    _min?: ProductCustomFieldMinOrderByAggregateInput
    _sum?: ProductCustomFieldSumOrderByAggregateInput
  }

  export type ProductCustomFieldScalarWhereWithAggregatesInput = {
    AND?: ProductCustomFieldScalarWhereWithAggregatesInput | ProductCustomFieldScalarWhereWithAggregatesInput[]
    OR?: ProductCustomFieldScalarWhereWithAggregatesInput[]
    NOT?: ProductCustomFieldScalarWhereWithAggregatesInput | ProductCustomFieldScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductCustomField"> | string
    productId?: UuidWithAggregatesFilter<"ProductCustomField"> | string
    siteId?: UuidWithAggregatesFilter<"ProductCustomField"> | string
    fieldName?: StringWithAggregatesFilter<"ProductCustomField"> | string
    fieldType?: StringWithAggregatesFilter<"ProductCustomField"> | string
    fieldValue?: StringWithAggregatesFilter<"ProductCustomField"> | string
    displayOrder?: IntWithAggregatesFilter<"ProductCustomField"> | number
    isRequired?: BoolWithAggregatesFilter<"ProductCustomField"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"ProductCustomField"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductCustomField"> | Date | string | null
  }

  export type ProductPriceHistoryWhereInput = {
    AND?: ProductPriceHistoryWhereInput | ProductPriceHistoryWhereInput[]
    OR?: ProductPriceHistoryWhereInput[]
    NOT?: ProductPriceHistoryWhereInput | ProductPriceHistoryWhereInput[]
    id?: UuidFilter<"ProductPriceHistory"> | string
    productId?: UuidFilter<"ProductPriceHistory"> | string
    price?: DecimalFilter<"ProductPriceHistory"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ProductPriceHistory"> | string
    source?: StringFilter<"ProductPriceHistory"> | string
    recordedAt?: DateTimeNullableFilter<"ProductPriceHistory"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductPriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    recordedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductPriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductPriceHistoryWhereInput | ProductPriceHistoryWhereInput[]
    OR?: ProductPriceHistoryWhereInput[]
    NOT?: ProductPriceHistoryWhereInput | ProductPriceHistoryWhereInput[]
    productId?: UuidFilter<"ProductPriceHistory"> | string
    price?: DecimalFilter<"ProductPriceHistory"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ProductPriceHistory"> | string
    source?: StringFilter<"ProductPriceHistory"> | string
    recordedAt?: DateTimeNullableFilter<"ProductPriceHistory"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductPriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    recordedAt?: SortOrderInput | SortOrder
    _count?: ProductPriceHistoryCountOrderByAggregateInput
    _avg?: ProductPriceHistoryAvgOrderByAggregateInput
    _max?: ProductPriceHistoryMaxOrderByAggregateInput
    _min?: ProductPriceHistoryMinOrderByAggregateInput
    _sum?: ProductPriceHistorySumOrderByAggregateInput
  }

  export type ProductPriceHistoryScalarWhereWithAggregatesInput = {
    AND?: ProductPriceHistoryScalarWhereWithAggregatesInput | ProductPriceHistoryScalarWhereWithAggregatesInput[]
    OR?: ProductPriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: ProductPriceHistoryScalarWhereWithAggregatesInput | ProductPriceHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductPriceHistory"> | string
    productId?: UuidWithAggregatesFilter<"ProductPriceHistory"> | string
    price?: DecimalWithAggregatesFilter<"ProductPriceHistory"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"ProductPriceHistory"> | string
    source?: StringWithAggregatesFilter<"ProductPriceHistory"> | string
    recordedAt?: DateTimeNullableWithAggregatesFilter<"ProductPriceHistory"> | Date | string | null
  }

  export type PriceAlertWhereInput = {
    AND?: PriceAlertWhereInput | PriceAlertWhereInput[]
    OR?: PriceAlertWhereInput[]
    NOT?: PriceAlertWhereInput | PriceAlertWhereInput[]
    id?: UuidFilter<"PriceAlert"> | string
    siteId?: UuidFilter<"PriceAlert"> | string
    productId?: UuidFilter<"PriceAlert"> | string
    alertType?: StringFilter<"PriceAlert"> | string
    threshold?: DecimalFilter<"PriceAlert"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    createdAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type PriceAlertOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    productId?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    site?: SiteOrderByWithRelationInput
  }

  export type PriceAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceAlertWhereInput | PriceAlertWhereInput[]
    OR?: PriceAlertWhereInput[]
    NOT?: PriceAlertWhereInput | PriceAlertWhereInput[]
    siteId?: UuidFilter<"PriceAlert"> | string
    productId?: UuidFilter<"PriceAlert"> | string
    alertType?: StringFilter<"PriceAlert"> | string
    threshold?: DecimalFilter<"PriceAlert"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    createdAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type PriceAlertOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    productId?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    _count?: PriceAlertCountOrderByAggregateInput
    _avg?: PriceAlertAvgOrderByAggregateInput
    _max?: PriceAlertMaxOrderByAggregateInput
    _min?: PriceAlertMinOrderByAggregateInput
    _sum?: PriceAlertSumOrderByAggregateInput
  }

  export type PriceAlertScalarWhereWithAggregatesInput = {
    AND?: PriceAlertScalarWhereWithAggregatesInput | PriceAlertScalarWhereWithAggregatesInput[]
    OR?: PriceAlertScalarWhereWithAggregatesInput[]
    NOT?: PriceAlertScalarWhereWithAggregatesInput | PriceAlertScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PriceAlert"> | string
    siteId?: UuidWithAggregatesFilter<"PriceAlert"> | string
    productId?: UuidWithAggregatesFilter<"PriceAlert"> | string
    alertType?: StringWithAggregatesFilter<"PriceAlert"> | string
    threshold?: DecimalWithAggregatesFilter<"PriceAlert"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"PriceAlert"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"PriceAlert"> | Date | string | null
    triggeredAt?: DateTimeNullableWithAggregatesFilter<"PriceAlert"> | Date | string | null
  }

  export type InteractiveQuizWhereInput = {
    AND?: InteractiveQuizWhereInput | InteractiveQuizWhereInput[]
    OR?: InteractiveQuizWhereInput[]
    NOT?: InteractiveQuizWhereInput | InteractiveQuizWhereInput[]
    id?: UuidFilter<"InteractiveQuiz"> | string
    siteId?: UuidFilter<"InteractiveQuiz"> | string
    title?: StringFilter<"InteractiveQuiz"> | string
    description?: StringNullableFilter<"InteractiveQuiz"> | string | null
    isActive?: BoolFilter<"InteractiveQuiz"> | boolean
    createdAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    questions?: QuizQuestionListRelationFilter
    results?: QuizResultListRelationFilter
  }

  export type InteractiveQuizOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    site?: SiteOrderByWithRelationInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    results?: QuizResultOrderByRelationAggregateInput
  }

  export type InteractiveQuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractiveQuizWhereInput | InteractiveQuizWhereInput[]
    OR?: InteractiveQuizWhereInput[]
    NOT?: InteractiveQuizWhereInput | InteractiveQuizWhereInput[]
    siteId?: UuidFilter<"InteractiveQuiz"> | string
    title?: StringFilter<"InteractiveQuiz"> | string
    description?: StringNullableFilter<"InteractiveQuiz"> | string | null
    isActive?: BoolFilter<"InteractiveQuiz"> | boolean
    createdAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    questions?: QuizQuestionListRelationFilter
    results?: QuizResultListRelationFilter
  }, "id">

  export type InteractiveQuizOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: InteractiveQuizCountOrderByAggregateInput
    _max?: InteractiveQuizMaxOrderByAggregateInput
    _min?: InteractiveQuizMinOrderByAggregateInput
  }

  export type InteractiveQuizScalarWhereWithAggregatesInput = {
    AND?: InteractiveQuizScalarWhereWithAggregatesInput | InteractiveQuizScalarWhereWithAggregatesInput[]
    OR?: InteractiveQuizScalarWhereWithAggregatesInput[]
    NOT?: InteractiveQuizScalarWhereWithAggregatesInput | InteractiveQuizScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InteractiveQuiz"> | string
    siteId?: UuidWithAggregatesFilter<"InteractiveQuiz"> | string
    title?: StringWithAggregatesFilter<"InteractiveQuiz"> | string
    description?: StringNullableWithAggregatesFilter<"InteractiveQuiz"> | string | null
    isActive?: BoolWithAggregatesFilter<"InteractiveQuiz"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"InteractiveQuiz"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"InteractiveQuiz"> | Date | string | null
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: UuidFilter<"QuizQuestion"> | string
    quizId?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    questionType?: StringFilter<"QuizQuestion"> | string
    order?: IntFilter<"QuizQuestion"> | number
    isRequired?: BoolFilter<"QuizQuestion"> | boolean
    createdAt?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
    answers?: QuizAnswerListRelationFilter
    options?: QuizQuestionOptionListRelationFilter
    quiz?: XOR<InteractiveQuizScalarRelationFilter, InteractiveQuizWhereInput>
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    answers?: QuizAnswerOrderByRelationAggregateInput
    options?: QuizQuestionOptionOrderByRelationAggregateInput
    quiz?: InteractiveQuizOrderByWithRelationInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quizId?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    questionType?: StringFilter<"QuizQuestion"> | string
    order?: IntFilter<"QuizQuestion"> | number
    isRequired?: BoolFilter<"QuizQuestion"> | boolean
    createdAt?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
    answers?: QuizAnswerListRelationFilter
    options?: QuizQuestionOptionListRelationFilter
    quiz?: XOR<InteractiveQuizScalarRelationFilter, InteractiveQuizWhereInput>
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizQuestion"> | string
    quizId?: UuidWithAggregatesFilter<"QuizQuestion"> | string
    question?: StringWithAggregatesFilter<"QuizQuestion"> | string
    questionType?: StringWithAggregatesFilter<"QuizQuestion"> | string
    order?: IntWithAggregatesFilter<"QuizQuestion"> | number
    isRequired?: BoolWithAggregatesFilter<"QuizQuestion"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"QuizQuestion"> | Date | string | null
  }

  export type QuizQuestionOptionWhereInput = {
    AND?: QuizQuestionOptionWhereInput | QuizQuestionOptionWhereInput[]
    OR?: QuizQuestionOptionWhereInput[]
    NOT?: QuizQuestionOptionWhereInput | QuizQuestionOptionWhereInput[]
    id?: UuidFilter<"QuizQuestionOption"> | string
    questionId?: UuidFilter<"QuizQuestionOption"> | string
    optionText?: StringFilter<"QuizQuestionOption"> | string
    optionValue?: StringFilter<"QuizQuestionOption"> | string
    order?: IntFilter<"QuizQuestionOption"> | number
    createdAt?: DateTimeNullableFilter<"QuizQuestionOption"> | Date | string | null
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }

  export type QuizQuestionOptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    optionText?: SortOrder
    optionValue?: SortOrder
    order?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    question?: QuizQuestionOrderByWithRelationInput
  }

  export type QuizQuestionOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionOptionWhereInput | QuizQuestionOptionWhereInput[]
    OR?: QuizQuestionOptionWhereInput[]
    NOT?: QuizQuestionOptionWhereInput | QuizQuestionOptionWhereInput[]
    questionId?: UuidFilter<"QuizQuestionOption"> | string
    optionText?: StringFilter<"QuizQuestionOption"> | string
    optionValue?: StringFilter<"QuizQuestionOption"> | string
    order?: IntFilter<"QuizQuestionOption"> | number
    createdAt?: DateTimeNullableFilter<"QuizQuestionOption"> | Date | string | null
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }, "id">

  export type QuizQuestionOptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    optionText?: SortOrder
    optionValue?: SortOrder
    order?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: QuizQuestionOptionCountOrderByAggregateInput
    _avg?: QuizQuestionOptionAvgOrderByAggregateInput
    _max?: QuizQuestionOptionMaxOrderByAggregateInput
    _min?: QuizQuestionOptionMinOrderByAggregateInput
    _sum?: QuizQuestionOptionSumOrderByAggregateInput
  }

  export type QuizQuestionOptionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionOptionScalarWhereWithAggregatesInput | QuizQuestionOptionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionOptionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionOptionScalarWhereWithAggregatesInput | QuizQuestionOptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizQuestionOption"> | string
    questionId?: UuidWithAggregatesFilter<"QuizQuestionOption"> | string
    optionText?: StringWithAggregatesFilter<"QuizQuestionOption"> | string
    optionValue?: StringWithAggregatesFilter<"QuizQuestionOption"> | string
    order?: IntWithAggregatesFilter<"QuizQuestionOption"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"QuizQuestionOption"> | Date | string | null
  }

  export type QuizResultWhereInput = {
    AND?: QuizResultWhereInput | QuizResultWhereInput[]
    OR?: QuizResultWhereInput[]
    NOT?: QuizResultWhereInput | QuizResultWhereInput[]
    id?: UuidFilter<"QuizResult"> | string
    quizId?: UuidFilter<"QuizResult"> | string
    sessionId?: StringFilter<"QuizResult"> | string
    answers?: JsonFilter<"QuizResult">
    recommendations?: JsonNullableFilter<"QuizResult">
    completedAt?: DateTimeNullableFilter<"QuizResult"> | Date | string | null
    quizAnswers?: QuizAnswerListRelationFilter
    quiz?: XOR<InteractiveQuizScalarRelationFilter, InteractiveQuizWhereInput>
  }

  export type QuizResultOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sessionId?: SortOrder
    answers?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    quizAnswers?: QuizAnswerOrderByRelationAggregateInput
    quiz?: InteractiveQuizOrderByWithRelationInput
  }

  export type QuizResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizResultWhereInput | QuizResultWhereInput[]
    OR?: QuizResultWhereInput[]
    NOT?: QuizResultWhereInput | QuizResultWhereInput[]
    quizId?: UuidFilter<"QuizResult"> | string
    sessionId?: StringFilter<"QuizResult"> | string
    answers?: JsonFilter<"QuizResult">
    recommendations?: JsonNullableFilter<"QuizResult">
    completedAt?: DateTimeNullableFilter<"QuizResult"> | Date | string | null
    quizAnswers?: QuizAnswerListRelationFilter
    quiz?: XOR<InteractiveQuizScalarRelationFilter, InteractiveQuizWhereInput>
  }, "id">

  export type QuizResultOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sessionId?: SortOrder
    answers?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: QuizResultCountOrderByAggregateInput
    _max?: QuizResultMaxOrderByAggregateInput
    _min?: QuizResultMinOrderByAggregateInput
  }

  export type QuizResultScalarWhereWithAggregatesInput = {
    AND?: QuizResultScalarWhereWithAggregatesInput | QuizResultScalarWhereWithAggregatesInput[]
    OR?: QuizResultScalarWhereWithAggregatesInput[]
    NOT?: QuizResultScalarWhereWithAggregatesInput | QuizResultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizResult"> | string
    quizId?: UuidWithAggregatesFilter<"QuizResult"> | string
    sessionId?: StringWithAggregatesFilter<"QuizResult"> | string
    answers?: JsonWithAggregatesFilter<"QuizResult">
    recommendations?: JsonNullableWithAggregatesFilter<"QuizResult">
    completedAt?: DateTimeNullableWithAggregatesFilter<"QuizResult"> | Date | string | null
  }

  export type QuizAnswerWhereInput = {
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    id?: UuidFilter<"QuizAnswer"> | string
    resultId?: UuidFilter<"QuizAnswer"> | string
    questionId?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    createdAt?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    result?: XOR<QuizResultScalarRelationFilter, QuizResultWhereInput>
  }

  export type QuizAnswerOrderByWithRelationInput = {
    id?: SortOrder
    resultId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    question?: QuizQuestionOrderByWithRelationInput
    result?: QuizResultOrderByWithRelationInput
  }

  export type QuizAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    resultId?: UuidFilter<"QuizAnswer"> | string
    questionId?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    createdAt?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    result?: XOR<QuizResultScalarRelationFilter, QuizResultWhereInput>
  }, "id">

  export type QuizAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    resultId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: QuizAnswerCountOrderByAggregateInput
    _max?: QuizAnswerMaxOrderByAggregateInput
    _min?: QuizAnswerMinOrderByAggregateInput
  }

  export type QuizAnswerScalarWhereWithAggregatesInput = {
    AND?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    OR?: QuizAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizAnswer"> | string
    resultId?: UuidWithAggregatesFilter<"QuizAnswer"> | string
    questionId?: UuidWithAggregatesFilter<"QuizAnswer"> | string
    answer?: StringWithAggregatesFilter<"QuizAnswer"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"QuizAnswer"> | Date | string | null
  }

  export type AffiliateLinkWhereInput = {
    AND?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    OR?: AffiliateLinkWhereInput[]
    NOT?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    id?: UuidFilter<"AffiliateLink"> | string
    name?: StringFilter<"AffiliateLink"> | string
    originalUrl?: StringFilter<"AffiliateLink"> | string
    affiliateUrl?: StringFilter<"AffiliateLink"> | string
    siteId?: UuidFilter<"AffiliateLink"> | string
    createdBy?: UuidNullableFilter<"AffiliateLink"> | string | null
    createdAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    productId?: UuidNullableFilter<"AffiliateLink"> | string | null
    merchantId?: UuidNullableFilter<"AffiliateLink"> | string | null
    displayText?: StringNullableFilter<"AffiliateLink"> | string | null
    trackingId?: StringNullableFilter<"AffiliateLink"> | string | null
    status?: StringFilter<"AffiliateLink"> | string
    commissionInfo?: JsonNullableFilter<"AffiliateLink">
    expirationDate?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    conversions?: ConversionListRelationFilter
    linkClicks?: LinkClickListRelationFilter
  }

  export type AffiliateLinkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalUrl?: SortOrder
    affiliateUrl?: SortOrder
    siteId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    displayText?: SortOrderInput | SortOrder
    trackingId?: SortOrderInput | SortOrder
    status?: SortOrder
    commissionInfo?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    merchant?: MerchantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
    conversions?: ConversionOrderByRelationAggregateInput
    linkClicks?: LinkClickOrderByRelationAggregateInput
  }

  export type AffiliateLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    OR?: AffiliateLinkWhereInput[]
    NOT?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    name?: StringFilter<"AffiliateLink"> | string
    originalUrl?: StringFilter<"AffiliateLink"> | string
    affiliateUrl?: StringFilter<"AffiliateLink"> | string
    siteId?: UuidFilter<"AffiliateLink"> | string
    createdBy?: UuidNullableFilter<"AffiliateLink"> | string | null
    createdAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    productId?: UuidNullableFilter<"AffiliateLink"> | string | null
    merchantId?: UuidNullableFilter<"AffiliateLink"> | string | null
    displayText?: StringNullableFilter<"AffiliateLink"> | string | null
    trackingId?: StringNullableFilter<"AffiliateLink"> | string | null
    status?: StringFilter<"AffiliateLink"> | string
    commissionInfo?: JsonNullableFilter<"AffiliateLink">
    expirationDate?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    conversions?: ConversionListRelationFilter
    linkClicks?: LinkClickListRelationFilter
  }, "id">

  export type AffiliateLinkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalUrl?: SortOrder
    affiliateUrl?: SortOrder
    siteId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    displayText?: SortOrderInput | SortOrder
    trackingId?: SortOrderInput | SortOrder
    status?: SortOrder
    commissionInfo?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    _count?: AffiliateLinkCountOrderByAggregateInput
    _max?: AffiliateLinkMaxOrderByAggregateInput
    _min?: AffiliateLinkMinOrderByAggregateInput
  }

  export type AffiliateLinkScalarWhereWithAggregatesInput = {
    AND?: AffiliateLinkScalarWhereWithAggregatesInput | AffiliateLinkScalarWhereWithAggregatesInput[]
    OR?: AffiliateLinkScalarWhereWithAggregatesInput[]
    NOT?: AffiliateLinkScalarWhereWithAggregatesInput | AffiliateLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AffiliateLink"> | string
    name?: StringWithAggregatesFilter<"AffiliateLink"> | string
    originalUrl?: StringWithAggregatesFilter<"AffiliateLink"> | string
    affiliateUrl?: StringWithAggregatesFilter<"AffiliateLink"> | string
    siteId?: UuidWithAggregatesFilter<"AffiliateLink"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AffiliateLink"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AffiliateLink"> | Date | string | null
    productId?: UuidNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    merchantId?: UuidNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    displayText?: StringNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    trackingId?: StringNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    status?: StringWithAggregatesFilter<"AffiliateLink"> | string
    commissionInfo?: JsonNullableWithAggregatesFilter<"AffiliateLink">
    expirationDate?: DateTimeNullableWithAggregatesFilter<"AffiliateLink"> | Date | string | null
  }

  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: UuidFilter<"Merchant"> | string
    name?: StringFilter<"Merchant"> | string
    description?: StringNullableFilter<"Merchant"> | string | null
    website?: StringNullableFilter<"Merchant"> | string | null
    logoUrl?: StringNullableFilter<"Merchant"> | string | null
    createdAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    affiliateLinks?: AffiliateLinkOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    name?: StringFilter<"Merchant"> | string
    description?: StringNullableFilter<"Merchant"> | string | null
    website?: StringNullableFilter<"Merchant"> | string | null
    logoUrl?: StringNullableFilter<"Merchant"> | string | null
    createdAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Merchant"> | Date | string | null
    affiliateLinks?: AffiliateLinkListRelationFilter
  }, "id">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Merchant"> | string
    name?: StringWithAggregatesFilter<"Merchant"> | string
    description?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Merchant"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Merchant"> | Date | string | null
  }

  export type LinkClickWhereInput = {
    AND?: LinkClickWhereInput | LinkClickWhereInput[]
    OR?: LinkClickWhereInput[]
    NOT?: LinkClickWhereInput | LinkClickWhereInput[]
    id?: UuidFilter<"LinkClick"> | string
    affiliateLinkId?: UuidFilter<"LinkClick"> | string
    ipAddress?: StringNullableFilter<"LinkClick"> | string | null
    userAgent?: StringNullableFilter<"LinkClick"> | string | null
    referrer?: StringNullableFilter<"LinkClick"> | string | null
    clickedAt?: DateTimeNullableFilter<"LinkClick"> | Date | string | null
    conversionStatus?: StringNullableFilter<"LinkClick"> | string | null
    conversionValue?: DecimalNullableFilter<"LinkClick"> | Decimal | DecimalJsLike | number | string | null
    affiliateLink?: XOR<AffiliateLinkScalarRelationFilter, AffiliateLinkWhereInput>
  }

  export type LinkClickOrderByWithRelationInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    conversionStatus?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    affiliateLink?: AffiliateLinkOrderByWithRelationInput
  }

  export type LinkClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinkClickWhereInput | LinkClickWhereInput[]
    OR?: LinkClickWhereInput[]
    NOT?: LinkClickWhereInput | LinkClickWhereInput[]
    affiliateLinkId?: UuidFilter<"LinkClick"> | string
    ipAddress?: StringNullableFilter<"LinkClick"> | string | null
    userAgent?: StringNullableFilter<"LinkClick"> | string | null
    referrer?: StringNullableFilter<"LinkClick"> | string | null
    clickedAt?: DateTimeNullableFilter<"LinkClick"> | Date | string | null
    conversionStatus?: StringNullableFilter<"LinkClick"> | string | null
    conversionValue?: DecimalNullableFilter<"LinkClick"> | Decimal | DecimalJsLike | number | string | null
    affiliateLink?: XOR<AffiliateLinkScalarRelationFilter, AffiliateLinkWhereInput>
  }, "id">

  export type LinkClickOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    conversionStatus?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    _count?: LinkClickCountOrderByAggregateInput
    _avg?: LinkClickAvgOrderByAggregateInput
    _max?: LinkClickMaxOrderByAggregateInput
    _min?: LinkClickMinOrderByAggregateInput
    _sum?: LinkClickSumOrderByAggregateInput
  }

  export type LinkClickScalarWhereWithAggregatesInput = {
    AND?: LinkClickScalarWhereWithAggregatesInput | LinkClickScalarWhereWithAggregatesInput[]
    OR?: LinkClickScalarWhereWithAggregatesInput[]
    NOT?: LinkClickScalarWhereWithAggregatesInput | LinkClickScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LinkClick"> | string
    affiliateLinkId?: UuidWithAggregatesFilter<"LinkClick"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"LinkClick"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LinkClick"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"LinkClick"> | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"LinkClick"> | Date | string | null
    conversionStatus?: StringNullableWithAggregatesFilter<"LinkClick"> | string | null
    conversionValue?: DecimalNullableWithAggregatesFilter<"LinkClick"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ConversionWhereInput = {
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    id?: UuidFilter<"Conversion"> | string
    affiliateLinkId?: UuidFilter<"Conversion"> | string
    orderId?: StringNullableFilter<"Conversion"> | string | null
    orderValue?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Conversion"> | string
    conversionDate?: DateTimeNullableFilter<"Conversion"> | Date | string | null
    status?: StringFilter<"Conversion"> | string
    notes?: StringNullableFilter<"Conversion"> | string | null
    affiliateLink?: XOR<AffiliateLinkScalarRelationFilter, AffiliateLinkWhereInput>
  }

  export type ConversionOrderByWithRelationInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderValue?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    conversionDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    affiliateLink?: AffiliateLinkOrderByWithRelationInput
  }

  export type ConversionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    affiliateLinkId?: UuidFilter<"Conversion"> | string
    orderId?: StringNullableFilter<"Conversion"> | string | null
    orderValue?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Conversion"> | string
    conversionDate?: DateTimeNullableFilter<"Conversion"> | Date | string | null
    status?: StringFilter<"Conversion"> | string
    notes?: StringNullableFilter<"Conversion"> | string | null
    affiliateLink?: XOR<AffiliateLinkScalarRelationFilter, AffiliateLinkWhereInput>
  }, "id">

  export type ConversionOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderValue?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    conversionDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ConversionCountOrderByAggregateInput
    _avg?: ConversionAvgOrderByAggregateInput
    _max?: ConversionMaxOrderByAggregateInput
    _min?: ConversionMinOrderByAggregateInput
    _sum?: ConversionSumOrderByAggregateInput
  }

  export type ConversionScalarWhereWithAggregatesInput = {
    AND?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    OR?: ConversionScalarWhereWithAggregatesInput[]
    NOT?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Conversion"> | string
    affiliateLinkId?: UuidWithAggregatesFilter<"Conversion"> | string
    orderId?: StringNullableWithAggregatesFilter<"Conversion"> | string | null
    orderValue?: DecimalWithAggregatesFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalWithAggregatesFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Conversion"> | string
    conversionDate?: DateTimeNullableWithAggregatesFilter<"Conversion"> | Date | string | null
    status?: StringWithAggregatesFilter<"Conversion"> | string
    notes?: StringNullableWithAggregatesFilter<"Conversion"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    userRoles?: UserRoleListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    siteId?: UuidNullableFilter<"UserRole"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    siteId?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    siteId?: UuidNullableFilter<"UserRole"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    siteId?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    siteId?: UuidNullableWithAggregatesFilter<"UserRole"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeNullableWithAggregatesFilter<"AuditLog"> | Date | string | null
  }

  export type NewsletterSubscriberWhereInput = {
    AND?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    OR?: NewsletterSubscriberWhereInput[]
    NOT?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    id?: UuidFilter<"NewsletterSubscriber"> | string
    email?: StringFilter<"NewsletterSubscriber"> | string
    firstName?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    lastName?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    isActive?: BoolFilter<"NewsletterSubscriber"> | boolean
    subscribedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    unsubscribedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    preferences?: JsonNullableFilter<"NewsletterSubscriber">
    source?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    createdAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
  }

  export type NewsletterSubscriberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscribedAt?: SortOrderInput | SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type NewsletterSubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    OR?: NewsletterSubscriberWhereInput[]
    NOT?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    firstName?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    lastName?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    isActive?: BoolFilter<"NewsletterSubscriber"> | boolean
    subscribedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    unsubscribedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    preferences?: JsonNullableFilter<"NewsletterSubscriber">
    source?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    createdAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NewsletterSubscriber"> | Date | string | null
  }, "id" | "email">

  export type NewsletterSubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscribedAt?: SortOrderInput | SortOrder
    unsubscribedAt?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: NewsletterSubscriberCountOrderByAggregateInput
    _max?: NewsletterSubscriberMaxOrderByAggregateInput
    _min?: NewsletterSubscriberMinOrderByAggregateInput
  }

  export type NewsletterSubscriberScalarWhereWithAggregatesInput = {
    AND?: NewsletterSubscriberScalarWhereWithAggregatesInput | NewsletterSubscriberScalarWhereWithAggregatesInput[]
    OR?: NewsletterSubscriberScalarWhereWithAggregatesInput[]
    NOT?: NewsletterSubscriberScalarWhereWithAggregatesInput | NewsletterSubscriberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NewsletterSubscriber"> | string
    email?: StringWithAggregatesFilter<"NewsletterSubscriber"> | string
    firstName?: StringNullableWithAggregatesFilter<"NewsletterSubscriber"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"NewsletterSubscriber"> | string | null
    isActive?: BoolWithAggregatesFilter<"NewsletterSubscriber"> | boolean
    subscribedAt?: DateTimeNullableWithAggregatesFilter<"NewsletterSubscriber"> | Date | string | null
    unsubscribedAt?: DateTimeNullableWithAggregatesFilter<"NewsletterSubscriber"> | Date | string | null
    preferences?: JsonNullableWithAggregatesFilter<"NewsletterSubscriber">
    source?: StringNullableWithAggregatesFilter<"NewsletterSubscriber"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"NewsletterSubscriber"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"NewsletterSubscriber"> | Date | string | null
  }

  export type NewsletterCampaignWhereInput = {
    AND?: NewsletterCampaignWhereInput | NewsletterCampaignWhereInput[]
    OR?: NewsletterCampaignWhereInput[]
    NOT?: NewsletterCampaignWhereInput | NewsletterCampaignWhereInput[]
    id?: UuidFilter<"NewsletterCampaign"> | string
    name?: StringFilter<"NewsletterCampaign"> | string
    subject?: StringFilter<"NewsletterCampaign"> | string
    content?: StringFilter<"NewsletterCampaign"> | string
    status?: StringFilter<"NewsletterCampaign"> | string
    sentAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
    sentCount?: IntFilter<"NewsletterCampaign"> | number
    openCount?: IntFilter<"NewsletterCampaign"> | number
    clickCount?: IntFilter<"NewsletterCampaign"> | number
    createdAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
  }

  export type NewsletterCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type NewsletterCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsletterCampaignWhereInput | NewsletterCampaignWhereInput[]
    OR?: NewsletterCampaignWhereInput[]
    NOT?: NewsletterCampaignWhereInput | NewsletterCampaignWhereInput[]
    name?: StringFilter<"NewsletterCampaign"> | string
    subject?: StringFilter<"NewsletterCampaign"> | string
    content?: StringFilter<"NewsletterCampaign"> | string
    status?: StringFilter<"NewsletterCampaign"> | string
    sentAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
    sentCount?: IntFilter<"NewsletterCampaign"> | number
    openCount?: IntFilter<"NewsletterCampaign"> | number
    clickCount?: IntFilter<"NewsletterCampaign"> | number
    createdAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"NewsletterCampaign"> | Date | string | null
  }, "id">

  export type NewsletterCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: NewsletterCampaignCountOrderByAggregateInput
    _avg?: NewsletterCampaignAvgOrderByAggregateInput
    _max?: NewsletterCampaignMaxOrderByAggregateInput
    _min?: NewsletterCampaignMinOrderByAggregateInput
    _sum?: NewsletterCampaignSumOrderByAggregateInput
  }

  export type NewsletterCampaignScalarWhereWithAggregatesInput = {
    AND?: NewsletterCampaignScalarWhereWithAggregatesInput | NewsletterCampaignScalarWhereWithAggregatesInput[]
    OR?: NewsletterCampaignScalarWhereWithAggregatesInput[]
    NOT?: NewsletterCampaignScalarWhereWithAggregatesInput | NewsletterCampaignScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NewsletterCampaign"> | string
    name?: StringWithAggregatesFilter<"NewsletterCampaign"> | string
    subject?: StringWithAggregatesFilter<"NewsletterCampaign"> | string
    content?: StringWithAggregatesFilter<"NewsletterCampaign"> | string
    status?: StringWithAggregatesFilter<"NewsletterCampaign"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"NewsletterCampaign"> | Date | string | null
    sentCount?: IntWithAggregatesFilter<"NewsletterCampaign"> | number
    openCount?: IntWithAggregatesFilter<"NewsletterCampaign"> | number
    clickCount?: IntWithAggregatesFilter<"NewsletterCampaign"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"NewsletterCampaign"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"NewsletterCampaign"> | Date | string | null
  }

  export type NewsletterWhereInput = {
    AND?: NewsletterWhereInput | NewsletterWhereInput[]
    OR?: NewsletterWhereInput[]
    NOT?: NewsletterWhereInput | NewsletterWhereInput[]
    id?: UuidFilter<"Newsletter"> | string
    name?: StringFilter<"Newsletter"> | string
    description?: StringNullableFilter<"Newsletter"> | string | null
    createdAt?: DateTimeNullableFilter<"Newsletter"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Newsletter"> | Date | string | null
  }

  export type NewsletterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type NewsletterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsletterWhereInput | NewsletterWhereInput[]
    OR?: NewsletterWhereInput[]
    NOT?: NewsletterWhereInput | NewsletterWhereInput[]
    name?: StringFilter<"Newsletter"> | string
    description?: StringNullableFilter<"Newsletter"> | string | null
    createdAt?: DateTimeNullableFilter<"Newsletter"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Newsletter"> | Date | string | null
  }, "id">

  export type NewsletterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: NewsletterCountOrderByAggregateInput
    _max?: NewsletterMaxOrderByAggregateInput
    _min?: NewsletterMinOrderByAggregateInput
  }

  export type NewsletterScalarWhereWithAggregatesInput = {
    AND?: NewsletterScalarWhereWithAggregatesInput | NewsletterScalarWhereWithAggregatesInput[]
    OR?: NewsletterScalarWhereWithAggregatesInput[]
    NOT?: NewsletterScalarWhereWithAggregatesInput | NewsletterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Newsletter"> | string
    name?: StringWithAggregatesFilter<"Newsletter"> | string
    description?: StringNullableWithAggregatesFilter<"Newsletter"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Newsletter"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Newsletter"> | Date | string | null
  }

  export type SocialMediaAccountWhereInput = {
    AND?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    OR?: SocialMediaAccountWhereInput[]
    NOT?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    id?: UuidFilter<"SocialMediaAccount"> | string
    platform?: StringFilter<"SocialMediaAccount"> | string
    username?: StringFilter<"SocialMediaAccount"> | string
    accessToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    refreshToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    isActive?: BoolFilter<"SocialMediaAccount"> | boolean
    createdAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
  }

  export type SocialMediaAccountOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type SocialMediaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    OR?: SocialMediaAccountWhereInput[]
    NOT?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    platform?: StringFilter<"SocialMediaAccount"> | string
    username?: StringFilter<"SocialMediaAccount"> | string
    accessToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    refreshToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    isActive?: BoolFilter<"SocialMediaAccount"> | boolean
    createdAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
  }, "id">

  export type SocialMediaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SocialMediaAccountCountOrderByAggregateInput
    _max?: SocialMediaAccountMaxOrderByAggregateInput
    _min?: SocialMediaAccountMinOrderByAggregateInput
  }

  export type SocialMediaAccountScalarWhereWithAggregatesInput = {
    AND?: SocialMediaAccountScalarWhereWithAggregatesInput | SocialMediaAccountScalarWhereWithAggregatesInput[]
    OR?: SocialMediaAccountScalarWhereWithAggregatesInput[]
    NOT?: SocialMediaAccountScalarWhereWithAggregatesInput | SocialMediaAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SocialMediaAccount"> | string
    platform?: StringWithAggregatesFilter<"SocialMediaAccount"> | string
    username?: StringWithAggregatesFilter<"SocialMediaAccount"> | string
    accessToken?: StringNullableWithAggregatesFilter<"SocialMediaAccount"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"SocialMediaAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"SocialMediaAccount"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaAccount"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaAccount"> | Date | string | null
  }

  export type SocialMediaPostWhereInput = {
    AND?: SocialMediaPostWhereInput | SocialMediaPostWhereInput[]
    OR?: SocialMediaPostWhereInput[]
    NOT?: SocialMediaPostWhereInput | SocialMediaPostWhereInput[]
    id?: UuidFilter<"SocialMediaPost"> | string
    platform?: StringFilter<"SocialMediaPost"> | string
    content?: StringFilter<"SocialMediaPost"> | string
    mediaUrls?: JsonNullableFilter<"SocialMediaPost">
    status?: StringFilter<"SocialMediaPost"> | string
    scheduledAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    engagement?: JsonNullableFilter<"SocialMediaPost">
    createdAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
  }

  export type SocialMediaPostOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    content?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type SocialMediaPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialMediaPostWhereInput | SocialMediaPostWhereInput[]
    OR?: SocialMediaPostWhereInput[]
    NOT?: SocialMediaPostWhereInput | SocialMediaPostWhereInput[]
    platform?: StringFilter<"SocialMediaPost"> | string
    content?: StringFilter<"SocialMediaPost"> | string
    mediaUrls?: JsonNullableFilter<"SocialMediaPost">
    status?: StringFilter<"SocialMediaPost"> | string
    scheduledAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    engagement?: JsonNullableFilter<"SocialMediaPost">
    createdAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SocialMediaPost"> | Date | string | null
  }, "id">

  export type SocialMediaPostOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    content?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SocialMediaPostCountOrderByAggregateInput
    _max?: SocialMediaPostMaxOrderByAggregateInput
    _min?: SocialMediaPostMinOrderByAggregateInput
  }

  export type SocialMediaPostScalarWhereWithAggregatesInput = {
    AND?: SocialMediaPostScalarWhereWithAggregatesInput | SocialMediaPostScalarWhereWithAggregatesInput[]
    OR?: SocialMediaPostScalarWhereWithAggregatesInput[]
    NOT?: SocialMediaPostScalarWhereWithAggregatesInput | SocialMediaPostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SocialMediaPost"> | string
    platform?: StringWithAggregatesFilter<"SocialMediaPost"> | string
    content?: StringWithAggregatesFilter<"SocialMediaPost"> | string
    mediaUrls?: JsonNullableWithAggregatesFilter<"SocialMediaPost">
    status?: StringWithAggregatesFilter<"SocialMediaPost"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaPost"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaPost"> | Date | string | null
    engagement?: JsonNullableWithAggregatesFilter<"SocialMediaPost">
    createdAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaPost"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaPost"> | Date | string | null
  }

  export type AffiliateProductWhereInput = {
    AND?: AffiliateProductWhereInput | AffiliateProductWhereInput[]
    OR?: AffiliateProductWhereInput[]
    NOT?: AffiliateProductWhereInput | AffiliateProductWhereInput[]
    id?: UuidFilter<"AffiliateProduct"> | string
    name?: StringFilter<"AffiliateProduct"> | string
    description?: StringNullableFilter<"AffiliateProduct"> | string | null
    price?: DecimalFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"AffiliateProduct"> | string
    affiliateUrl?: StringFilter<"AffiliateProduct"> | string
    merchant?: StringFilter<"AffiliateProduct"> | string
    category?: StringNullableFilter<"AffiliateProduct"> | string | null
    tags?: JsonNullableFilter<"AffiliateProduct">
    images?: JsonNullableFilter<"AffiliateProduct">
    specifications?: JsonNullableFilter<"AffiliateProduct">
    availability?: BoolFilter<"AffiliateProduct"> | boolean
    rating?: DecimalNullableFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntNullableFilter<"AffiliateProduct"> | number | null
    createdAt?: DateTimeNullableFilter<"AffiliateProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AffiliateProduct"> | Date | string | null
  }

  export type AffiliateProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    affiliateUrl?: SortOrder
    merchant?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    availability?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type AffiliateProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateProductWhereInput | AffiliateProductWhereInput[]
    OR?: AffiliateProductWhereInput[]
    NOT?: AffiliateProductWhereInput | AffiliateProductWhereInput[]
    name?: StringFilter<"AffiliateProduct"> | string
    description?: StringNullableFilter<"AffiliateProduct"> | string | null
    price?: DecimalFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"AffiliateProduct"> | string
    affiliateUrl?: StringFilter<"AffiliateProduct"> | string
    merchant?: StringFilter<"AffiliateProduct"> | string
    category?: StringNullableFilter<"AffiliateProduct"> | string | null
    tags?: JsonNullableFilter<"AffiliateProduct">
    images?: JsonNullableFilter<"AffiliateProduct">
    specifications?: JsonNullableFilter<"AffiliateProduct">
    availability?: BoolFilter<"AffiliateProduct"> | boolean
    rating?: DecimalNullableFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntNullableFilter<"AffiliateProduct"> | number | null
    createdAt?: DateTimeNullableFilter<"AffiliateProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AffiliateProduct"> | Date | string | null
  }, "id">

  export type AffiliateProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    affiliateUrl?: SortOrder
    merchant?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    availability?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AffiliateProductCountOrderByAggregateInput
    _avg?: AffiliateProductAvgOrderByAggregateInput
    _max?: AffiliateProductMaxOrderByAggregateInput
    _min?: AffiliateProductMinOrderByAggregateInput
    _sum?: AffiliateProductSumOrderByAggregateInput
  }

  export type AffiliateProductScalarWhereWithAggregatesInput = {
    AND?: AffiliateProductScalarWhereWithAggregatesInput | AffiliateProductScalarWhereWithAggregatesInput[]
    OR?: AffiliateProductScalarWhereWithAggregatesInput[]
    NOT?: AffiliateProductScalarWhereWithAggregatesInput | AffiliateProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AffiliateProduct"> | string
    name?: StringWithAggregatesFilter<"AffiliateProduct"> | string
    description?: StringNullableWithAggregatesFilter<"AffiliateProduct"> | string | null
    price?: DecimalWithAggregatesFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"AffiliateProduct"> | string
    affiliateUrl?: StringWithAggregatesFilter<"AffiliateProduct"> | string
    merchant?: StringWithAggregatesFilter<"AffiliateProduct"> | string
    category?: StringNullableWithAggregatesFilter<"AffiliateProduct"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"AffiliateProduct">
    images?: JsonNullableWithAggregatesFilter<"AffiliateProduct">
    specifications?: JsonNullableWithAggregatesFilter<"AffiliateProduct">
    availability?: BoolWithAggregatesFilter<"AffiliateProduct"> | boolean
    rating?: DecimalNullableWithAggregatesFilter<"AffiliateProduct"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntNullableWithAggregatesFilter<"AffiliateProduct"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AffiliateProduct"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AffiliateProduct"> | Date | string | null
  }

  export type AffiliateLinkClickWhereInput = {
    AND?: AffiliateLinkClickWhereInput | AffiliateLinkClickWhereInput[]
    OR?: AffiliateLinkClickWhereInput[]
    NOT?: AffiliateLinkClickWhereInput | AffiliateLinkClickWhereInput[]
    id?: UuidFilter<"AffiliateLinkClick"> | string
    affiliateUrl?: StringFilter<"AffiliateLinkClick"> | string
    ipAddress?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    userAgent?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    referrer?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    clickedAt?: DateTimeNullableFilter<"AffiliateLinkClick"> | Date | string | null
    conversionValue?: DecimalNullableFilter<"AffiliateLinkClick"> | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickOrderByWithRelationInput = {
    id?: SortOrder
    affiliateUrl?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
  }

  export type AffiliateLinkClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateLinkClickWhereInput | AffiliateLinkClickWhereInput[]
    OR?: AffiliateLinkClickWhereInput[]
    NOT?: AffiliateLinkClickWhereInput | AffiliateLinkClickWhereInput[]
    affiliateUrl?: StringFilter<"AffiliateLinkClick"> | string
    ipAddress?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    userAgent?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    referrer?: StringNullableFilter<"AffiliateLinkClick"> | string | null
    clickedAt?: DateTimeNullableFilter<"AffiliateLinkClick"> | Date | string | null
    conversionValue?: DecimalNullableFilter<"AffiliateLinkClick"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type AffiliateLinkClickOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateUrl?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    _count?: AffiliateLinkClickCountOrderByAggregateInput
    _avg?: AffiliateLinkClickAvgOrderByAggregateInput
    _max?: AffiliateLinkClickMaxOrderByAggregateInput
    _min?: AffiliateLinkClickMinOrderByAggregateInput
    _sum?: AffiliateLinkClickSumOrderByAggregateInput
  }

  export type AffiliateLinkClickScalarWhereWithAggregatesInput = {
    AND?: AffiliateLinkClickScalarWhereWithAggregatesInput | AffiliateLinkClickScalarWhereWithAggregatesInput[]
    OR?: AffiliateLinkClickScalarWhereWithAggregatesInput[]
    NOT?: AffiliateLinkClickScalarWhereWithAggregatesInput | AffiliateLinkClickScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AffiliateLinkClick"> | string
    affiliateUrl?: StringWithAggregatesFilter<"AffiliateLinkClick"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AffiliateLinkClick"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AffiliateLinkClick"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"AffiliateLinkClick"> | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"AffiliateLinkClick"> | Date | string | null
    conversionValue?: DecimalNullableWithAggregatesFilter<"AffiliateLinkClick"> | Decimal | DecimalJsLike | number | string | null
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: UuidFilter<"Recipe"> | string
    title?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    prepTime?: IntNullableFilter<"Recipe"> | number | null
    cookTime?: IntNullableFilter<"Recipe"> | number | null
    servings?: IntNullableFilter<"Recipe"> | number | null
    difficulty?: StringNullableFilter<"Recipe"> | string | null
    cuisine?: StringNullableFilter<"Recipe"> | string | null
    tags?: JsonNullableFilter<"Recipe">
    createdAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    ingredients?: RecipeIngredientListRelationFilter
    instructions?: RecipeInstructionListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prepTime?: SortOrderInput | SortOrder
    cookTime?: SortOrderInput | SortOrder
    servings?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    cuisine?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ingredients?: RecipeIngredientOrderByRelationAggregateInput
    instructions?: RecipeInstructionOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    title?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    prepTime?: IntNullableFilter<"Recipe"> | number | null
    cookTime?: IntNullableFilter<"Recipe"> | number | null
    servings?: IntNullableFilter<"Recipe"> | number | null
    difficulty?: StringNullableFilter<"Recipe"> | string | null
    cuisine?: StringNullableFilter<"Recipe"> | string | null
    tags?: JsonNullableFilter<"Recipe">
    createdAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    ingredients?: RecipeIngredientListRelationFilter
    instructions?: RecipeInstructionListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prepTime?: SortOrderInput | SortOrder
    cookTime?: SortOrderInput | SortOrder
    servings?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    cuisine?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Recipe"> | string
    title?: StringWithAggregatesFilter<"Recipe"> | string
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    prepTime?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    cookTime?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    servings?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    difficulty?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    cuisine?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"Recipe">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Recipe"> | Date | string | null
  }

  export type RecipeIngredientWhereInput = {
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    id?: UuidFilter<"RecipeIngredient"> | string
    recipeId?: UuidFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
    order?: IntFilter<"RecipeIngredient"> | number
    createdAt?: DateTimeNullableFilter<"RecipeIngredient"> | Date | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type RecipeIngredientOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipeId?: UuidFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
    order?: IntFilter<"RecipeIngredient"> | number
    createdAt?: DateTimeNullableFilter<"RecipeIngredient"> | Date | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id">

  export type RecipeIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: RecipeIngredientCountOrderByAggregateInput
    _avg?: RecipeIngredientAvgOrderByAggregateInput
    _max?: RecipeIngredientMaxOrderByAggregateInput
    _min?: RecipeIngredientMinOrderByAggregateInput
    _sum?: RecipeIngredientSumOrderByAggregateInput
  }

  export type RecipeIngredientScalarWhereWithAggregatesInput = {
    AND?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    OR?: RecipeIngredientScalarWhereWithAggregatesInput[]
    NOT?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RecipeIngredient"> | string
    recipeId?: UuidWithAggregatesFilter<"RecipeIngredient"> | string
    name?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    amount?: DecimalWithAggregatesFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    notes?: StringNullableWithAggregatesFilter<"RecipeIngredient"> | string | null
    order?: IntWithAggregatesFilter<"RecipeIngredient"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RecipeIngredient"> | Date | string | null
  }

  export type RecipeInstructionWhereInput = {
    AND?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    OR?: RecipeInstructionWhereInput[]
    NOT?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    id?: UuidFilter<"RecipeInstruction"> | string
    recipeId?: UuidFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
    imageUrl?: StringNullableFilter<"RecipeInstruction"> | string | null
    createdAt?: DateTimeNullableFilter<"RecipeInstruction"> | Date | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type RecipeInstructionOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeInstructionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    OR?: RecipeInstructionWhereInput[]
    NOT?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    recipeId?: UuidFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
    imageUrl?: StringNullableFilter<"RecipeInstruction"> | string | null
    createdAt?: DateTimeNullableFilter<"RecipeInstruction"> | Date | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id">

  export type RecipeInstructionOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: RecipeInstructionCountOrderByAggregateInput
    _avg?: RecipeInstructionAvgOrderByAggregateInput
    _max?: RecipeInstructionMaxOrderByAggregateInput
    _min?: RecipeInstructionMinOrderByAggregateInput
    _sum?: RecipeInstructionSumOrderByAggregateInput
  }

  export type RecipeInstructionScalarWhereWithAggregatesInput = {
    AND?: RecipeInstructionScalarWhereWithAggregatesInput | RecipeInstructionScalarWhereWithAggregatesInput[]
    OR?: RecipeInstructionScalarWhereWithAggregatesInput[]
    NOT?: RecipeInstructionScalarWhereWithAggregatesInput | RecipeInstructionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RecipeInstruction"> | string
    recipeId?: UuidWithAggregatesFilter<"RecipeInstruction"> | string
    stepNumber?: IntWithAggregatesFilter<"RecipeInstruction"> | number
    instruction?: StringWithAggregatesFilter<"RecipeInstruction"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"RecipeInstruction"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"RecipeInstruction"> | Date | string | null
  }

  export type ContentVersionWhereInput = {
    AND?: ContentVersionWhereInput | ContentVersionWhereInput[]
    OR?: ContentVersionWhereInput[]
    NOT?: ContentVersionWhereInput | ContentVersionWhereInput[]
    id?: UuidFilter<"ContentVersion"> | string
    contentId?: UuidFilter<"ContentVersion"> | string
    version?: IntFilter<"ContentVersion"> | number
    data?: JsonFilter<"ContentVersion">
    createdBy?: UuidNullableFilter<"ContentVersion"> | string | null
    createdAt?: DateTimeNullableFilter<"ContentVersion"> | Date | string | null
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }

  export type ContentVersionOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    content?: ContentOrderByWithRelationInput
  }

  export type ContentVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentVersionWhereInput | ContentVersionWhereInput[]
    OR?: ContentVersionWhereInput[]
    NOT?: ContentVersionWhereInput | ContentVersionWhereInput[]
    contentId?: UuidFilter<"ContentVersion"> | string
    version?: IntFilter<"ContentVersion"> | number
    data?: JsonFilter<"ContentVersion">
    createdBy?: UuidNullableFilter<"ContentVersion"> | string | null
    createdAt?: DateTimeNullableFilter<"ContentVersion"> | Date | string | null
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }, "id">

  export type ContentVersionOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: ContentVersionCountOrderByAggregateInput
    _avg?: ContentVersionAvgOrderByAggregateInput
    _max?: ContentVersionMaxOrderByAggregateInput
    _min?: ContentVersionMinOrderByAggregateInput
    _sum?: ContentVersionSumOrderByAggregateInput
  }

  export type ContentVersionScalarWhereWithAggregatesInput = {
    AND?: ContentVersionScalarWhereWithAggregatesInput | ContentVersionScalarWhereWithAggregatesInput[]
    OR?: ContentVersionScalarWhereWithAggregatesInput[]
    NOT?: ContentVersionScalarWhereWithAggregatesInput | ContentVersionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContentVersion"> | string
    contentId?: UuidWithAggregatesFilter<"ContentVersion"> | string
    version?: IntWithAggregatesFilter<"ContentVersion"> | number
    data?: JsonWithAggregatesFilter<"ContentVersion">
    createdBy?: UuidNullableWithAggregatesFilter<"ContentVersion"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ContentVersion"> | Date | string | null
  }

  export type RealTimeNotificationWhereInput = {
    AND?: RealTimeNotificationWhereInput | RealTimeNotificationWhereInput[]
    OR?: RealTimeNotificationWhereInput[]
    NOT?: RealTimeNotificationWhereInput | RealTimeNotificationWhereInput[]
    id?: UuidFilter<"RealTimeNotification"> | string
    userId?: UuidFilter<"RealTimeNotification"> | string
    type?: StringFilter<"RealTimeNotification"> | string
    title?: StringFilter<"RealTimeNotification"> | string
    message?: StringFilter<"RealTimeNotification"> | string
    isRead?: BoolFilter<"RealTimeNotification"> | boolean
    createdAt?: DateTimeNullableFilter<"RealTimeNotification"> | Date | string | null
  }

  export type RealTimeNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type RealTimeNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RealTimeNotificationWhereInput | RealTimeNotificationWhereInput[]
    OR?: RealTimeNotificationWhereInput[]
    NOT?: RealTimeNotificationWhereInput | RealTimeNotificationWhereInput[]
    userId?: UuidFilter<"RealTimeNotification"> | string
    type?: StringFilter<"RealTimeNotification"> | string
    title?: StringFilter<"RealTimeNotification"> | string
    message?: StringFilter<"RealTimeNotification"> | string
    isRead?: BoolFilter<"RealTimeNotification"> | boolean
    createdAt?: DateTimeNullableFilter<"RealTimeNotification"> | Date | string | null
  }, "id">

  export type RealTimeNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: RealTimeNotificationCountOrderByAggregateInput
    _max?: RealTimeNotificationMaxOrderByAggregateInput
    _min?: RealTimeNotificationMinOrderByAggregateInput
  }

  export type RealTimeNotificationScalarWhereWithAggregatesInput = {
    AND?: RealTimeNotificationScalarWhereWithAggregatesInput | RealTimeNotificationScalarWhereWithAggregatesInput[]
    OR?: RealTimeNotificationScalarWhereWithAggregatesInput[]
    NOT?: RealTimeNotificationScalarWhereWithAggregatesInput | RealTimeNotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RealTimeNotification"> | string
    userId?: UuidWithAggregatesFilter<"RealTimeNotification"> | string
    type?: StringWithAggregatesFilter<"RealTimeNotification"> | string
    title?: StringWithAggregatesFilter<"RealTimeNotification"> | string
    message?: StringWithAggregatesFilter<"RealTimeNotification"> | string
    isRead?: BoolWithAggregatesFilter<"RealTimeNotification"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"RealTimeNotification"> | Date | string | null
  }

  export type AIContentLogWhereInput = {
    AND?: AIContentLogWhereInput | AIContentLogWhereInput[]
    OR?: AIContentLogWhereInput[]
    NOT?: AIContentLogWhereInput | AIContentLogWhereInput[]
    id?: UuidFilter<"AIContentLog"> | string
    prompt?: StringFilter<"AIContentLog"> | string
    response?: StringFilter<"AIContentLog"> | string
    model?: StringFilter<"AIContentLog"> | string
    tokensUsed?: IntFilter<"AIContentLog"> | number
    cost?: DecimalNullableFilter<"AIContentLog"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntNullableFilter<"AIContentLog"> | number | null
    status?: StringFilter<"AIContentLog"> | string
    error?: StringNullableFilter<"AIContentLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AIContentLog"> | Date | string | null
  }

  export type AIContentLogOrderByWithRelationInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type AIContentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIContentLogWhereInput | AIContentLogWhereInput[]
    OR?: AIContentLogWhereInput[]
    NOT?: AIContentLogWhereInput | AIContentLogWhereInput[]
    prompt?: StringFilter<"AIContentLog"> | string
    response?: StringFilter<"AIContentLog"> | string
    model?: StringFilter<"AIContentLog"> | string
    tokensUsed?: IntFilter<"AIContentLog"> | number
    cost?: DecimalNullableFilter<"AIContentLog"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntNullableFilter<"AIContentLog"> | number | null
    status?: StringFilter<"AIContentLog"> | string
    error?: StringNullableFilter<"AIContentLog"> | string | null
    createdAt?: DateTimeNullableFilter<"AIContentLog"> | Date | string | null
  }, "id">

  export type AIContentLogOrderByWithAggregationInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AIContentLogCountOrderByAggregateInput
    _avg?: AIContentLogAvgOrderByAggregateInput
    _max?: AIContentLogMaxOrderByAggregateInput
    _min?: AIContentLogMinOrderByAggregateInput
    _sum?: AIContentLogSumOrderByAggregateInput
  }

  export type AIContentLogScalarWhereWithAggregatesInput = {
    AND?: AIContentLogScalarWhereWithAggregatesInput | AIContentLogScalarWhereWithAggregatesInput[]
    OR?: AIContentLogScalarWhereWithAggregatesInput[]
    NOT?: AIContentLogScalarWhereWithAggregatesInput | AIContentLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIContentLog"> | string
    prompt?: StringWithAggregatesFilter<"AIContentLog"> | string
    response?: StringWithAggregatesFilter<"AIContentLog"> | string
    model?: StringWithAggregatesFilter<"AIContentLog"> | string
    tokensUsed?: IntWithAggregatesFilter<"AIContentLog"> | number
    cost?: DecimalNullableWithAggregatesFilter<"AIContentLog"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntNullableWithAggregatesFilter<"AIContentLog"> | number | null
    status?: StringWithAggregatesFilter<"AIContentLog"> | string
    error?: StringNullableWithAggregatesFilter<"AIContentLog"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AIContentLog"> | Date | string | null
  }

  export type BulkImportWhereInput = {
    AND?: BulkImportWhereInput | BulkImportWhereInput[]
    OR?: BulkImportWhereInput[]
    NOT?: BulkImportWhereInput | BulkImportWhereInput[]
    id?: UuidFilter<"BulkImport"> | string
    filename?: StringFilter<"BulkImport"> | string
    status?: StringFilter<"BulkImport"> | string
    totalRows?: IntFilter<"BulkImport"> | number
    processedRows?: IntFilter<"BulkImport"> | number
    errorRows?: IntFilter<"BulkImport"> | number
    errors?: JsonNullableFilter<"BulkImport">
    createdAt?: DateTimeNullableFilter<"BulkImport"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BulkImport"> | Date | string | null
  }

  export type BulkImportOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
    errors?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type BulkImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BulkImportWhereInput | BulkImportWhereInput[]
    OR?: BulkImportWhereInput[]
    NOT?: BulkImportWhereInput | BulkImportWhereInput[]
    filename?: StringFilter<"BulkImport"> | string
    status?: StringFilter<"BulkImport"> | string
    totalRows?: IntFilter<"BulkImport"> | number
    processedRows?: IntFilter<"BulkImport"> | number
    errorRows?: IntFilter<"BulkImport"> | number
    errors?: JsonNullableFilter<"BulkImport">
    createdAt?: DateTimeNullableFilter<"BulkImport"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BulkImport"> | Date | string | null
  }, "id">

  export type BulkImportOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
    errors?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: BulkImportCountOrderByAggregateInput
    _avg?: BulkImportAvgOrderByAggregateInput
    _max?: BulkImportMaxOrderByAggregateInput
    _min?: BulkImportMinOrderByAggregateInput
    _sum?: BulkImportSumOrderByAggregateInput
  }

  export type BulkImportScalarWhereWithAggregatesInput = {
    AND?: BulkImportScalarWhereWithAggregatesInput | BulkImportScalarWhereWithAggregatesInput[]
    OR?: BulkImportScalarWhereWithAggregatesInput[]
    NOT?: BulkImportScalarWhereWithAggregatesInput | BulkImportScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BulkImport"> | string
    filename?: StringWithAggregatesFilter<"BulkImport"> | string
    status?: StringWithAggregatesFilter<"BulkImport"> | string
    totalRows?: IntWithAggregatesFilter<"BulkImport"> | number
    processedRows?: IntWithAggregatesFilter<"BulkImport"> | number
    errorRows?: IntWithAggregatesFilter<"BulkImport"> | number
    errors?: JsonNullableWithAggregatesFilter<"BulkImport">
    createdAt?: DateTimeNullableWithAggregatesFilter<"BulkImport"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"BulkImport"> | Date | string | null
  }

  export type MakeWebhookWhereInput = {
    AND?: MakeWebhookWhereInput | MakeWebhookWhereInput[]
    OR?: MakeWebhookWhereInput[]
    NOT?: MakeWebhookWhereInput | MakeWebhookWhereInput[]
    id?: UuidFilter<"MakeWebhook"> | string
    name?: StringFilter<"MakeWebhook"> | string
    url?: StringFilter<"MakeWebhook"> | string
    secret?: StringFilter<"MakeWebhook"> | string
    isActive?: BoolFilter<"MakeWebhook"> | boolean
    events?: JsonNullableFilter<"MakeWebhook">
    createdAt?: DateTimeNullableFilter<"MakeWebhook"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MakeWebhook"> | Date | string | null
  }

  export type MakeWebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type MakeWebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MakeWebhookWhereInput | MakeWebhookWhereInput[]
    OR?: MakeWebhookWhereInput[]
    NOT?: MakeWebhookWhereInput | MakeWebhookWhereInput[]
    name?: StringFilter<"MakeWebhook"> | string
    url?: StringFilter<"MakeWebhook"> | string
    secret?: StringFilter<"MakeWebhook"> | string
    isActive?: BoolFilter<"MakeWebhook"> | boolean
    events?: JsonNullableFilter<"MakeWebhook">
    createdAt?: DateTimeNullableFilter<"MakeWebhook"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MakeWebhook"> | Date | string | null
  }, "id">

  export type MakeWebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MakeWebhookCountOrderByAggregateInput
    _max?: MakeWebhookMaxOrderByAggregateInput
    _min?: MakeWebhookMinOrderByAggregateInput
  }

  export type MakeWebhookScalarWhereWithAggregatesInput = {
    AND?: MakeWebhookScalarWhereWithAggregatesInput | MakeWebhookScalarWhereWithAggregatesInput[]
    OR?: MakeWebhookScalarWhereWithAggregatesInput[]
    NOT?: MakeWebhookScalarWhereWithAggregatesInput | MakeWebhookScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MakeWebhook"> | string
    name?: StringWithAggregatesFilter<"MakeWebhook"> | string
    url?: StringWithAggregatesFilter<"MakeWebhook"> | string
    secret?: StringWithAggregatesFilter<"MakeWebhook"> | string
    isActive?: BoolWithAggregatesFilter<"MakeWebhook"> | boolean
    events?: JsonNullableWithAggregatesFilter<"MakeWebhook">
    createdAt?: DateTimeNullableWithAggregatesFilter<"MakeWebhook"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MakeWebhook"> | Date | string | null
  }

  export type CookieConsentWhereInput = {
    AND?: CookieConsentWhereInput | CookieConsentWhereInput[]
    OR?: CookieConsentWhereInput[]
    NOT?: CookieConsentWhereInput | CookieConsentWhereInput[]
    id?: UuidFilter<"CookieConsent"> | string
    sessionId?: StringFilter<"CookieConsent"> | string
    preferences?: JsonFilter<"CookieConsent">
    consentedAt?: DateTimeNullableFilter<"CookieConsent"> | Date | string | null
  }

  export type CookieConsentOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    preferences?: SortOrder
    consentedAt?: SortOrderInput | SortOrder
  }

  export type CookieConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CookieConsentWhereInput | CookieConsentWhereInput[]
    OR?: CookieConsentWhereInput[]
    NOT?: CookieConsentWhereInput | CookieConsentWhereInput[]
    sessionId?: StringFilter<"CookieConsent"> | string
    preferences?: JsonFilter<"CookieConsent">
    consentedAt?: DateTimeNullableFilter<"CookieConsent"> | Date | string | null
  }, "id">

  export type CookieConsentOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    preferences?: SortOrder
    consentedAt?: SortOrderInput | SortOrder
    _count?: CookieConsentCountOrderByAggregateInput
    _max?: CookieConsentMaxOrderByAggregateInput
    _min?: CookieConsentMinOrderByAggregateInput
  }

  export type CookieConsentScalarWhereWithAggregatesInput = {
    AND?: CookieConsentScalarWhereWithAggregatesInput | CookieConsentScalarWhereWithAggregatesInput[]
    OR?: CookieConsentScalarWhereWithAggregatesInput[]
    NOT?: CookieConsentScalarWhereWithAggregatesInput | CookieConsentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CookieConsent"> | string
    sessionId?: StringWithAggregatesFilter<"CookieConsent"> | string
    preferences?: JsonWithAggregatesFilter<"CookieConsent">
    consentedAt?: DateTimeNullableWithAggregatesFilter<"CookieConsent"> | Date | string | null
  }

  export type AdSpaceWhereInput = {
    AND?: AdSpaceWhereInput | AdSpaceWhereInput[]
    OR?: AdSpaceWhereInput[]
    NOT?: AdSpaceWhereInput | AdSpaceWhereInput[]
    id?: UuidFilter<"AdSpace"> | string
    name?: StringFilter<"AdSpace"> | string
    location?: StringFilter<"AdSpace"> | string
    adType?: StringFilter<"AdSpace"> | string
    isActive?: BoolFilter<"AdSpace"> | boolean
    adCode?: StringNullableFilter<"AdSpace"> | string | null
    dimensions?: JsonNullableFilter<"AdSpace">
    createdAt?: DateTimeNullableFilter<"AdSpace"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AdSpace"> | Date | string | null
  }

  export type AdSpaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    adType?: SortOrder
    isActive?: SortOrder
    adCode?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type AdSpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdSpaceWhereInput | AdSpaceWhereInput[]
    OR?: AdSpaceWhereInput[]
    NOT?: AdSpaceWhereInput | AdSpaceWhereInput[]
    name?: StringFilter<"AdSpace"> | string
    location?: StringFilter<"AdSpace"> | string
    adType?: StringFilter<"AdSpace"> | string
    isActive?: BoolFilter<"AdSpace"> | boolean
    adCode?: StringNullableFilter<"AdSpace"> | string | null
    dimensions?: JsonNullableFilter<"AdSpace">
    createdAt?: DateTimeNullableFilter<"AdSpace"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AdSpace"> | Date | string | null
  }, "id">

  export type AdSpaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    adType?: SortOrder
    isActive?: SortOrder
    adCode?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AdSpaceCountOrderByAggregateInput
    _max?: AdSpaceMaxOrderByAggregateInput
    _min?: AdSpaceMinOrderByAggregateInput
  }

  export type AdSpaceScalarWhereWithAggregatesInput = {
    AND?: AdSpaceScalarWhereWithAggregatesInput | AdSpaceScalarWhereWithAggregatesInput[]
    OR?: AdSpaceScalarWhereWithAggregatesInput[]
    NOT?: AdSpaceScalarWhereWithAggregatesInput | AdSpaceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdSpace"> | string
    name?: StringWithAggregatesFilter<"AdSpace"> | string
    location?: StringWithAggregatesFilter<"AdSpace"> | string
    adType?: StringWithAggregatesFilter<"AdSpace"> | string
    isActive?: BoolWithAggregatesFilter<"AdSpace"> | boolean
    adCode?: StringNullableWithAggregatesFilter<"AdSpace"> | string | null
    dimensions?: JsonNullableWithAggregatesFilter<"AdSpace">
    createdAt?: DateTimeNullableWithAggregatesFilter<"AdSpace"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AdSpace"> | Date | string | null
  }

  export type CustomNicheWhereInput = {
    AND?: CustomNicheWhereInput | CustomNicheWhereInput[]
    OR?: CustomNicheWhereInput[]
    NOT?: CustomNicheWhereInput | CustomNicheWhereInput[]
    id?: UuidFilter<"CustomNiche"> | string
    name?: StringFilter<"CustomNiche"> | string
    description?: StringNullableFilter<"CustomNiche"> | string | null
    keywords?: JsonNullableFilter<"CustomNiche">
    categories?: JsonNullableFilter<"CustomNiche">
    targetAudience?: StringNullableFilter<"CustomNiche"> | string | null
    competitionLevel?: StringNullableFilter<"CustomNiche"> | string | null
    profitabilityScore?: IntNullableFilter<"CustomNiche"> | number | null
    isActive?: BoolFilter<"CustomNiche"> | boolean
    createdAt?: DateTimeNullableFilter<"CustomNiche"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomNiche"> | Date | string | null
    sites?: SiteListRelationFilter
  }

  export type CustomNicheOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    competitionLevel?: SortOrderInput | SortOrder
    profitabilityScore?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    sites?: SiteOrderByRelationAggregateInput
  }

  export type CustomNicheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomNicheWhereInput | CustomNicheWhereInput[]
    OR?: CustomNicheWhereInput[]
    NOT?: CustomNicheWhereInput | CustomNicheWhereInput[]
    name?: StringFilter<"CustomNiche"> | string
    description?: StringNullableFilter<"CustomNiche"> | string | null
    keywords?: JsonNullableFilter<"CustomNiche">
    categories?: JsonNullableFilter<"CustomNiche">
    targetAudience?: StringNullableFilter<"CustomNiche"> | string | null
    competitionLevel?: StringNullableFilter<"CustomNiche"> | string | null
    profitabilityScore?: IntNullableFilter<"CustomNiche"> | number | null
    isActive?: BoolFilter<"CustomNiche"> | boolean
    createdAt?: DateTimeNullableFilter<"CustomNiche"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomNiche"> | Date | string | null
    sites?: SiteListRelationFilter
  }, "id">

  export type CustomNicheOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    competitionLevel?: SortOrderInput | SortOrder
    profitabilityScore?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CustomNicheCountOrderByAggregateInput
    _avg?: CustomNicheAvgOrderByAggregateInput
    _max?: CustomNicheMaxOrderByAggregateInput
    _min?: CustomNicheMinOrderByAggregateInput
    _sum?: CustomNicheSumOrderByAggregateInput
  }

  export type CustomNicheScalarWhereWithAggregatesInput = {
    AND?: CustomNicheScalarWhereWithAggregatesInput | CustomNicheScalarWhereWithAggregatesInput[]
    OR?: CustomNicheScalarWhereWithAggregatesInput[]
    NOT?: CustomNicheScalarWhereWithAggregatesInput | CustomNicheScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CustomNiche"> | string
    name?: StringWithAggregatesFilter<"CustomNiche"> | string
    description?: StringNullableWithAggregatesFilter<"CustomNiche"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"CustomNiche">
    categories?: JsonNullableWithAggregatesFilter<"CustomNiche">
    targetAudience?: StringNullableWithAggregatesFilter<"CustomNiche"> | string | null
    competitionLevel?: StringNullableWithAggregatesFilter<"CustomNiche"> | string | null
    profitabilityScore?: IntNullableWithAggregatesFilter<"CustomNiche"> | number | null
    isActive?: BoolWithAggregatesFilter<"CustomNiche"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"CustomNiche"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CustomNiche"> | Date | string | null
  }

  export type AutoBlogPostWhereInput = {
    AND?: AutoBlogPostWhereInput | AutoBlogPostWhereInput[]
    OR?: AutoBlogPostWhereInput[]
    NOT?: AutoBlogPostWhereInput | AutoBlogPostWhereInput[]
    id?: UuidFilter<"AutoBlogPost"> | string
    siteId?: UuidFilter<"AutoBlogPost"> | string
    title?: StringFilter<"AutoBlogPost"> | string
    content?: StringFilter<"AutoBlogPost"> | string
    summary?: StringNullableFilter<"AutoBlogPost"> | string | null
    keyTakeaways?: JsonNullableFilter<"AutoBlogPost">
    featuredImage?: StringNullableFilter<"AutoBlogPost"> | string | null
    status?: StringFilter<"AutoBlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    seoData?: JsonNullableFilter<"AutoBlogPost">
    tags?: JsonNullableFilter<"AutoBlogPost">
    category?: StringNullableFilter<"AutoBlogPost"> | string | null
    postType?: StringFilter<"AutoBlogPost"> | string
    wordCount?: IntNullableFilter<"AutoBlogPost"> | number | null
    readingTime?: IntNullableFilter<"AutoBlogPost"> | number | null
    affiliateLinks?: JsonNullableFilter<"AutoBlogPost">
    internalLinks?: JsonNullableFilter<"AutoBlogPost">
    externalLinks?: JsonNullableFilter<"AutoBlogPost">
    aiProvider?: StringNullableFilter<"AutoBlogPost"> | string | null
    generationCost?: DecimalNullableFilter<"AutoBlogPost"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type AutoBlogPostOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    keyTakeaways?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    seoData?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    postType?: SortOrder
    wordCount?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    affiliateLinks?: SortOrderInput | SortOrder
    internalLinks?: SortOrderInput | SortOrder
    externalLinks?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    generationCost?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    site?: SiteOrderByWithRelationInput
  }

  export type AutoBlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoBlogPostWhereInput | AutoBlogPostWhereInput[]
    OR?: AutoBlogPostWhereInput[]
    NOT?: AutoBlogPostWhereInput | AutoBlogPostWhereInput[]
    siteId?: UuidFilter<"AutoBlogPost"> | string
    title?: StringFilter<"AutoBlogPost"> | string
    content?: StringFilter<"AutoBlogPost"> | string
    summary?: StringNullableFilter<"AutoBlogPost"> | string | null
    keyTakeaways?: JsonNullableFilter<"AutoBlogPost">
    featuredImage?: StringNullableFilter<"AutoBlogPost"> | string | null
    status?: StringFilter<"AutoBlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    seoData?: JsonNullableFilter<"AutoBlogPost">
    tags?: JsonNullableFilter<"AutoBlogPost">
    category?: StringNullableFilter<"AutoBlogPost"> | string | null
    postType?: StringFilter<"AutoBlogPost"> | string
    wordCount?: IntNullableFilter<"AutoBlogPost"> | number | null
    readingTime?: IntNullableFilter<"AutoBlogPost"> | number | null
    affiliateLinks?: JsonNullableFilter<"AutoBlogPost">
    internalLinks?: JsonNullableFilter<"AutoBlogPost">
    externalLinks?: JsonNullableFilter<"AutoBlogPost">
    aiProvider?: StringNullableFilter<"AutoBlogPost"> | string | null
    generationCost?: DecimalNullableFilter<"AutoBlogPost"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type AutoBlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    keyTakeaways?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    seoData?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    postType?: SortOrder
    wordCount?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    affiliateLinks?: SortOrderInput | SortOrder
    internalLinks?: SortOrderInput | SortOrder
    externalLinks?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    generationCost?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AutoBlogPostCountOrderByAggregateInput
    _avg?: AutoBlogPostAvgOrderByAggregateInput
    _max?: AutoBlogPostMaxOrderByAggregateInput
    _min?: AutoBlogPostMinOrderByAggregateInput
    _sum?: AutoBlogPostSumOrderByAggregateInput
  }

  export type AutoBlogPostScalarWhereWithAggregatesInput = {
    AND?: AutoBlogPostScalarWhereWithAggregatesInput | AutoBlogPostScalarWhereWithAggregatesInput[]
    OR?: AutoBlogPostScalarWhereWithAggregatesInput[]
    NOT?: AutoBlogPostScalarWhereWithAggregatesInput | AutoBlogPostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AutoBlogPost"> | string
    siteId?: UuidWithAggregatesFilter<"AutoBlogPost"> | string
    title?: StringWithAggregatesFilter<"AutoBlogPost"> | string
    content?: StringWithAggregatesFilter<"AutoBlogPost"> | string
    summary?: StringNullableWithAggregatesFilter<"AutoBlogPost"> | string | null
    keyTakeaways?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    featuredImage?: StringNullableWithAggregatesFilter<"AutoBlogPost"> | string | null
    status?: StringWithAggregatesFilter<"AutoBlogPost"> | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AutoBlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"AutoBlogPost"> | Date | string | null
    seoData?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    tags?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    category?: StringNullableWithAggregatesFilter<"AutoBlogPost"> | string | null
    postType?: StringWithAggregatesFilter<"AutoBlogPost"> | string
    wordCount?: IntNullableWithAggregatesFilter<"AutoBlogPost"> | number | null
    readingTime?: IntNullableWithAggregatesFilter<"AutoBlogPost"> | number | null
    affiliateLinks?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    internalLinks?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    externalLinks?: JsonNullableWithAggregatesFilter<"AutoBlogPost">
    aiProvider?: StringNullableWithAggregatesFilter<"AutoBlogPost"> | string | null
    generationCost?: DecimalNullableWithAggregatesFilter<"AutoBlogPost"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AutoBlogPost"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AutoBlogPost"> | Date | string | null
  }

  export type ContentScheduleWhereInput = {
    AND?: ContentScheduleWhereInput | ContentScheduleWhereInput[]
    OR?: ContentScheduleWhereInput[]
    NOT?: ContentScheduleWhereInput | ContentScheduleWhereInput[]
    id?: UuidFilter<"ContentSchedule"> | string
    siteId?: UuidFilter<"ContentSchedule"> | string
    name?: StringFilter<"ContentSchedule"> | string
    description?: StringNullableFilter<"ContentSchedule"> | string | null
    frequency?: StringFilter<"ContentSchedule"> | string
    interval?: IntFilter<"ContentSchedule"> | number
    postTypes?: JsonFilter<"ContentSchedule">
    categories?: JsonFilter<"ContentSchedule">
    keywords?: JsonFilter<"ContentSchedule">
    isActive?: BoolFilter<"ContentSchedule"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type ContentScheduleOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    postTypes?: SortOrder
    categories?: SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    site?: SiteOrderByWithRelationInput
  }

  export type ContentScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentScheduleWhereInput | ContentScheduleWhereInput[]
    OR?: ContentScheduleWhereInput[]
    NOT?: ContentScheduleWhereInput | ContentScheduleWhereInput[]
    siteId?: UuidFilter<"ContentSchedule"> | string
    name?: StringFilter<"ContentSchedule"> | string
    description?: StringNullableFilter<"ContentSchedule"> | string | null
    frequency?: StringFilter<"ContentSchedule"> | string
    interval?: IntFilter<"ContentSchedule"> | number
    postTypes?: JsonFilter<"ContentSchedule">
    categories?: JsonFilter<"ContentSchedule">
    keywords?: JsonFilter<"ContentSchedule">
    isActive?: BoolFilter<"ContentSchedule"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type ContentScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    postTypes?: SortOrder
    categories?: SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ContentScheduleCountOrderByAggregateInput
    _avg?: ContentScheduleAvgOrderByAggregateInput
    _max?: ContentScheduleMaxOrderByAggregateInput
    _min?: ContentScheduleMinOrderByAggregateInput
    _sum?: ContentScheduleSumOrderByAggregateInput
  }

  export type ContentScheduleScalarWhereWithAggregatesInput = {
    AND?: ContentScheduleScalarWhereWithAggregatesInput | ContentScheduleScalarWhereWithAggregatesInput[]
    OR?: ContentScheduleScalarWhereWithAggregatesInput[]
    NOT?: ContentScheduleScalarWhereWithAggregatesInput | ContentScheduleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContentSchedule"> | string
    siteId?: UuidWithAggregatesFilter<"ContentSchedule"> | string
    name?: StringWithAggregatesFilter<"ContentSchedule"> | string
    description?: StringNullableWithAggregatesFilter<"ContentSchedule"> | string | null
    frequency?: StringWithAggregatesFilter<"ContentSchedule"> | string
    interval?: IntWithAggregatesFilter<"ContentSchedule"> | number
    postTypes?: JsonWithAggregatesFilter<"ContentSchedule">
    categories?: JsonWithAggregatesFilter<"ContentSchedule">
    keywords?: JsonWithAggregatesFilter<"ContentSchedule">
    isActive?: BoolWithAggregatesFilter<"ContentSchedule"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"ContentSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"ContentSchedule"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ContentSchedule"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ContentSchedule"> | Date | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: UuidFilter<"ProductCategory"> | string
    siteId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
    displayOrder?: IntFilter<"ProductCategory"> | number
    isActive?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
    seoKeywords?: StringNullableFilter<"ProductCategory"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    products?: SiteProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    seoKeywords?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parent?: ProductCategoryOrderByWithRelationInput
    children?: ProductCategoryOrderByRelationAggregateInput
    site?: SiteOrderByWithRelationInput
    products?: SiteProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    siteId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
    displayOrder?: IntFilter<"ProductCategory"> | number
    isActive?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
    seoKeywords?: StringNullableFilter<"ProductCategory"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    products?: SiteProductListRelationFilter
  }, "id" | "slug">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    seoKeywords?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductCategory"> | string
    siteId?: UuidWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    slug?: StringWithAggregatesFilter<"ProductCategory"> | string
    parentId?: UuidNullableWithAggregatesFilter<"ProductCategory"> | string | null
    displayOrder?: IntWithAggregatesFilter<"ProductCategory"> | number
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    seoKeywords?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ProductCategory"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductCategory"> | Date | string | null
  }

  export type ContentCreateInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
  }

  export type ContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentTypeCreateInput = {
    name: string
    description?: string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    content?: ContentCreateNestedManyWithoutContentTypeInput
  }

  export type ContentTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    content?: ContentUncheckedCreateNestedManyWithoutContentTypeInput
  }

  export type ContentTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentUpdateManyWithoutContentTypeNestedInput
  }

  export type ContentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentUncheckedUpdateManyWithoutContentTypeNestedInput
  }

  export type ContentTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    content?: ContentCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    parentId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    content?: ContentCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    content?: ContentCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    content?: ContentCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    parentId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentCategoryCreateInput = {
    category: CategoryCreateNestedOneWithoutContentInput
    content: ContentCreateNestedOneWithoutCategoriesInput
  }

  export type ContentCategoryUncheckedCreateInput = {
    contentId: string
    categoryId: number
  }

  export type ContentCategoryUpdateInput = {
    category?: CategoryUpdateOneRequiredWithoutContentNestedInput
    content?: ContentUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ContentCategoryUncheckedUpdateInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCategoryCreateManyInput = {
    contentId: string
    categoryId: number
  }

  export type ContentCategoryUpdateManyMutationInput = {

  }

  export type ContentCategoryUncheckedUpdateManyInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    content?: ContentTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    content?: ContentTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentTagCreateInput = {
    content: ContentCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutContentInput
  }

  export type ContentTagUncheckedCreateInput = {
    contentId: string
    tagId: number
  }

  export type ContentTagUpdateInput = {
    content?: ContentUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutContentNestedInput
  }

  export type ContentTagUncheckedUpdateInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagCreateManyInput = {
    contentId: string
    tagId: number
  }

  export type ContentTagUpdateManyMutationInput = {

  }

  export type ContentTagUncheckedUpdateManyInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type SiteCreateInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateManyInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteContentCreateInput = {
    content: ContentCreateNestedOneWithoutSiteContentInput
    site: SiteCreateNestedOneWithoutContentInput
  }

  export type SiteContentUncheckedCreateInput = {
    siteId: string
    contentId: string
  }

  export type SiteContentUpdateInput = {
    content?: ContentUpdateOneRequiredWithoutSiteContentNestedInput
    site?: SiteUpdateOneRequiredWithoutContentNestedInput
  }

  export type SiteContentUncheckedUpdateInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteContentCreateManyInput = {
    siteId: string
    contentId: string
  }

  export type SiteContentUpdateManyMutationInput = {

  }

  export type SiteContentUncheckedUpdateManyInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAssetCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    siteMedia?: SiteMediaCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    siteMedia?: SiteMediaUncheckedCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    siteMedia?: SiteMediaUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    siteMedia?: SiteMediaUncheckedUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MediaAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteMediaCreateInput = {
    content: ContentCreateNestedOneWithoutMediaInput
    mediaAsset: MediaAssetCreateNestedOneWithoutSiteMediaInput
    site: SiteCreateNestedOneWithoutMediaInput
  }

  export type SiteMediaUncheckedCreateInput = {
    siteId: string
    contentId: string
    mediaAssetId: string
  }

  export type SiteMediaUpdateInput = {
    content?: ContentUpdateOneRequiredWithoutMediaNestedInput
    mediaAsset?: MediaAssetUpdateOneRequiredWithoutSiteMediaNestedInput
    site?: SiteUpdateOneRequiredWithoutMediaNestedInput
  }

  export type SiteMediaUncheckedUpdateInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaCreateManyInput = {
    siteId: string
    contentId: string
    mediaAssetId: string
  }

  export type SiteMediaUpdateManyMutationInput = {

  }

  export type SiteMediaUncheckedUpdateManyInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryUncheckedCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteProductCreateInput = {
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSiteProductsInput
    site: SiteCreateNestedOneWithoutProductsInput
  }

  export type SiteProductUncheckedCreateInput = {
    siteId: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type SiteProductUpdateInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSiteProductsNestedInput
    site?: SiteUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SiteProductUncheckedUpdateInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteProductCreateManyInput = {
    siteId: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type SiteProductUpdateManyMutationInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteProductUncheckedUpdateManyInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCustomFieldCreateInput = {
    id?: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCustomFieldsInput
    site: SiteCreateNestedOneWithoutCustomFieldsInput
  }

  export type ProductCustomFieldUncheckedCreateInput = {
    id?: string
    productId: string
    siteId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCustomFieldsNestedInput
    site?: SiteUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type ProductCustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldCreateManyInput = {
    id?: string
    productId: string
    siteId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryCreateInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutPriceHistoryInput
  }

  export type ProductPriceHistoryUncheckedCreateInput = {
    id?: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
  }

  export type ProductPriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type ProductPriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryCreateManyInput = {
    id?: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
  }

  export type ProductPriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertCreateInput = {
    id?: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
    site: SiteCreateNestedOneWithoutPriceAlertsInput
  }

  export type PriceAlertUncheckedCreateInput = {
    id?: string
    siteId: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
  }

  export type PriceAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutPriceAlertsNestedInput
  }

  export type PriceAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertCreateManyInput = {
    id?: string
    siteId: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
  }

  export type PriceAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InteractiveQuizCreateInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    results?: QuizResultCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizUncheckedCreateInput = {
    id?: string
    siteId: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    results?: QuizResultUncheckedCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    results?: QuizResultUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    results?: QuizResultUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizCreateManyInput = {
    id?: string
    siteId: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InteractiveQuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InteractiveQuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionCreateInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    options?: QuizQuestionOptionCreateNestedManyWithoutQuestionInput
    quiz: InteractiveQuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    quizId: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: QuizQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    options?: QuizQuestionOptionUpdateManyWithoutQuestionNestedInput
    quiz?: InteractiveQuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: QuizQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    quizId: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionCreateInput = {
    id?: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
    question: QuizQuestionCreateNestedOneWithoutOptionsInput
  }

  export type QuizQuestionOptionUncheckedCreateInput = {
    id?: string
    questionId: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
  }

  export type QuizQuestionOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type QuizQuestionOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionCreateManyInput = {
    id?: string
    questionId: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
  }

  export type QuizQuestionOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizResultCreateInput = {
    id?: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    quizAnswers?: QuizAnswerCreateNestedManyWithoutResultInput
    quiz: InteractiveQuizCreateNestedOneWithoutResultsInput
  }

  export type QuizResultUncheckedCreateInput = {
    id?: string
    quizId: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutResultInput
  }

  export type QuizResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAnswers?: QuizAnswerUpdateManyWithoutResultNestedInput
    quiz?: InteractiveQuizUpdateOneRequiredWithoutResultsNestedInput
  }

  export type QuizResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutResultNestedInput
  }

  export type QuizResultCreateManyInput = {
    id?: string
    quizId: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
  }

  export type QuizResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateInput = {
    id?: string
    answer: string
    createdAt?: Date | string | null
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
    result: QuizResultCreateNestedOneWithoutQuizAnswersInput
  }

  export type QuizAnswerUncheckedCreateInput = {
    id?: string
    resultId: string
    questionId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
    result?: QuizResultUpdateOneRequiredWithoutQuizAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateManyInput = {
    id?: string
    resultId: string
    questionId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateLinkCreateInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    merchant?: MerchantCreateNestedOneWithoutAffiliateLinksInput
    product?: ProductCreateNestedOneWithoutAffiliateLinksInput
    site: SiteCreateNestedOneWithoutAffiliateLinksInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneWithoutAffiliateLinksNestedInput
    product?: ProductUpdateOneWithoutAffiliateLinksNestedInput
    site?: SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkCreateManyInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
  }

  export type AffiliateLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MerchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LinkClickCreateInput = {
    id?: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
    affiliateLink: AffiliateLinkCreateNestedOneWithoutLinkClicksInput
  }

  export type LinkClickUncheckedCreateInput = {
    id?: string
    affiliateLinkId: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    affiliateLink?: AffiliateLinkUpdateOneRequiredWithoutLinkClicksNestedInput
  }

  export type LinkClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateLinkId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickCreateManyInput = {
    id?: string
    affiliateLinkId: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateLinkId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ConversionCreateInput = {
    id?: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
    affiliateLink: AffiliateLinkCreateNestedOneWithoutConversionsInput
  }

  export type ConversionUncheckedCreateInput = {
    id?: string
    affiliateLinkId: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type ConversionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateLink?: AffiliateLinkUpdateOneRequiredWithoutConversionsNestedInput
  }

  export type ConversionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateLinkId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversionCreateManyInput = {
    id?: string
    affiliateLinkId: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type ConversionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateLinkId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    userId: string
    siteId?: string | null
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: number
    siteId?: string | null
  }

  export type UserRoleUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: number
    siteId?: string | null
  }

  export type UserRoleUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    tableName: string
    recordId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    tableName: string
    recordId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    tableName: string
    recordId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriberCreateInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    isActive?: boolean
    subscribedAt?: Date | string | null
    unsubscribedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterSubscriberUncheckedCreateInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    isActive?: boolean
    subscribedAt?: Date | string | null
    unsubscribedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterSubscriberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriberCreateManyInput = {
    id?: string
    email: string
    firstName?: string | null
    lastName?: string | null
    isActive?: boolean
    subscribedAt?: Date | string | null
    unsubscribedAt?: Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterSubscriberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterSubscriberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCampaignCreateInput = {
    id?: string
    name: string
    subject: string
    content: string
    status?: string
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterCampaignUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    content: string
    status?: string
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCampaignCreateManyInput = {
    id?: string
    name: string
    subject: string
    content: string
    status?: string
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsletterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsletterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaAccountCreateInput = {
    id?: string
    platform: string
    username: string
    accessToken?: string | null
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaAccountUncheckedCreateInput = {
    id?: string
    platform: string
    username: string
    accessToken?: string | null
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaAccountCreateManyInput = {
    id?: string
    platform: string
    username: string
    accessToken?: string | null
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaPostCreateInput = {
    id?: string
    platform: string
    content: string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    scheduledAt?: Date | string | null
    publishedAt?: Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaPostUncheckedCreateInput = {
    id?: string
    platform: string
    content: string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    scheduledAt?: Date | string | null
    publishedAt?: Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaPostCreateManyInput = {
    id?: string
    platform: string
    content: string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    scheduledAt?: Date | string | null
    publishedAt?: Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SocialMediaPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialMediaPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    affiliateUrl: string
    merchant: string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: boolean
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AffiliateProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    affiliateUrl: string
    merchant: string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: boolean
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AffiliateProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    merchant?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    merchant?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    affiliateUrl: string
    merchant: string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: boolean
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AffiliateProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    merchant?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    merchant?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    availability?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateLinkClickCreateInput = {
    id?: string
    affiliateUrl: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickUncheckedCreateInput = {
    id?: string
    affiliateUrl: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickCreateManyInput = {
    id?: string
    affiliateUrl: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type RecipeCreateInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeIngredientCreateInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateInput = {
    id?: string
    recipeId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
  }

  export type RecipeIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeIngredientCreateManyInput = {
    id?: string
    recipeId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
  }

  export type RecipeIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionCreateInput = {
    id?: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
    recipe: RecipeCreateNestedOneWithoutInstructionsInput
  }

  export type RecipeInstructionUncheckedCreateInput = {
    id?: string
    recipeId: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
  }

  export type RecipeInstructionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipe?: RecipeUpdateOneRequiredWithoutInstructionsNestedInput
  }

  export type RecipeInstructionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionCreateManyInput = {
    id?: string
    recipeId: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
  }

  export type RecipeInstructionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentVersionCreateInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
    content: ContentCreateNestedOneWithoutVersionsInput
  }

  export type ContentVersionUncheckedCreateInput = {
    id?: string
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
  }

  export type ContentVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ContentVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentVersionCreateManyInput = {
    id?: string
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
  }

  export type ContentVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RealTimeNotificationCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string | null
  }

  export type RealTimeNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string | null
  }

  export type RealTimeNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RealTimeNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RealTimeNotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string | null
  }

  export type RealTimeNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RealTimeNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIContentLogCreateInput = {
    id?: string
    prompt: string
    response: string
    model: string
    tokensUsed: number
    cost?: Decimal | DecimalJsLike | number | string | null
    duration?: number | null
    status: string
    error?: string | null
    createdAt?: Date | string | null
  }

  export type AIContentLogUncheckedCreateInput = {
    id?: string
    prompt: string
    response: string
    model: string
    tokensUsed: number
    cost?: Decimal | DecimalJsLike | number | string | null
    duration?: number | null
    status: string
    error?: string | null
    createdAt?: Date | string | null
  }

  export type AIContentLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIContentLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIContentLogCreateManyInput = {
    id?: string
    prompt: string
    response: string
    model: string
    tokensUsed: number
    cost?: Decimal | DecimalJsLike | number | string | null
    duration?: number | null
    status: string
    error?: string | null
    createdAt?: Date | string | null
  }

  export type AIContentLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIContentLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkImportCreateInput = {
    id?: string
    filename: string
    status?: string
    totalRows?: number
    processedRows?: number
    errorRows?: number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BulkImportUncheckedCreateInput = {
    id?: string
    filename: string
    status?: string
    totalRows?: number
    processedRows?: number
    errorRows?: number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BulkImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    errorRows?: IntFieldUpdateOperationsInput | number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    errorRows?: IntFieldUpdateOperationsInput | number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkImportCreateManyInput = {
    id?: string
    filename: string
    status?: string
    totalRows?: number
    processedRows?: number
    errorRows?: number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BulkImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    errorRows?: IntFieldUpdateOperationsInput | number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    errorRows?: IntFieldUpdateOperationsInput | number
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MakeWebhookCreateInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MakeWebhookUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MakeWebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MakeWebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MakeWebhookCreateManyInput = {
    id?: string
    name: string
    url: string
    secret: string
    isActive?: boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MakeWebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MakeWebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CookieConsentCreateInput = {
    id?: string
    sessionId: string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: Date | string | null
  }

  export type CookieConsentUncheckedCreateInput = {
    id?: string
    sessionId: string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: Date | string | null
  }

  export type CookieConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CookieConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CookieConsentCreateManyInput = {
    id?: string
    sessionId: string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: Date | string | null
  }

  export type CookieConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CookieConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdSpaceCreateInput = {
    id?: string
    name: string
    location: string
    adType: string
    isActive?: boolean
    adCode?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AdSpaceUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    adType: string
    isActive?: boolean
    adCode?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AdSpaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    adType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adCode?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdSpaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    adType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adCode?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdSpaceCreateManyInput = {
    id?: string
    name: string
    location: string
    adType: string
    isActive?: boolean
    adCode?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AdSpaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    adType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adCode?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdSpaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    adType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adCode?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomNicheCreateInput = {
    id?: string
    name: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    competitionLevel?: string | null
    profitabilityScore?: number | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sites?: SiteCreateNestedManyWithoutCustomNicheInput
  }

  export type CustomNicheUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    competitionLevel?: string | null
    profitabilityScore?: number | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sites?: SiteUncheckedCreateNestedManyWithoutCustomNicheInput
  }

  export type CustomNicheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sites?: SiteUpdateManyWithoutCustomNicheNestedInput
  }

  export type CustomNicheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sites?: SiteUncheckedUpdateManyWithoutCustomNicheNestedInput
  }

  export type CustomNicheCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    competitionLevel?: string | null
    profitabilityScore?: number | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CustomNicheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomNicheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostCreateInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutAutoBlogPostsInput
  }

  export type AutoBlogPostUncheckedCreateInput = {
    id?: string
    siteId: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AutoBlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutAutoBlogPostsNestedInput
  }

  export type AutoBlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostCreateManyInput = {
    id?: string
    siteId: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AutoBlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleCreateInput = {
    id?: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutContentSchedulesInput
  }

  export type ContentScheduleUncheckedCreateInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutContentSchedulesNestedInput
  }

  export type ContentScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleCreateManyInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    site: SiteCreateNestedOneWithoutProductCategoriesInput
    products?: SiteProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: SiteProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    site?: SiteUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: SiteProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContentTypeScalarRelationFilter = {
    is?: ContentTypeWhereInput
    isNot?: ContentTypeWhereInput
  }

  export type ContentCategoryListRelationFilter = {
    every?: ContentCategoryWhereInput
    some?: ContentCategoryWhereInput
    none?: ContentCategoryWhereInput
  }

  export type ContentTagListRelationFilter = {
    every?: ContentTagWhereInput
    some?: ContentTagWhereInput
    none?: ContentTagWhereInput
  }

  export type ContentVersionListRelationFilter = {
    every?: ContentVersionWhereInput
    some?: ContentVersionWhereInput
    none?: ContentVersionWhereInput
  }

  export type SiteContentListRelationFilter = {
    every?: SiteContentWhereInput
    some?: SiteContentWhereInput
    none?: SiteContentWhereInput
  }

  export type SiteMediaListRelationFilter = {
    every?: SiteMediaWhereInput
    some?: SiteMediaWhereInput
    none?: SiteMediaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContentCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    contentTypeId?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    scheduledPublishAt?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    contentTypeId?: SortOrder
    version?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    contentTypeId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    scheduledPublishAt?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    contentTypeId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    scheduledPublishAt?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    contentTypeId?: SortOrder
    version?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContentListRelationFilter = {
    every?: ContentWhereInput
    some?: ContentWhereInput
    none?: ContentWhereInput
  }

  export type ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schema?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type ContentCategoryContentIdCategoryIdCompoundUniqueInput = {
    contentId: string
    categoryId: number
  }

  export type ContentCategoryCountOrderByAggregateInput = {
    contentId?: SortOrder
    categoryId?: SortOrder
  }

  export type ContentCategoryAvgOrderByAggregateInput = {
    categoryId?: SortOrder
  }

  export type ContentCategoryMaxOrderByAggregateInput = {
    contentId?: SortOrder
    categoryId?: SortOrder
  }

  export type ContentCategoryMinOrderByAggregateInput = {
    contentId?: SortOrder
    categoryId?: SortOrder
  }

  export type ContentCategorySumOrderByAggregateInput = {
    categoryId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ContentTagContentIdTagIdCompoundUniqueInput = {
    contentId: string
    tagId: number
  }

  export type ContentTagCountOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagAvgOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type ContentTagMaxOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagMinOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagSumOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AffiliateLinkListRelationFilter = {
    every?: AffiliateLinkWhereInput
    some?: AffiliateLinkWhereInput
    none?: AffiliateLinkWhereInput
  }

  export type AutoBlogPostListRelationFilter = {
    every?: AutoBlogPostWhereInput
    some?: AutoBlogPostWhereInput
    none?: AutoBlogPostWhereInput
  }

  export type ContentScheduleListRelationFilter = {
    every?: ContentScheduleWhereInput
    some?: ContentScheduleWhereInput
    none?: ContentScheduleWhereInput
  }

  export type InteractiveQuizListRelationFilter = {
    every?: InteractiveQuizWhereInput
    some?: InteractiveQuizWhereInput
    none?: InteractiveQuizWhereInput
  }

  export type PriceAlertListRelationFilter = {
    every?: PriceAlertWhereInput
    some?: PriceAlertWhereInput
    none?: PriceAlertWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductCustomFieldListRelationFilter = {
    every?: ProductCustomFieldWhereInput
    some?: ProductCustomFieldWhereInput
    none?: ProductCustomFieldWhereInput
  }

  export type SiteProductListRelationFilter = {
    every?: SiteProductWhereInput
    some?: SiteProductWhereInput
    none?: SiteProductWhereInput
  }

  export type CustomNicheNullableScalarRelationFilter = {
    is?: CustomNicheWhereInput | null
    isNot?: CustomNicheWhereInput | null
  }

  export type AffiliateLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoBlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractiveQuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    nicheType?: SortOrder
    customNicheId?: SortOrder
    nicheKeywords?: SortOrder
    targetAudience?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    aboutTitle?: SortOrder
    aboutDescription?: SortOrder
    contactEmail?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    featuredPostsTitle?: SortOrder
    featuredPostsSubtitle?: SortOrder
    featuredProductsTitle?: SortOrder
    featuredProductsSubtitle?: SortOrder
    newsletterTitle?: SortOrder
    newsletterSubtitle?: SortOrder
    autoBlogEnabled?: SortOrder
    autoBlogFrequency?: SortOrder
    autoBlogPostTypes?: SortOrder
    autoBlogCategories?: SortOrder
    footerText?: SortOrder
    socialLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    nicheType?: SortOrder
    customNicheId?: SortOrder
    targetAudience?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    aboutTitle?: SortOrder
    aboutDescription?: SortOrder
    contactEmail?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    featuredPostsTitle?: SortOrder
    featuredPostsSubtitle?: SortOrder
    featuredProductsTitle?: SortOrder
    featuredProductsSubtitle?: SortOrder
    newsletterTitle?: SortOrder
    newsletterSubtitle?: SortOrder
    autoBlogEnabled?: SortOrder
    autoBlogFrequency?: SortOrder
    footerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    nicheType?: SortOrder
    customNicheId?: SortOrder
    targetAudience?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    aboutTitle?: SortOrder
    aboutDescription?: SortOrder
    contactEmail?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    featuredPostsTitle?: SortOrder
    featuredPostsSubtitle?: SortOrder
    featuredProductsTitle?: SortOrder
    featuredProductsSubtitle?: SortOrder
    newsletterTitle?: SortOrder
    newsletterSubtitle?: SortOrder
    autoBlogEnabled?: SortOrder
    autoBlogFrequency?: SortOrder
    footerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SiteScalarRelationFilter = {
    is?: SiteWhereInput
    isNot?: SiteWhereInput
  }

  export type SiteContentSiteIdContentIdCompoundUniqueInput = {
    siteId: string
    contentId: string
  }

  export type SiteContentCountOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
  }

  export type SiteContentMaxOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
  }

  export type SiteContentMinOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
  }

  export type MediaAssetCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MediaAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MediaAssetScalarRelationFilter = {
    is?: MediaAssetWhereInput
    isNot?: MediaAssetWhereInput
  }

  export type SiteMediaSiteIdContentIdMediaAssetIdCompoundUniqueInput = {
    siteId: string
    contentId: string
    mediaAssetId: string
  }

  export type SiteMediaCountOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    mediaAssetId?: SortOrder
  }

  export type SiteMediaMaxOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    mediaAssetId?: SortOrder
  }

  export type SiteMediaMinOrderByAggregateInput = {
    siteId?: SortOrder
    contentId?: SortOrder
    mediaAssetId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ProductPriceHistoryListRelationFilter = {
    every?: ProductPriceHistoryWhereInput
    some?: ProductPriceHistoryWhereInput
    none?: ProductPriceHistoryWhereInput
  }

  export type ProductPriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    manufacturer?: SortOrder
    basePrice?: SortOrder
    mainImageUrl?: SortOrder
    specifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    manufacturer?: SortOrder
    basePrice?: SortOrder
    mainImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    manufacturer?: SortOrder
    basePrice?: SortOrder
    mainImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SiteProductSiteIdProductIdCompoundUniqueInput = {
    siteId: string
    productId: string
  }

  export type SiteProductCountOrderByAggregateInput = {
    siteId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    inStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type SiteProductAvgOrderByAggregateInput = {
    price?: SortOrder
    discount?: SortOrder
  }

  export type SiteProductMaxOrderByAggregateInput = {
    siteId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    inStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type SiteProductMinOrderByAggregateInput = {
    siteId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    inStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type SiteProductSumOrderByAggregateInput = {
    price?: SortOrder
    discount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProductCustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    siteId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    displayOrder?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCustomFieldAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ProductCustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    siteId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    displayOrder?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    siteId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    displayOrder?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCustomFieldSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ProductPriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProductPriceHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductPriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProductPriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProductPriceHistorySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceAlertCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    productId?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type PriceAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type PriceAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    productId?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type PriceAlertMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    productId?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type PriceAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizResultListRelationFilter = {
    every?: QuizResultWhereInput
    some?: QuizResultWhereInput
    none?: QuizResultWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractiveQuizCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InteractiveQuizMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InteractiveQuizMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizAnswerListRelationFilter = {
    every?: QuizAnswerWhereInput
    some?: QuizAnswerWhereInput
    none?: QuizAnswerWhereInput
  }

  export type QuizQuestionOptionListRelationFilter = {
    every?: QuizQuestionOptionWhereInput
    some?: QuizQuestionOptionWhereInput
    none?: QuizQuestionOptionWhereInput
  }

  export type InteractiveQuizScalarRelationFilter = {
    is?: InteractiveQuizWhereInput
    isNot?: InteractiveQuizWhereInput
  }

  export type QuizAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuizQuestionScalarRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuizQuestionOptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optionText?: SortOrder
    optionValue?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionOptionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuizQuestionOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optionText?: SortOrder
    optionValue?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionOptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optionText?: SortOrder
    optionValue?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionOptionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuizResultCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sessionId?: SortOrder
    answers?: SortOrder
    recommendations?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizResultMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizResultMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizResultScalarRelationFilter = {
    is?: QuizResultWhereInput
    isNot?: QuizResultWhereInput
  }

  export type QuizAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    resultId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    resultId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    resultId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type MerchantNullableScalarRelationFilter = {
    is?: MerchantWhereInput | null
    isNot?: MerchantWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ConversionListRelationFilter = {
    every?: ConversionWhereInput
    some?: ConversionWhereInput
    none?: ConversionWhereInput
  }

  export type LinkClickListRelationFilter = {
    every?: LinkClickWhereInput
    some?: LinkClickWhereInput
    none?: LinkClickWhereInput
  }

  export type ConversionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkClickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateLinkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalUrl?: SortOrder
    affiliateUrl?: SortOrder
    siteId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    merchantId?: SortOrder
    displayText?: SortOrder
    trackingId?: SortOrder
    status?: SortOrder
    commissionInfo?: SortOrder
    expirationDate?: SortOrder
  }

  export type AffiliateLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalUrl?: SortOrder
    affiliateUrl?: SortOrder
    siteId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    merchantId?: SortOrder
    displayText?: SortOrder
    trackingId?: SortOrder
    status?: SortOrder
    expirationDate?: SortOrder
  }

  export type AffiliateLinkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalUrl?: SortOrder
    affiliateUrl?: SortOrder
    siteId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    merchantId?: SortOrder
    displayText?: SortOrder
    trackingId?: SortOrder
    status?: SortOrder
    expirationDate?: SortOrder
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateLinkScalarRelationFilter = {
    is?: AffiliateLinkWhereInput
    isNot?: AffiliateLinkWhereInput
  }

  export type LinkClickCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionStatus?: SortOrder
    conversionValue?: SortOrder
  }

  export type LinkClickAvgOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type LinkClickMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionStatus?: SortOrder
    conversionValue?: SortOrder
  }

  export type LinkClickMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionStatus?: SortOrder
    conversionValue?: SortOrder
  }

  export type LinkClickSumOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type ConversionCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    orderId?: SortOrder
    orderValue?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    conversionDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ConversionAvgOrderByAggregateInput = {
    orderValue?: SortOrder
    commission?: SortOrder
  }

  export type ConversionMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    orderId?: SortOrder
    orderValue?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    conversionDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ConversionMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateLinkId?: SortOrder
    orderId?: SortOrder
    orderValue?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    conversionDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ConversionSumOrderByAggregateInput = {
    orderValue?: SortOrder
    commission?: SortOrder
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    siteId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    siteId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    siteId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsletterSubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    isActive?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
    preferences?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterSubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    isActive?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterSubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    isActive?: SortOrder
    subscribedAt?: SortOrder
    unsubscribedAt?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterCampaignAvgOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type NewsletterCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterCampaignSumOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type NewsletterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaPostCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    content?: SortOrder
    mediaUrls?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaPostMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaPostMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    content?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    affiliateUrl?: SortOrder
    merchant?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    availability?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProductAvgOrderByAggregateInput = {
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type AffiliateProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    affiliateUrl?: SortOrder
    merchant?: SortOrder
    category?: SortOrder
    availability?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    affiliateUrl?: SortOrder
    merchant?: SortOrder
    category?: SortOrder
    availability?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProductSumOrderByAggregateInput = {
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type AffiliateLinkClickCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateUrl?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionValue?: SortOrder
  }

  export type AffiliateLinkClickAvgOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type AffiliateLinkClickMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateUrl?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionValue?: SortOrder
  }

  export type AffiliateLinkClickMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateUrl?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    clickedAt?: SortOrder
    conversionValue?: SortOrder
  }

  export type AffiliateLinkClickSumOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type RecipeIngredientListRelationFilter = {
    every?: RecipeIngredientWhereInput
    some?: RecipeIngredientWhereInput
    none?: RecipeIngredientWhereInput
  }

  export type RecipeInstructionListRelationFilter = {
    every?: RecipeInstructionWhereInput
    some?: RecipeInstructionWhereInput
    none?: RecipeInstructionWhereInput
  }

  export type RecipeIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeInstructionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prepTime?: SortOrder
    cookTime?: SortOrder
    servings?: SortOrder
    difficulty?: SortOrder
    cuisine?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    prepTime?: SortOrder
    cookTime?: SortOrder
    servings?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prepTime?: SortOrder
    cookTime?: SortOrder
    servings?: SortOrder
    difficulty?: SortOrder
    cuisine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prepTime?: SortOrder
    cookTime?: SortOrder
    servings?: SortOrder
    difficulty?: SortOrder
    cuisine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    prepTime?: SortOrder
    cookTime?: SortOrder
    servings?: SortOrder
  }

  export type RecipeScalarRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type RecipeIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeIngredientAvgOrderByAggregateInput = {
    amount?: SortOrder
    order?: SortOrder
  }

  export type RecipeIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeIngredientSumOrderByAggregateInput = {
    amount?: SortOrder
    order?: SortOrder
  }

  export type RecipeInstructionCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeInstructionAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type RecipeInstructionMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeInstructionMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type RecipeInstructionSumOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type ContentVersionCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ContentVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type RealTimeNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RealTimeNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RealTimeNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type AIContentLogCountOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIContentLogAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
    duration?: SortOrder
  }

  export type AIContentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIContentLogMinOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIContentLogSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
    duration?: SortOrder
  }

  export type BulkImportCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
    errors?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkImportAvgOrderByAggregateInput = {
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
  }

  export type BulkImportMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkImportMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkImportSumOrderByAggregateInput = {
    totalRows?: SortOrder
    processedRows?: SortOrder
    errorRows?: SortOrder
  }

  export type MakeWebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MakeWebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MakeWebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CookieConsentCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    preferences?: SortOrder
    consentedAt?: SortOrder
  }

  export type CookieConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    consentedAt?: SortOrder
  }

  export type CookieConsentMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    consentedAt?: SortOrder
  }

  export type AdSpaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    adType?: SortOrder
    isActive?: SortOrder
    adCode?: SortOrder
    dimensions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    adType?: SortOrder
    isActive?: SortOrder
    adCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSpaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    adType?: SortOrder
    isActive?: SortOrder
    adCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteListRelationFilter = {
    every?: SiteWhereInput
    some?: SiteWhereInput
    none?: SiteWhereInput
  }

  export type SiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomNicheCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    categories?: SortOrder
    targetAudience?: SortOrder
    competitionLevel?: SortOrder
    profitabilityScore?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomNicheAvgOrderByAggregateInput = {
    profitabilityScore?: SortOrder
  }

  export type CustomNicheMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetAudience?: SortOrder
    competitionLevel?: SortOrder
    profitabilityScore?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomNicheMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetAudience?: SortOrder
    competitionLevel?: SortOrder
    profitabilityScore?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomNicheSumOrderByAggregateInput = {
    profitabilityScore?: SortOrder
  }

  export type AutoBlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    keyTakeaways?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    seoData?: SortOrder
    tags?: SortOrder
    category?: SortOrder
    postType?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    affiliateLinks?: SortOrder
    internalLinks?: SortOrder
    externalLinks?: SortOrder
    aiProvider?: SortOrder
    generationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoBlogPostAvgOrderByAggregateInput = {
    wordCount?: SortOrder
    readingTime?: SortOrder
    generationCost?: SortOrder
  }

  export type AutoBlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    category?: SortOrder
    postType?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    aiProvider?: SortOrder
    generationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoBlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    category?: SortOrder
    postType?: SortOrder
    wordCount?: SortOrder
    readingTime?: SortOrder
    aiProvider?: SortOrder
    generationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoBlogPostSumOrderByAggregateInput = {
    wordCount?: SortOrder
    readingTime?: SortOrder
    generationCost?: SortOrder
  }

  export type ContentScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    postTypes?: SortOrder
    categories?: SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentScheduleAvgOrderByAggregateInput = {
    interval?: SortOrder
  }

  export type ContentScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentScheduleSumOrderByAggregateInput = {
    interval?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    seoKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ContentTypeCreateNestedOneWithoutContentInput = {
    create?: XOR<ContentTypeCreateWithoutContentInput, ContentTypeUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentInput
    connect?: ContentTypeWhereUniqueInput
  }

  export type ContentCategoryCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput> | ContentCategoryCreateWithoutContentInput[] | ContentCategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutContentInput | ContentCategoryCreateOrConnectWithoutContentInput[]
    createMany?: ContentCategoryCreateManyContentInputEnvelope
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
  }

  export type ContentTagCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentVersionCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput> | ContentVersionCreateWithoutContentInput[] | ContentVersionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentVersionCreateOrConnectWithoutContentInput | ContentVersionCreateOrConnectWithoutContentInput[]
    createMany?: ContentVersionCreateManyContentInputEnvelope
    connect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
  }

  export type SiteContentCreateNestedManyWithoutContentInput = {
    create?: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput> | SiteContentCreateWithoutContentInput[] | SiteContentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutContentInput | SiteContentCreateOrConnectWithoutContentInput[]
    createMany?: SiteContentCreateManyContentInputEnvelope
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
  }

  export type SiteMediaCreateNestedManyWithoutContentInput = {
    create?: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput> | SiteMediaCreateWithoutContentInput[] | SiteMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutContentInput | SiteMediaCreateOrConnectWithoutContentInput[]
    createMany?: SiteMediaCreateManyContentInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type ContentCategoryUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput> | ContentCategoryCreateWithoutContentInput[] | ContentCategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutContentInput | ContentCategoryCreateOrConnectWithoutContentInput[]
    createMany?: ContentCategoryCreateManyContentInputEnvelope
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
  }

  export type ContentTagUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentVersionUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput> | ContentVersionCreateWithoutContentInput[] | ContentVersionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentVersionCreateOrConnectWithoutContentInput | ContentVersionCreateOrConnectWithoutContentInput[]
    createMany?: ContentVersionCreateManyContentInputEnvelope
    connect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
  }

  export type SiteContentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput> | SiteContentCreateWithoutContentInput[] | SiteContentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutContentInput | SiteContentCreateOrConnectWithoutContentInput[]
    createMany?: SiteContentCreateManyContentInputEnvelope
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
  }

  export type SiteMediaUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput> | SiteMediaCreateWithoutContentInput[] | SiteMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutContentInput | SiteMediaCreateOrConnectWithoutContentInput[]
    createMany?: SiteMediaCreateManyContentInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContentTypeUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<ContentTypeCreateWithoutContentInput, ContentTypeUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentInput
    upsert?: ContentTypeUpsertWithoutContentInput
    connect?: ContentTypeWhereUniqueInput
    update?: XOR<XOR<ContentTypeUpdateToOneWithWhereWithoutContentInput, ContentTypeUpdateWithoutContentInput>, ContentTypeUncheckedUpdateWithoutContentInput>
  }

  export type ContentCategoryUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput> | ContentCategoryCreateWithoutContentInput[] | ContentCategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutContentInput | ContentCategoryCreateOrConnectWithoutContentInput[]
    upsert?: ContentCategoryUpsertWithWhereUniqueWithoutContentInput | ContentCategoryUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentCategoryCreateManyContentInputEnvelope
    set?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    disconnect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    delete?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    update?: ContentCategoryUpdateWithWhereUniqueWithoutContentInput | ContentCategoryUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentCategoryUpdateManyWithWhereWithoutContentInput | ContentCategoryUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
  }

  export type ContentTagUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutContentInput | ContentTagUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutContentInput | ContentTagUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutContentInput | ContentTagUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentVersionUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput> | ContentVersionCreateWithoutContentInput[] | ContentVersionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentVersionCreateOrConnectWithoutContentInput | ContentVersionCreateOrConnectWithoutContentInput[]
    upsert?: ContentVersionUpsertWithWhereUniqueWithoutContentInput | ContentVersionUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentVersionCreateManyContentInputEnvelope
    set?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    disconnect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    delete?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    connect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    update?: ContentVersionUpdateWithWhereUniqueWithoutContentInput | ContentVersionUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentVersionUpdateManyWithWhereWithoutContentInput | ContentVersionUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentVersionScalarWhereInput | ContentVersionScalarWhereInput[]
  }

  export type SiteContentUpdateManyWithoutContentNestedInput = {
    create?: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput> | SiteContentCreateWithoutContentInput[] | SiteContentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutContentInput | SiteContentCreateOrConnectWithoutContentInput[]
    upsert?: SiteContentUpsertWithWhereUniqueWithoutContentInput | SiteContentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: SiteContentCreateManyContentInputEnvelope
    set?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    disconnect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    delete?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    update?: SiteContentUpdateWithWhereUniqueWithoutContentInput | SiteContentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: SiteContentUpdateManyWithWhereWithoutContentInput | SiteContentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
  }

  export type SiteMediaUpdateManyWithoutContentNestedInput = {
    create?: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput> | SiteMediaCreateWithoutContentInput[] | SiteMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutContentInput | SiteMediaCreateOrConnectWithoutContentInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutContentInput | SiteMediaUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: SiteMediaCreateManyContentInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutContentInput | SiteMediaUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutContentInput | SiteMediaUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContentCategoryUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput> | ContentCategoryCreateWithoutContentInput[] | ContentCategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutContentInput | ContentCategoryCreateOrConnectWithoutContentInput[]
    upsert?: ContentCategoryUpsertWithWhereUniqueWithoutContentInput | ContentCategoryUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentCategoryCreateManyContentInputEnvelope
    set?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    disconnect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    delete?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    update?: ContentCategoryUpdateWithWhereUniqueWithoutContentInput | ContentCategoryUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentCategoryUpdateManyWithWhereWithoutContentInput | ContentCategoryUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
  }

  export type ContentTagUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutContentInput | ContentTagUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutContentInput | ContentTagUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutContentInput | ContentTagUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentVersionUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput> | ContentVersionCreateWithoutContentInput[] | ContentVersionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentVersionCreateOrConnectWithoutContentInput | ContentVersionCreateOrConnectWithoutContentInput[]
    upsert?: ContentVersionUpsertWithWhereUniqueWithoutContentInput | ContentVersionUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentVersionCreateManyContentInputEnvelope
    set?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    disconnect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    delete?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    connect?: ContentVersionWhereUniqueInput | ContentVersionWhereUniqueInput[]
    update?: ContentVersionUpdateWithWhereUniqueWithoutContentInput | ContentVersionUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentVersionUpdateManyWithWhereWithoutContentInput | ContentVersionUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentVersionScalarWhereInput | ContentVersionScalarWhereInput[]
  }

  export type SiteContentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput> | SiteContentCreateWithoutContentInput[] | SiteContentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutContentInput | SiteContentCreateOrConnectWithoutContentInput[]
    upsert?: SiteContentUpsertWithWhereUniqueWithoutContentInput | SiteContentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: SiteContentCreateManyContentInputEnvelope
    set?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    disconnect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    delete?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    update?: SiteContentUpdateWithWhereUniqueWithoutContentInput | SiteContentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: SiteContentUpdateManyWithWhereWithoutContentInput | SiteContentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
  }

  export type SiteMediaUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput> | SiteMediaCreateWithoutContentInput[] | SiteMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutContentInput | SiteMediaCreateOrConnectWithoutContentInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutContentInput | SiteMediaUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: SiteMediaCreateManyContentInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutContentInput | SiteMediaUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutContentInput | SiteMediaUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type ContentCreateNestedManyWithoutContentTypeInput = {
    create?: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput> | ContentCreateWithoutContentTypeInput[] | ContentUncheckedCreateWithoutContentTypeInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutContentTypeInput | ContentCreateOrConnectWithoutContentTypeInput[]
    createMany?: ContentCreateManyContentTypeInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutContentTypeInput = {
    create?: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput> | ContentCreateWithoutContentTypeInput[] | ContentUncheckedCreateWithoutContentTypeInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutContentTypeInput | ContentCreateOrConnectWithoutContentTypeInput[]
    createMany?: ContentCreateManyContentTypeInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentUpdateManyWithoutContentTypeNestedInput = {
    create?: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput> | ContentCreateWithoutContentTypeInput[] | ContentUncheckedCreateWithoutContentTypeInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutContentTypeInput | ContentCreateOrConnectWithoutContentTypeInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutContentTypeInput | ContentUpsertWithWhereUniqueWithoutContentTypeInput[]
    createMany?: ContentCreateManyContentTypeInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutContentTypeInput | ContentUpdateWithWhereUniqueWithoutContentTypeInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutContentTypeInput | ContentUpdateManyWithWhereWithoutContentTypeInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutContentTypeNestedInput = {
    create?: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput> | ContentCreateWithoutContentTypeInput[] | ContentUncheckedCreateWithoutContentTypeInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutContentTypeInput | ContentCreateOrConnectWithoutContentTypeInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutContentTypeInput | ContentUpsertWithWhereUniqueWithoutContentTypeInput[]
    createMany?: ContentCreateManyContentTypeInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutContentTypeInput | ContentUpdateWithWhereUniqueWithoutContentTypeInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutContentTypeInput | ContentUpdateManyWithWhereWithoutContentTypeInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput> | ContentCategoryCreateWithoutCategoryInput[] | ContentCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutCategoryInput | ContentCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ContentCategoryCreateManyCategoryInputEnvelope
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput> | ContentCategoryCreateWithoutCategoryInput[] | ContentCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutCategoryInput | ContentCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ContentCategoryCreateManyCategoryInputEnvelope
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput> | ContentCategoryCreateWithoutCategoryInput[] | ContentCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutCategoryInput | ContentCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ContentCategoryUpsertWithWhereUniqueWithoutCategoryInput | ContentCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ContentCategoryCreateManyCategoryInputEnvelope
    set?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    disconnect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    delete?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    update?: ContentCategoryUpdateWithWhereUniqueWithoutCategoryInput | ContentCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ContentCategoryUpdateManyWithWhereWithoutCategoryInput | ContentCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput> | ContentCategoryCreateWithoutCategoryInput[] | ContentCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCategoryCreateOrConnectWithoutCategoryInput | ContentCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ContentCategoryUpsertWithWhereUniqueWithoutCategoryInput | ContentCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ContentCategoryCreateManyCategoryInputEnvelope
    set?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    disconnect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    delete?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    connect?: ContentCategoryWhereUniqueInput | ContentCategoryWhereUniqueInput[]
    update?: ContentCategoryUpdateWithWhereUniqueWithoutCategoryInput | ContentCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ContentCategoryUpdateManyWithWhereWithoutCategoryInput | ContentCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutContentInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput
    connect?: CategoryWhereUniqueInput
  }

  export type ContentCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ContentCreateWithoutCategoriesInput, ContentUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutCategoriesInput
    connect?: ContentWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput
    upsert?: CategoryUpsertWithoutContentInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutContentInput, CategoryUpdateWithoutContentInput>, CategoryUncheckedUpdateWithoutContentInput>
  }

  export type ContentUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ContentCreateWithoutCategoriesInput, ContentUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutCategoriesInput
    upsert?: ContentUpsertWithoutCategoriesInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutCategoriesInput, ContentUpdateWithoutCategoriesInput>, ContentUncheckedUpdateWithoutCategoriesInput>
  }

  export type ContentTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutTagInput | ContentTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutTagInput | ContentTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutTagInput | ContentTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutTagInput | ContentTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutTagInput | ContentTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutTagInput | ContentTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutTagsInput = {
    create?: XOR<ContentCreateWithoutTagsInput, ContentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutTagsInput
    connect?: ContentWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutContentInput = {
    create?: XOR<TagCreateWithoutContentInput, TagUncheckedCreateWithoutContentInput>
    connectOrCreate?: TagCreateOrConnectWithoutContentInput
    connect?: TagWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ContentCreateWithoutTagsInput, ContentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutTagsInput
    upsert?: ContentUpsertWithoutTagsInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutTagsInput, ContentUpdateWithoutTagsInput>, ContentUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<TagCreateWithoutContentInput, TagUncheckedCreateWithoutContentInput>
    connectOrCreate?: TagCreateOrConnectWithoutContentInput
    upsert?: TagUpsertWithoutContentInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutContentInput, TagUpdateWithoutContentInput>, TagUncheckedUpdateWithoutContentInput>
  }

  export type AffiliateLinkCreateNestedManyWithoutSiteInput = {
    create?: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput> | AffiliateLinkCreateWithoutSiteInput[] | AffiliateLinkUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutSiteInput | AffiliateLinkCreateOrConnectWithoutSiteInput[]
    createMany?: AffiliateLinkCreateManySiteInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type AutoBlogPostCreateNestedManyWithoutSiteInput = {
    create?: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput> | AutoBlogPostCreateWithoutSiteInput[] | AutoBlogPostUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AutoBlogPostCreateOrConnectWithoutSiteInput | AutoBlogPostCreateOrConnectWithoutSiteInput[]
    createMany?: AutoBlogPostCreateManySiteInputEnvelope
    connect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
  }

  export type ContentScheduleCreateNestedManyWithoutSiteInput = {
    create?: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput> | ContentScheduleCreateWithoutSiteInput[] | ContentScheduleUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ContentScheduleCreateOrConnectWithoutSiteInput | ContentScheduleCreateOrConnectWithoutSiteInput[]
    createMany?: ContentScheduleCreateManySiteInputEnvelope
    connect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
  }

  export type InteractiveQuizCreateNestedManyWithoutSiteInput = {
    create?: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput> | InteractiveQuizCreateWithoutSiteInput[] | InteractiveQuizUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutSiteInput | InteractiveQuizCreateOrConnectWithoutSiteInput[]
    createMany?: InteractiveQuizCreateManySiteInputEnvelope
    connect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
  }

  export type PriceAlertCreateNestedManyWithoutSiteInput = {
    create?: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput> | PriceAlertCreateWithoutSiteInput[] | PriceAlertUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutSiteInput | PriceAlertCreateOrConnectWithoutSiteInput[]
    createMany?: PriceAlertCreateManySiteInputEnvelope
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutSiteInput = {
    create?: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput> | ProductCategoryCreateWithoutSiteInput[] | ProductCategoryUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSiteInput | ProductCategoryCreateOrConnectWithoutSiteInput[]
    createMany?: ProductCategoryCreateManySiteInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCustomFieldCreateNestedManyWithoutSiteInput = {
    create?: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput> | ProductCustomFieldCreateWithoutSiteInput[] | ProductCustomFieldUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutSiteInput | ProductCustomFieldCreateOrConnectWithoutSiteInput[]
    createMany?: ProductCustomFieldCreateManySiteInputEnvelope
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
  }

  export type SiteContentCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput> | SiteContentCreateWithoutSiteInput[] | SiteContentUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutSiteInput | SiteContentCreateOrConnectWithoutSiteInput[]
    createMany?: SiteContentCreateManySiteInputEnvelope
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
  }

  export type SiteMediaCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput> | SiteMediaCreateWithoutSiteInput[] | SiteMediaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutSiteInput | SiteMediaCreateOrConnectWithoutSiteInput[]
    createMany?: SiteMediaCreateManySiteInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type SiteProductCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput> | SiteProductCreateWithoutSiteInput[] | SiteProductUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutSiteInput | SiteProductCreateOrConnectWithoutSiteInput[]
    createMany?: SiteProductCreateManySiteInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type CustomNicheCreateNestedOneWithoutSitesInput = {
    create?: XOR<CustomNicheCreateWithoutSitesInput, CustomNicheUncheckedCreateWithoutSitesInput>
    connectOrCreate?: CustomNicheCreateOrConnectWithoutSitesInput
    connect?: CustomNicheWhereUniqueInput
  }

  export type AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput> | AffiliateLinkCreateWithoutSiteInput[] | AffiliateLinkUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutSiteInput | AffiliateLinkCreateOrConnectWithoutSiteInput[]
    createMany?: AffiliateLinkCreateManySiteInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput> | AutoBlogPostCreateWithoutSiteInput[] | AutoBlogPostUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AutoBlogPostCreateOrConnectWithoutSiteInput | AutoBlogPostCreateOrConnectWithoutSiteInput[]
    createMany?: AutoBlogPostCreateManySiteInputEnvelope
    connect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
  }

  export type ContentScheduleUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput> | ContentScheduleCreateWithoutSiteInput[] | ContentScheduleUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ContentScheduleCreateOrConnectWithoutSiteInput | ContentScheduleCreateOrConnectWithoutSiteInput[]
    createMany?: ContentScheduleCreateManySiteInputEnvelope
    connect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
  }

  export type InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput> | InteractiveQuizCreateWithoutSiteInput[] | InteractiveQuizUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutSiteInput | InteractiveQuizCreateOrConnectWithoutSiteInput[]
    createMany?: InteractiveQuizCreateManySiteInputEnvelope
    connect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
  }

  export type PriceAlertUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput> | PriceAlertCreateWithoutSiteInput[] | PriceAlertUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutSiteInput | PriceAlertCreateOrConnectWithoutSiteInput[]
    createMany?: PriceAlertCreateManySiteInputEnvelope
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput> | ProductCategoryCreateWithoutSiteInput[] | ProductCategoryUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSiteInput | ProductCategoryCreateOrConnectWithoutSiteInput[]
    createMany?: ProductCategoryCreateManySiteInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput> | ProductCustomFieldCreateWithoutSiteInput[] | ProductCustomFieldUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutSiteInput | ProductCustomFieldCreateOrConnectWithoutSiteInput[]
    createMany?: ProductCustomFieldCreateManySiteInputEnvelope
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
  }

  export type SiteContentUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput> | SiteContentCreateWithoutSiteInput[] | SiteContentUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutSiteInput | SiteContentCreateOrConnectWithoutSiteInput[]
    createMany?: SiteContentCreateManySiteInputEnvelope
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
  }

  export type SiteMediaUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput> | SiteMediaCreateWithoutSiteInput[] | SiteMediaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutSiteInput | SiteMediaCreateOrConnectWithoutSiteInput[]
    createMany?: SiteMediaCreateManySiteInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type SiteProductUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput> | SiteProductCreateWithoutSiteInput[] | SiteProductUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutSiteInput | SiteProductCreateOrConnectWithoutSiteInput[]
    createMany?: SiteProductCreateManySiteInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AffiliateLinkUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput> | AffiliateLinkCreateWithoutSiteInput[] | AffiliateLinkUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutSiteInput | AffiliateLinkCreateOrConnectWithoutSiteInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutSiteInput | AffiliateLinkUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AffiliateLinkCreateManySiteInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutSiteInput | AffiliateLinkUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutSiteInput | AffiliateLinkUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type AutoBlogPostUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput> | AutoBlogPostCreateWithoutSiteInput[] | AutoBlogPostUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AutoBlogPostCreateOrConnectWithoutSiteInput | AutoBlogPostCreateOrConnectWithoutSiteInput[]
    upsert?: AutoBlogPostUpsertWithWhereUniqueWithoutSiteInput | AutoBlogPostUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AutoBlogPostCreateManySiteInputEnvelope
    set?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    disconnect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    delete?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    connect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    update?: AutoBlogPostUpdateWithWhereUniqueWithoutSiteInput | AutoBlogPostUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AutoBlogPostUpdateManyWithWhereWithoutSiteInput | AutoBlogPostUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AutoBlogPostScalarWhereInput | AutoBlogPostScalarWhereInput[]
  }

  export type ContentScheduleUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput> | ContentScheduleCreateWithoutSiteInput[] | ContentScheduleUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ContentScheduleCreateOrConnectWithoutSiteInput | ContentScheduleCreateOrConnectWithoutSiteInput[]
    upsert?: ContentScheduleUpsertWithWhereUniqueWithoutSiteInput | ContentScheduleUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ContentScheduleCreateManySiteInputEnvelope
    set?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    disconnect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    delete?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    connect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    update?: ContentScheduleUpdateWithWhereUniqueWithoutSiteInput | ContentScheduleUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ContentScheduleUpdateManyWithWhereWithoutSiteInput | ContentScheduleUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ContentScheduleScalarWhereInput | ContentScheduleScalarWhereInput[]
  }

  export type InteractiveQuizUpdateManyWithoutSiteNestedInput = {
    create?: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput> | InteractiveQuizCreateWithoutSiteInput[] | InteractiveQuizUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutSiteInput | InteractiveQuizCreateOrConnectWithoutSiteInput[]
    upsert?: InteractiveQuizUpsertWithWhereUniqueWithoutSiteInput | InteractiveQuizUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: InteractiveQuizCreateManySiteInputEnvelope
    set?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    disconnect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    delete?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    connect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    update?: InteractiveQuizUpdateWithWhereUniqueWithoutSiteInput | InteractiveQuizUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: InteractiveQuizUpdateManyWithWhereWithoutSiteInput | InteractiveQuizUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: InteractiveQuizScalarWhereInput | InteractiveQuizScalarWhereInput[]
  }

  export type PriceAlertUpdateManyWithoutSiteNestedInput = {
    create?: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput> | PriceAlertCreateWithoutSiteInput[] | PriceAlertUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutSiteInput | PriceAlertCreateOrConnectWithoutSiteInput[]
    upsert?: PriceAlertUpsertWithWhereUniqueWithoutSiteInput | PriceAlertUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: PriceAlertCreateManySiteInputEnvelope
    set?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    disconnect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    delete?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    update?: PriceAlertUpdateWithWhereUniqueWithoutSiteInput | PriceAlertUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: PriceAlertUpdateManyWithWhereWithoutSiteInput | PriceAlertUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput> | ProductCategoryCreateWithoutSiteInput[] | ProductCategoryUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSiteInput | ProductCategoryCreateOrConnectWithoutSiteInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutSiteInput | ProductCategoryUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ProductCategoryCreateManySiteInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutSiteInput | ProductCategoryUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutSiteInput | ProductCategoryUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductCustomFieldUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput> | ProductCustomFieldCreateWithoutSiteInput[] | ProductCustomFieldUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutSiteInput | ProductCustomFieldCreateOrConnectWithoutSiteInput[]
    upsert?: ProductCustomFieldUpsertWithWhereUniqueWithoutSiteInput | ProductCustomFieldUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ProductCustomFieldCreateManySiteInputEnvelope
    set?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    disconnect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    delete?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    update?: ProductCustomFieldUpdateWithWhereUniqueWithoutSiteInput | ProductCustomFieldUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ProductCustomFieldUpdateManyWithWhereWithoutSiteInput | ProductCustomFieldUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
  }

  export type SiteContentUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput> | SiteContentCreateWithoutSiteInput[] | SiteContentUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutSiteInput | SiteContentCreateOrConnectWithoutSiteInput[]
    upsert?: SiteContentUpsertWithWhereUniqueWithoutSiteInput | SiteContentUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteContentCreateManySiteInputEnvelope
    set?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    disconnect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    delete?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    update?: SiteContentUpdateWithWhereUniqueWithoutSiteInput | SiteContentUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteContentUpdateManyWithWhereWithoutSiteInput | SiteContentUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
  }

  export type SiteMediaUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput> | SiteMediaCreateWithoutSiteInput[] | SiteMediaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutSiteInput | SiteMediaCreateOrConnectWithoutSiteInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutSiteInput | SiteMediaUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteMediaCreateManySiteInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutSiteInput | SiteMediaUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutSiteInput | SiteMediaUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type SiteProductUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput> | SiteProductCreateWithoutSiteInput[] | SiteProductUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutSiteInput | SiteProductCreateOrConnectWithoutSiteInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutSiteInput | SiteProductUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteProductCreateManySiteInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutSiteInput | SiteProductUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutSiteInput | SiteProductUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type CustomNicheUpdateOneWithoutSitesNestedInput = {
    create?: XOR<CustomNicheCreateWithoutSitesInput, CustomNicheUncheckedCreateWithoutSitesInput>
    connectOrCreate?: CustomNicheCreateOrConnectWithoutSitesInput
    upsert?: CustomNicheUpsertWithoutSitesInput
    disconnect?: CustomNicheWhereInput | boolean
    delete?: CustomNicheWhereInput | boolean
    connect?: CustomNicheWhereUniqueInput
    update?: XOR<XOR<CustomNicheUpdateToOneWithWhereWithoutSitesInput, CustomNicheUpdateWithoutSitesInput>, CustomNicheUncheckedUpdateWithoutSitesInput>
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput> | AffiliateLinkCreateWithoutSiteInput[] | AffiliateLinkUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutSiteInput | AffiliateLinkCreateOrConnectWithoutSiteInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutSiteInput | AffiliateLinkUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AffiliateLinkCreateManySiteInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutSiteInput | AffiliateLinkUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutSiteInput | AffiliateLinkUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput> | AutoBlogPostCreateWithoutSiteInput[] | AutoBlogPostUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AutoBlogPostCreateOrConnectWithoutSiteInput | AutoBlogPostCreateOrConnectWithoutSiteInput[]
    upsert?: AutoBlogPostUpsertWithWhereUniqueWithoutSiteInput | AutoBlogPostUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AutoBlogPostCreateManySiteInputEnvelope
    set?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    disconnect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    delete?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    connect?: AutoBlogPostWhereUniqueInput | AutoBlogPostWhereUniqueInput[]
    update?: AutoBlogPostUpdateWithWhereUniqueWithoutSiteInput | AutoBlogPostUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AutoBlogPostUpdateManyWithWhereWithoutSiteInput | AutoBlogPostUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AutoBlogPostScalarWhereInput | AutoBlogPostScalarWhereInput[]
  }

  export type ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput> | ContentScheduleCreateWithoutSiteInput[] | ContentScheduleUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ContentScheduleCreateOrConnectWithoutSiteInput | ContentScheduleCreateOrConnectWithoutSiteInput[]
    upsert?: ContentScheduleUpsertWithWhereUniqueWithoutSiteInput | ContentScheduleUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ContentScheduleCreateManySiteInputEnvelope
    set?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    disconnect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    delete?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    connect?: ContentScheduleWhereUniqueInput | ContentScheduleWhereUniqueInput[]
    update?: ContentScheduleUpdateWithWhereUniqueWithoutSiteInput | ContentScheduleUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ContentScheduleUpdateManyWithWhereWithoutSiteInput | ContentScheduleUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ContentScheduleScalarWhereInput | ContentScheduleScalarWhereInput[]
  }

  export type InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput> | InteractiveQuizCreateWithoutSiteInput[] | InteractiveQuizUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutSiteInput | InteractiveQuizCreateOrConnectWithoutSiteInput[]
    upsert?: InteractiveQuizUpsertWithWhereUniqueWithoutSiteInput | InteractiveQuizUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: InteractiveQuizCreateManySiteInputEnvelope
    set?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    disconnect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    delete?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    connect?: InteractiveQuizWhereUniqueInput | InteractiveQuizWhereUniqueInput[]
    update?: InteractiveQuizUpdateWithWhereUniqueWithoutSiteInput | InteractiveQuizUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: InteractiveQuizUpdateManyWithWhereWithoutSiteInput | InteractiveQuizUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: InteractiveQuizScalarWhereInput | InteractiveQuizScalarWhereInput[]
  }

  export type PriceAlertUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput> | PriceAlertCreateWithoutSiteInput[] | PriceAlertUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutSiteInput | PriceAlertCreateOrConnectWithoutSiteInput[]
    upsert?: PriceAlertUpsertWithWhereUniqueWithoutSiteInput | PriceAlertUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: PriceAlertCreateManySiteInputEnvelope
    set?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    disconnect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    delete?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    update?: PriceAlertUpdateWithWhereUniqueWithoutSiteInput | PriceAlertUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: PriceAlertUpdateManyWithWhereWithoutSiteInput | PriceAlertUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput> | ProductCategoryCreateWithoutSiteInput[] | ProductCategoryUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSiteInput | ProductCategoryCreateOrConnectWithoutSiteInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutSiteInput | ProductCategoryUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ProductCategoryCreateManySiteInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutSiteInput | ProductCategoryUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutSiteInput | ProductCategoryUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput> | ProductCustomFieldCreateWithoutSiteInput[] | ProductCustomFieldUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutSiteInput | ProductCustomFieldCreateOrConnectWithoutSiteInput[]
    upsert?: ProductCustomFieldUpsertWithWhereUniqueWithoutSiteInput | ProductCustomFieldUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ProductCustomFieldCreateManySiteInputEnvelope
    set?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    disconnect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    delete?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    update?: ProductCustomFieldUpdateWithWhereUniqueWithoutSiteInput | ProductCustomFieldUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ProductCustomFieldUpdateManyWithWhereWithoutSiteInput | ProductCustomFieldUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
  }

  export type SiteContentUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput> | SiteContentCreateWithoutSiteInput[] | SiteContentUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteContentCreateOrConnectWithoutSiteInput | SiteContentCreateOrConnectWithoutSiteInput[]
    upsert?: SiteContentUpsertWithWhereUniqueWithoutSiteInput | SiteContentUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteContentCreateManySiteInputEnvelope
    set?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    disconnect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    delete?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    connect?: SiteContentWhereUniqueInput | SiteContentWhereUniqueInput[]
    update?: SiteContentUpdateWithWhereUniqueWithoutSiteInput | SiteContentUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteContentUpdateManyWithWhereWithoutSiteInput | SiteContentUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
  }

  export type SiteMediaUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput> | SiteMediaCreateWithoutSiteInput[] | SiteMediaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutSiteInput | SiteMediaCreateOrConnectWithoutSiteInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutSiteInput | SiteMediaUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteMediaCreateManySiteInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutSiteInput | SiteMediaUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutSiteInput | SiteMediaUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type SiteProductUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput> | SiteProductCreateWithoutSiteInput[] | SiteProductUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutSiteInput | SiteProductCreateOrConnectWithoutSiteInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutSiteInput | SiteProductUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteProductCreateManySiteInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutSiteInput | SiteProductUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutSiteInput | SiteProductUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutSiteContentInput = {
    create?: XOR<ContentCreateWithoutSiteContentInput, ContentUncheckedCreateWithoutSiteContentInput>
    connectOrCreate?: ContentCreateOrConnectWithoutSiteContentInput
    connect?: ContentWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutContentInput = {
    create?: XOR<SiteCreateWithoutContentInput, SiteUncheckedCreateWithoutContentInput>
    connectOrCreate?: SiteCreateOrConnectWithoutContentInput
    connect?: SiteWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutSiteContentNestedInput = {
    create?: XOR<ContentCreateWithoutSiteContentInput, ContentUncheckedCreateWithoutSiteContentInput>
    connectOrCreate?: ContentCreateOrConnectWithoutSiteContentInput
    upsert?: ContentUpsertWithoutSiteContentInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutSiteContentInput, ContentUpdateWithoutSiteContentInput>, ContentUncheckedUpdateWithoutSiteContentInput>
  }

  export type SiteUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<SiteCreateWithoutContentInput, SiteUncheckedCreateWithoutContentInput>
    connectOrCreate?: SiteCreateOrConnectWithoutContentInput
    upsert?: SiteUpsertWithoutContentInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutContentInput, SiteUpdateWithoutContentInput>, SiteUncheckedUpdateWithoutContentInput>
  }

  export type SiteMediaCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput> | SiteMediaCreateWithoutMediaAssetInput[] | SiteMediaUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutMediaAssetInput | SiteMediaCreateOrConnectWithoutMediaAssetInput[]
    createMany?: SiteMediaCreateManyMediaAssetInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type SiteMediaUncheckedCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput> | SiteMediaCreateWithoutMediaAssetInput[] | SiteMediaUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutMediaAssetInput | SiteMediaCreateOrConnectWithoutMediaAssetInput[]
    createMany?: SiteMediaCreateManyMediaAssetInputEnvelope
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
  }

  export type SiteMediaUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput> | SiteMediaCreateWithoutMediaAssetInput[] | SiteMediaUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutMediaAssetInput | SiteMediaCreateOrConnectWithoutMediaAssetInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutMediaAssetInput | SiteMediaUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: SiteMediaCreateManyMediaAssetInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutMediaAssetInput | SiteMediaUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutMediaAssetInput | SiteMediaUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type SiteMediaUncheckedUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput> | SiteMediaCreateWithoutMediaAssetInput[] | SiteMediaUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SiteMediaCreateOrConnectWithoutMediaAssetInput | SiteMediaCreateOrConnectWithoutMediaAssetInput[]
    upsert?: SiteMediaUpsertWithWhereUniqueWithoutMediaAssetInput | SiteMediaUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: SiteMediaCreateManyMediaAssetInputEnvelope
    set?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    disconnect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    delete?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    connect?: SiteMediaWhereUniqueInput | SiteMediaWhereUniqueInput[]
    update?: SiteMediaUpdateWithWhereUniqueWithoutMediaAssetInput | SiteMediaUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: SiteMediaUpdateManyWithWhereWithoutMediaAssetInput | SiteMediaUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutMediaInput = {
    create?: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ContentCreateOrConnectWithoutMediaInput
    connect?: ContentWhereUniqueInput
  }

  export type MediaAssetCreateNestedOneWithoutSiteMediaInput = {
    create?: XOR<MediaAssetCreateWithoutSiteMediaInput, MediaAssetUncheckedCreateWithoutSiteMediaInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutSiteMediaInput
    connect?: MediaAssetWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutMediaInput = {
    create?: XOR<SiteCreateWithoutMediaInput, SiteUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SiteCreateOrConnectWithoutMediaInput
    connect?: SiteWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ContentCreateOrConnectWithoutMediaInput
    upsert?: ContentUpsertWithoutMediaInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutMediaInput, ContentUpdateWithoutMediaInput>, ContentUncheckedUpdateWithoutMediaInput>
  }

  export type MediaAssetUpdateOneRequiredWithoutSiteMediaNestedInput = {
    create?: XOR<MediaAssetCreateWithoutSiteMediaInput, MediaAssetUncheckedCreateWithoutSiteMediaInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutSiteMediaInput
    upsert?: MediaAssetUpsertWithoutSiteMediaInput
    connect?: MediaAssetWhereUniqueInput
    update?: XOR<XOR<MediaAssetUpdateToOneWithWhereWithoutSiteMediaInput, MediaAssetUpdateWithoutSiteMediaInput>, MediaAssetUncheckedUpdateWithoutSiteMediaInput>
  }

  export type SiteUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<SiteCreateWithoutMediaInput, SiteUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SiteCreateOrConnectWithoutMediaInput
    upsert?: SiteUpsertWithoutMediaInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutMediaInput, SiteUpdateWithoutMediaInput>, SiteUncheckedUpdateWithoutMediaInput>
  }

  export type AffiliateLinkCreateNestedManyWithoutProductInput = {
    create?: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput> | AffiliateLinkCreateWithoutProductInput[] | AffiliateLinkUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutProductInput | AffiliateLinkCreateOrConnectWithoutProductInput[]
    createMany?: AffiliateLinkCreateManyProductInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type ProductCustomFieldCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput> | ProductCustomFieldCreateWithoutProductInput[] | ProductCustomFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutProductInput | ProductCustomFieldCreateOrConnectWithoutProductInput[]
    createMany?: ProductCustomFieldCreateManyProductInputEnvelope
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
  }

  export type ProductPriceHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput> | ProductPriceHistoryCreateWithoutProductInput[] | ProductPriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceHistoryCreateOrConnectWithoutProductInput | ProductPriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductPriceHistoryCreateManyProductInputEnvelope
    connect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
  }

  export type SiteProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput> | SiteProductCreateWithoutProductInput[] | SiteProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutProductInput | SiteProductCreateOrConnectWithoutProductInput[]
    createMany?: SiteProductCreateManyProductInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type AffiliateLinkUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput> | AffiliateLinkCreateWithoutProductInput[] | AffiliateLinkUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutProductInput | AffiliateLinkCreateOrConnectWithoutProductInput[]
    createMany?: AffiliateLinkCreateManyProductInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type ProductCustomFieldUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput> | ProductCustomFieldCreateWithoutProductInput[] | ProductCustomFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutProductInput | ProductCustomFieldCreateOrConnectWithoutProductInput[]
    createMany?: ProductCustomFieldCreateManyProductInputEnvelope
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
  }

  export type ProductPriceHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput> | ProductPriceHistoryCreateWithoutProductInput[] | ProductPriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceHistoryCreateOrConnectWithoutProductInput | ProductPriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductPriceHistoryCreateManyProductInputEnvelope
    connect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
  }

  export type SiteProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput> | SiteProductCreateWithoutProductInput[] | SiteProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutProductInput | SiteProductCreateOrConnectWithoutProductInput[]
    createMany?: SiteProductCreateManyProductInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AffiliateLinkUpdateManyWithoutProductNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput> | AffiliateLinkCreateWithoutProductInput[] | AffiliateLinkUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutProductInput | AffiliateLinkCreateOrConnectWithoutProductInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutProductInput | AffiliateLinkUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AffiliateLinkCreateManyProductInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutProductInput | AffiliateLinkUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutProductInput | AffiliateLinkUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type ProductCustomFieldUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput> | ProductCustomFieldCreateWithoutProductInput[] | ProductCustomFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutProductInput | ProductCustomFieldCreateOrConnectWithoutProductInput[]
    upsert?: ProductCustomFieldUpsertWithWhereUniqueWithoutProductInput | ProductCustomFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCustomFieldCreateManyProductInputEnvelope
    set?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    disconnect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    delete?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    update?: ProductCustomFieldUpdateWithWhereUniqueWithoutProductInput | ProductCustomFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCustomFieldUpdateManyWithWhereWithoutProductInput | ProductCustomFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
  }

  export type ProductPriceHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput> | ProductPriceHistoryCreateWithoutProductInput[] | ProductPriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceHistoryCreateOrConnectWithoutProductInput | ProductPriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductPriceHistoryUpsertWithWhereUniqueWithoutProductInput | ProductPriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPriceHistoryCreateManyProductInputEnvelope
    set?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    disconnect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    delete?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    connect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    update?: ProductPriceHistoryUpdateWithWhereUniqueWithoutProductInput | ProductPriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPriceHistoryUpdateManyWithWhereWithoutProductInput | ProductPriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPriceHistoryScalarWhereInput | ProductPriceHistoryScalarWhereInput[]
  }

  export type SiteProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput> | SiteProductCreateWithoutProductInput[] | SiteProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutProductInput | SiteProductCreateOrConnectWithoutProductInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutProductInput | SiteProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SiteProductCreateManyProductInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutProductInput | SiteProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutProductInput | SiteProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput> | AffiliateLinkCreateWithoutProductInput[] | AffiliateLinkUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutProductInput | AffiliateLinkCreateOrConnectWithoutProductInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutProductInput | AffiliateLinkUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AffiliateLinkCreateManyProductInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutProductInput | AffiliateLinkUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutProductInput | AffiliateLinkUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type ProductCustomFieldUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput> | ProductCustomFieldCreateWithoutProductInput[] | ProductCustomFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCustomFieldCreateOrConnectWithoutProductInput | ProductCustomFieldCreateOrConnectWithoutProductInput[]
    upsert?: ProductCustomFieldUpsertWithWhereUniqueWithoutProductInput | ProductCustomFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCustomFieldCreateManyProductInputEnvelope
    set?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    disconnect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    delete?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    connect?: ProductCustomFieldWhereUniqueInput | ProductCustomFieldWhereUniqueInput[]
    update?: ProductCustomFieldUpdateWithWhereUniqueWithoutProductInput | ProductCustomFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCustomFieldUpdateManyWithWhereWithoutProductInput | ProductCustomFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
  }

  export type ProductPriceHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput> | ProductPriceHistoryCreateWithoutProductInput[] | ProductPriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceHistoryCreateOrConnectWithoutProductInput | ProductPriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductPriceHistoryUpsertWithWhereUniqueWithoutProductInput | ProductPriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPriceHistoryCreateManyProductInputEnvelope
    set?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    disconnect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    delete?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    connect?: ProductPriceHistoryWhereUniqueInput | ProductPriceHistoryWhereUniqueInput[]
    update?: ProductPriceHistoryUpdateWithWhereUniqueWithoutProductInput | ProductPriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPriceHistoryUpdateManyWithWhereWithoutProductInput | ProductPriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPriceHistoryScalarWhereInput | ProductPriceHistoryScalarWhereInput[]
  }

  export type SiteProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput> | SiteProductCreateWithoutProductInput[] | SiteProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutProductInput | SiteProductCreateOrConnectWithoutProductInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutProductInput | SiteProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SiteProductCreateManyProductInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutProductInput | SiteProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutProductInput | SiteProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSiteProductsInput = {
    create?: XOR<ProductCreateWithoutSiteProductsInput, ProductUncheckedCreateWithoutSiteProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSiteProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutProductsInput = {
    create?: XOR<SiteCreateWithoutProductsInput, SiteUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutProductsInput
    connect?: SiteWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSiteProductsNestedInput = {
    create?: XOR<ProductCreateWithoutSiteProductsInput, ProductUncheckedCreateWithoutSiteProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSiteProductsInput
    upsert?: ProductUpsertWithoutSiteProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSiteProductsInput, ProductUpdateWithoutSiteProductsInput>, ProductUncheckedUpdateWithoutSiteProductsInput>
  }

  export type SiteUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SiteCreateWithoutProductsInput, SiteUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutProductsInput
    upsert?: SiteUpsertWithoutProductsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutProductsInput, SiteUpdateWithoutProductsInput>, SiteUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<ProductCreateWithoutCustomFieldsInput, ProductUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomFieldsInput
    connect?: ProductWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<SiteCreateWithoutCustomFieldsInput, SiteUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutCustomFieldsInput
    connect?: SiteWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<ProductCreateWithoutCustomFieldsInput, ProductUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomFieldsInput
    upsert?: ProductUpsertWithoutCustomFieldsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCustomFieldsInput, ProductUpdateWithoutCustomFieldsInput>, ProductUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type SiteUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<SiteCreateWithoutCustomFieldsInput, SiteUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutCustomFieldsInput
    upsert?: SiteUpsertWithoutCustomFieldsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutCustomFieldsInput, SiteUpdateWithoutCustomFieldsInput>, SiteUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type ProductCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    upsert?: ProductUpsertWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPriceHistoryInput, ProductUpdateWithoutPriceHistoryInput>, ProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type SiteCreateNestedOneWithoutPriceAlertsInput = {
    create?: XOR<SiteCreateWithoutPriceAlertsInput, SiteUncheckedCreateWithoutPriceAlertsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutPriceAlertsInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutPriceAlertsNestedInput = {
    create?: XOR<SiteCreateWithoutPriceAlertsInput, SiteUncheckedCreateWithoutPriceAlertsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutPriceAlertsInput
    upsert?: SiteUpsertWithoutPriceAlertsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutPriceAlertsInput, SiteUpdateWithoutPriceAlertsInput>, SiteUncheckedUpdateWithoutPriceAlertsInput>
  }

  export type SiteCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<SiteCreateWithoutQuizzesInput, SiteUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutQuizzesInput
    connect?: SiteWhereUniqueInput
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizResultCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput> | QuizResultCreateWithoutQuizInput[] | QuizResultUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizInput | QuizResultCreateOrConnectWithoutQuizInput[]
    createMany?: QuizResultCreateManyQuizInputEnvelope
    connect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizResultUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput> | QuizResultCreateWithoutQuizInput[] | QuizResultUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizInput | QuizResultCreateOrConnectWithoutQuizInput[]
    createMany?: QuizResultCreateManyQuizInputEnvelope
    connect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
  }

  export type SiteUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<SiteCreateWithoutQuizzesInput, SiteUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutQuizzesInput
    upsert?: SiteUpsertWithoutQuizzesInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutQuizzesInput, SiteUpdateWithoutQuizzesInput>, SiteUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizResultUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput> | QuizResultCreateWithoutQuizInput[] | QuizResultUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizInput | QuizResultCreateOrConnectWithoutQuizInput[]
    upsert?: QuizResultUpsertWithWhereUniqueWithoutQuizInput | QuizResultUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizResultCreateManyQuizInputEnvelope
    set?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    disconnect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    delete?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    connect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    update?: QuizResultUpdateWithWhereUniqueWithoutQuizInput | QuizResultUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizResultUpdateManyWithWhereWithoutQuizInput | QuizResultUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizResultScalarWhereInput | QuizResultScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizResultUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput> | QuizResultCreateWithoutQuizInput[] | QuizResultUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizInput | QuizResultCreateOrConnectWithoutQuizInput[]
    upsert?: QuizResultUpsertWithWhereUniqueWithoutQuizInput | QuizResultUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizResultCreateManyQuizInputEnvelope
    set?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    disconnect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    delete?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    connect?: QuizResultWhereUniqueInput | QuizResultWhereUniqueInput[]
    update?: QuizResultUpdateWithWhereUniqueWithoutQuizInput | QuizResultUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizResultUpdateManyWithWhereWithoutQuizInput | QuizResultUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizResultScalarWhereInput | QuizResultScalarWhereInput[]
  }

  export type QuizAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizQuestionOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput> | QuizQuestionOptionCreateWithoutQuestionInput[] | QuizQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionOptionCreateOrConnectWithoutQuestionInput | QuizQuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizQuestionOptionCreateManyQuestionInputEnvelope
    connect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
  }

  export type InteractiveQuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<InteractiveQuizCreateWithoutQuestionsInput, InteractiveQuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutQuestionsInput
    connect?: InteractiveQuizWhereUniqueInput
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput> | QuizQuestionOptionCreateWithoutQuestionInput[] | QuizQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionOptionCreateOrConnectWithoutQuestionInput | QuizQuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizQuestionOptionCreateManyQuestionInputEnvelope
    connect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
  }

  export type QuizAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuestionInput | QuizAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput> | QuizQuestionOptionCreateWithoutQuestionInput[] | QuizQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionOptionCreateOrConnectWithoutQuestionInput | QuizQuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizQuestionOptionCreateManyQuestionInputEnvelope
    set?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    disconnect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    delete?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    connect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    update?: QuizQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizQuestionOptionUpdateManyWithWhereWithoutQuestionInput | QuizQuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizQuestionOptionScalarWhereInput | QuizQuestionOptionScalarWhereInput[]
  }

  export type InteractiveQuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<InteractiveQuizCreateWithoutQuestionsInput, InteractiveQuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutQuestionsInput
    upsert?: InteractiveQuizUpsertWithoutQuestionsInput
    connect?: InteractiveQuizWhereUniqueInput
    update?: XOR<XOR<InteractiveQuizUpdateToOneWithWhereWithoutQuestionsInput, InteractiveQuizUpdateWithoutQuestionsInput>, InteractiveQuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuestionInput | QuizAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput> | QuizQuestionOptionCreateWithoutQuestionInput[] | QuizQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionOptionCreateOrConnectWithoutQuestionInput | QuizQuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizQuestionOptionCreateManyQuestionInputEnvelope
    set?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    disconnect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    delete?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    connect?: QuizQuestionOptionWhereUniqueInput | QuizQuestionOptionWhereUniqueInput[]
    update?: QuizQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizQuestionOptionUpdateManyWithWhereWithoutQuestionInput | QuizQuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizQuestionOptionScalarWhereInput | QuizQuestionOptionScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuizQuestionUpsertWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutOptionsInput, QuizQuestionUpdateWithoutOptionsInput>, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuizAnswerCreateNestedManyWithoutResultInput = {
    create?: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput> | QuizAnswerCreateWithoutResultInput[] | QuizAnswerUncheckedCreateWithoutResultInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutResultInput | QuizAnswerCreateOrConnectWithoutResultInput[]
    createMany?: QuizAnswerCreateManyResultInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type InteractiveQuizCreateNestedOneWithoutResultsInput = {
    create?: XOR<InteractiveQuizCreateWithoutResultsInput, InteractiveQuizUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutResultsInput
    connect?: InteractiveQuizWhereUniqueInput
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutResultInput = {
    create?: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput> | QuizAnswerCreateWithoutResultInput[] | QuizAnswerUncheckedCreateWithoutResultInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutResultInput | QuizAnswerCreateOrConnectWithoutResultInput[]
    createMany?: QuizAnswerCreateManyResultInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizAnswerUpdateManyWithoutResultNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput> | QuizAnswerCreateWithoutResultInput[] | QuizAnswerUncheckedCreateWithoutResultInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutResultInput | QuizAnswerCreateOrConnectWithoutResultInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutResultInput | QuizAnswerUpsertWithWhereUniqueWithoutResultInput[]
    createMany?: QuizAnswerCreateManyResultInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutResultInput | QuizAnswerUpdateWithWhereUniqueWithoutResultInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutResultInput | QuizAnswerUpdateManyWithWhereWithoutResultInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type InteractiveQuizUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<InteractiveQuizCreateWithoutResultsInput, InteractiveQuizUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InteractiveQuizCreateOrConnectWithoutResultsInput
    upsert?: InteractiveQuizUpsertWithoutResultsInput
    connect?: InteractiveQuizWhereUniqueInput
    update?: XOR<XOR<InteractiveQuizUpdateToOneWithWhereWithoutResultsInput, InteractiveQuizUpdateWithoutResultsInput>, InteractiveQuizUncheckedUpdateWithoutResultsInput>
  }

  export type QuizAnswerUncheckedUpdateManyWithoutResultNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput> | QuizAnswerCreateWithoutResultInput[] | QuizAnswerUncheckedCreateWithoutResultInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutResultInput | QuizAnswerCreateOrConnectWithoutResultInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutResultInput | QuizAnswerUpsertWithWhereUniqueWithoutResultInput[]
    createMany?: QuizAnswerCreateManyResultInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutResultInput | QuizAnswerUpdateWithWhereUniqueWithoutResultInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutResultInput | QuizAnswerUpdateManyWithWhereWithoutResultInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizResultCreateNestedOneWithoutQuizAnswersInput = {
    create?: XOR<QuizResultCreateWithoutQuizAnswersInput, QuizResultUncheckedCreateWithoutQuizAnswersInput>
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizAnswersInput
    connect?: QuizResultWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuizQuestionUpsertWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutAnswersInput, QuizQuestionUpdateWithoutAnswersInput>, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizResultUpdateOneRequiredWithoutQuizAnswersNestedInput = {
    create?: XOR<QuizResultCreateWithoutQuizAnswersInput, QuizResultUncheckedCreateWithoutQuizAnswersInput>
    connectOrCreate?: QuizResultCreateOrConnectWithoutQuizAnswersInput
    upsert?: QuizResultUpsertWithoutQuizAnswersInput
    connect?: QuizResultWhereUniqueInput
    update?: XOR<XOR<QuizResultUpdateToOneWithWhereWithoutQuizAnswersInput, QuizResultUpdateWithoutQuizAnswersInput>, QuizResultUncheckedUpdateWithoutQuizAnswersInput>
  }

  export type MerchantCreateNestedOneWithoutAffiliateLinksInput = {
    create?: XOR<MerchantCreateWithoutAffiliateLinksInput, MerchantUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutAffiliateLinksInput
    connect?: MerchantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAffiliateLinksInput = {
    create?: XOR<ProductCreateWithoutAffiliateLinksInput, ProductUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAffiliateLinksInput
    connect?: ProductWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutAffiliateLinksInput = {
    create?: XOR<SiteCreateWithoutAffiliateLinksInput, SiteUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAffiliateLinksInput
    connect?: SiteWhereUniqueInput
  }

  export type ConversionCreateNestedManyWithoutAffiliateLinkInput = {
    create?: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput> | ConversionCreateWithoutAffiliateLinkInput[] | ConversionUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateLinkInput | ConversionCreateOrConnectWithoutAffiliateLinkInput[]
    createMany?: ConversionCreateManyAffiliateLinkInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type LinkClickCreateNestedManyWithoutAffiliateLinkInput = {
    create?: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput> | LinkClickCreateWithoutAffiliateLinkInput[] | LinkClickUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: LinkClickCreateOrConnectWithoutAffiliateLinkInput | LinkClickCreateOrConnectWithoutAffiliateLinkInput[]
    createMany?: LinkClickCreateManyAffiliateLinkInputEnvelope
    connect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
  }

  export type ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput = {
    create?: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput> | ConversionCreateWithoutAffiliateLinkInput[] | ConversionUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateLinkInput | ConversionCreateOrConnectWithoutAffiliateLinkInput[]
    createMany?: ConversionCreateManyAffiliateLinkInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput = {
    create?: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput> | LinkClickCreateWithoutAffiliateLinkInput[] | LinkClickUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: LinkClickCreateOrConnectWithoutAffiliateLinkInput | LinkClickCreateOrConnectWithoutAffiliateLinkInput[]
    createMany?: LinkClickCreateManyAffiliateLinkInputEnvelope
    connect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
  }

  export type MerchantUpdateOneWithoutAffiliateLinksNestedInput = {
    create?: XOR<MerchantCreateWithoutAffiliateLinksInput, MerchantUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutAffiliateLinksInput
    upsert?: MerchantUpsertWithoutAffiliateLinksInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutAffiliateLinksInput, MerchantUpdateWithoutAffiliateLinksInput>, MerchantUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type ProductUpdateOneWithoutAffiliateLinksNestedInput = {
    create?: XOR<ProductCreateWithoutAffiliateLinksInput, ProductUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAffiliateLinksInput
    upsert?: ProductUpsertWithoutAffiliateLinksInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAffiliateLinksInput, ProductUpdateWithoutAffiliateLinksInput>, ProductUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput = {
    create?: XOR<SiteCreateWithoutAffiliateLinksInput, SiteUncheckedCreateWithoutAffiliateLinksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAffiliateLinksInput
    upsert?: SiteUpsertWithoutAffiliateLinksInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutAffiliateLinksInput, SiteUpdateWithoutAffiliateLinksInput>, SiteUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type ConversionUpdateManyWithoutAffiliateLinkNestedInput = {
    create?: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput> | ConversionCreateWithoutAffiliateLinkInput[] | ConversionUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateLinkInput | ConversionCreateOrConnectWithoutAffiliateLinkInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutAffiliateLinkInput | ConversionUpsertWithWhereUniqueWithoutAffiliateLinkInput[]
    createMany?: ConversionCreateManyAffiliateLinkInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutAffiliateLinkInput | ConversionUpdateWithWhereUniqueWithoutAffiliateLinkInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutAffiliateLinkInput | ConversionUpdateManyWithWhereWithoutAffiliateLinkInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type LinkClickUpdateManyWithoutAffiliateLinkNestedInput = {
    create?: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput> | LinkClickCreateWithoutAffiliateLinkInput[] | LinkClickUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: LinkClickCreateOrConnectWithoutAffiliateLinkInput | LinkClickCreateOrConnectWithoutAffiliateLinkInput[]
    upsert?: LinkClickUpsertWithWhereUniqueWithoutAffiliateLinkInput | LinkClickUpsertWithWhereUniqueWithoutAffiliateLinkInput[]
    createMany?: LinkClickCreateManyAffiliateLinkInputEnvelope
    set?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    disconnect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    delete?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    connect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    update?: LinkClickUpdateWithWhereUniqueWithoutAffiliateLinkInput | LinkClickUpdateWithWhereUniqueWithoutAffiliateLinkInput[]
    updateMany?: LinkClickUpdateManyWithWhereWithoutAffiliateLinkInput | LinkClickUpdateManyWithWhereWithoutAffiliateLinkInput[]
    deleteMany?: LinkClickScalarWhereInput | LinkClickScalarWhereInput[]
  }

  export type ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput = {
    create?: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput> | ConversionCreateWithoutAffiliateLinkInput[] | ConversionUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateLinkInput | ConversionCreateOrConnectWithoutAffiliateLinkInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutAffiliateLinkInput | ConversionUpsertWithWhereUniqueWithoutAffiliateLinkInput[]
    createMany?: ConversionCreateManyAffiliateLinkInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutAffiliateLinkInput | ConversionUpdateWithWhereUniqueWithoutAffiliateLinkInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutAffiliateLinkInput | ConversionUpdateManyWithWhereWithoutAffiliateLinkInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput = {
    create?: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput> | LinkClickCreateWithoutAffiliateLinkInput[] | LinkClickUncheckedCreateWithoutAffiliateLinkInput[]
    connectOrCreate?: LinkClickCreateOrConnectWithoutAffiliateLinkInput | LinkClickCreateOrConnectWithoutAffiliateLinkInput[]
    upsert?: LinkClickUpsertWithWhereUniqueWithoutAffiliateLinkInput | LinkClickUpsertWithWhereUniqueWithoutAffiliateLinkInput[]
    createMany?: LinkClickCreateManyAffiliateLinkInputEnvelope
    set?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    disconnect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    delete?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    connect?: LinkClickWhereUniqueInput | LinkClickWhereUniqueInput[]
    update?: LinkClickUpdateWithWhereUniqueWithoutAffiliateLinkInput | LinkClickUpdateWithWhereUniqueWithoutAffiliateLinkInput[]
    updateMany?: LinkClickUpdateManyWithWhereWithoutAffiliateLinkInput | LinkClickUpdateManyWithWhereWithoutAffiliateLinkInput[]
    deleteMany?: LinkClickScalarWhereInput | LinkClickScalarWhereInput[]
  }

  export type AffiliateLinkCreateNestedManyWithoutMerchantInput = {
    create?: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput> | AffiliateLinkCreateWithoutMerchantInput[] | AffiliateLinkUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutMerchantInput | AffiliateLinkCreateOrConnectWithoutMerchantInput[]
    createMany?: AffiliateLinkCreateManyMerchantInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type AffiliateLinkUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput> | AffiliateLinkCreateWithoutMerchantInput[] | AffiliateLinkUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutMerchantInput | AffiliateLinkCreateOrConnectWithoutMerchantInput[]
    createMany?: AffiliateLinkCreateManyMerchantInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type AffiliateLinkUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput> | AffiliateLinkCreateWithoutMerchantInput[] | AffiliateLinkUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutMerchantInput | AffiliateLinkCreateOrConnectWithoutMerchantInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutMerchantInput | AffiliateLinkUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: AffiliateLinkCreateManyMerchantInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutMerchantInput | AffiliateLinkUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutMerchantInput | AffiliateLinkUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput> | AffiliateLinkCreateWithoutMerchantInput[] | AffiliateLinkUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutMerchantInput | AffiliateLinkCreateOrConnectWithoutMerchantInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutMerchantInput | AffiliateLinkUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: AffiliateLinkCreateManyMerchantInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutMerchantInput | AffiliateLinkUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutMerchantInput | AffiliateLinkUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type AffiliateLinkCreateNestedOneWithoutLinkClicksInput = {
    create?: XOR<AffiliateLinkCreateWithoutLinkClicksInput, AffiliateLinkUncheckedCreateWithoutLinkClicksInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutLinkClicksInput
    connect?: AffiliateLinkWhereUniqueInput
  }

  export type AffiliateLinkUpdateOneRequiredWithoutLinkClicksNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutLinkClicksInput, AffiliateLinkUncheckedCreateWithoutLinkClicksInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutLinkClicksInput
    upsert?: AffiliateLinkUpsertWithoutLinkClicksInput
    connect?: AffiliateLinkWhereUniqueInput
    update?: XOR<XOR<AffiliateLinkUpdateToOneWithWhereWithoutLinkClicksInput, AffiliateLinkUpdateWithoutLinkClicksInput>, AffiliateLinkUncheckedUpdateWithoutLinkClicksInput>
  }

  export type AffiliateLinkCreateNestedOneWithoutConversionsInput = {
    create?: XOR<AffiliateLinkCreateWithoutConversionsInput, AffiliateLinkUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutConversionsInput
    connect?: AffiliateLinkWhereUniqueInput
  }

  export type AffiliateLinkUpdateOneRequiredWithoutConversionsNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutConversionsInput, AffiliateLinkUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutConversionsInput
    upsert?: AffiliateLinkUpsertWithoutConversionsInput
    connect?: AffiliateLinkWhereUniqueInput
    update?: XOR<XOR<AffiliateLinkUpdateToOneWithWhereWithoutConversionsInput, AffiliateLinkUpdateWithoutConversionsInput>, AffiliateLinkUncheckedUpdateWithoutConversionsInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RecipeIngredientCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type RecipeInstructionCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
  }

  export type RecipeIngredientUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type RecipeInstructionUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    set?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    disconnect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    delete?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    update?: RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInstructionUpdateManyWithWhereWithoutRecipeInput | RecipeInstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    set?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    disconnect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    delete?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    update?: RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInstructionUpdateManyWithWhereWithoutRecipeInput | RecipeInstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    upsert?: RecipeUpsertWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutIngredientsInput, RecipeUpdateWithoutIngredientsInput>, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeCreateNestedOneWithoutInstructionsInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutInstructionsNestedInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    upsert?: RecipeUpsertWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutInstructionsInput, RecipeUpdateWithoutInstructionsInput>, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type ContentCreateNestedOneWithoutVersionsInput = {
    create?: XOR<ContentCreateWithoutVersionsInput, ContentUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutVersionsInput
    connect?: ContentWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<ContentCreateWithoutVersionsInput, ContentUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutVersionsInput
    upsert?: ContentUpsertWithoutVersionsInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutVersionsInput, ContentUpdateWithoutVersionsInput>, ContentUncheckedUpdateWithoutVersionsInput>
  }

  export type SiteCreateNestedManyWithoutCustomNicheInput = {
    create?: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput> | SiteCreateWithoutCustomNicheInput[] | SiteUncheckedCreateWithoutCustomNicheInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCustomNicheInput | SiteCreateOrConnectWithoutCustomNicheInput[]
    createMany?: SiteCreateManyCustomNicheInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type SiteUncheckedCreateNestedManyWithoutCustomNicheInput = {
    create?: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput> | SiteCreateWithoutCustomNicheInput[] | SiteUncheckedCreateWithoutCustomNicheInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCustomNicheInput | SiteCreateOrConnectWithoutCustomNicheInput[]
    createMany?: SiteCreateManyCustomNicheInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type SiteUpdateManyWithoutCustomNicheNestedInput = {
    create?: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput> | SiteCreateWithoutCustomNicheInput[] | SiteUncheckedCreateWithoutCustomNicheInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCustomNicheInput | SiteCreateOrConnectWithoutCustomNicheInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCustomNicheInput | SiteUpsertWithWhereUniqueWithoutCustomNicheInput[]
    createMany?: SiteCreateManyCustomNicheInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCustomNicheInput | SiteUpdateWithWhereUniqueWithoutCustomNicheInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCustomNicheInput | SiteUpdateManyWithWhereWithoutCustomNicheInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type SiteUncheckedUpdateManyWithoutCustomNicheNestedInput = {
    create?: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput> | SiteCreateWithoutCustomNicheInput[] | SiteUncheckedCreateWithoutCustomNicheInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCustomNicheInput | SiteCreateOrConnectWithoutCustomNicheInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCustomNicheInput | SiteUpsertWithWhereUniqueWithoutCustomNicheInput[]
    createMany?: SiteCreateManyCustomNicheInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCustomNicheInput | SiteUpdateWithWhereUniqueWithoutCustomNicheInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCustomNicheInput | SiteUpdateManyWithWhereWithoutCustomNicheInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutAutoBlogPostsInput = {
    create?: XOR<SiteCreateWithoutAutoBlogPostsInput, SiteUncheckedCreateWithoutAutoBlogPostsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAutoBlogPostsInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutAutoBlogPostsNestedInput = {
    create?: XOR<SiteCreateWithoutAutoBlogPostsInput, SiteUncheckedCreateWithoutAutoBlogPostsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAutoBlogPostsInput
    upsert?: SiteUpsertWithoutAutoBlogPostsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutAutoBlogPostsInput, SiteUpdateWithoutAutoBlogPostsInput>, SiteUncheckedUpdateWithoutAutoBlogPostsInput>
  }

  export type SiteCreateNestedOneWithoutContentSchedulesInput = {
    create?: XOR<SiteCreateWithoutContentSchedulesInput, SiteUncheckedCreateWithoutContentSchedulesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutContentSchedulesInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutContentSchedulesNestedInput = {
    create?: XOR<SiteCreateWithoutContentSchedulesInput, SiteUncheckedCreateWithoutContentSchedulesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutContentSchedulesInput
    upsert?: SiteUpsertWithoutContentSchedulesInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutContentSchedulesInput, SiteUpdateWithoutContentSchedulesInput>, SiteUncheckedUpdateWithoutContentSchedulesInput>
  }

  export type ProductCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type SiteCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<SiteCreateWithoutProductCategoriesInput, SiteUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutProductCategoriesInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput> | SiteProductCreateWithoutCategoryInput[] | SiteProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutCategoryInput | SiteProductCreateOrConnectWithoutCategoryInput[]
    createMany?: SiteProductCreateManyCategoryInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type SiteProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput> | SiteProductCreateWithoutCategoryInput[] | SiteProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutCategoryInput | SiteProductCreateOrConnectWithoutCategoryInput[]
    createMany?: SiteProductCreateManyCategoryInputEnvelope
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
  }

  export type ProductCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ProductCategoryUpsertWithoutChildrenInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutChildrenInput, ProductCategoryUpdateWithoutChildrenInput>, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type SiteUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<SiteCreateWithoutProductCategoriesInput, SiteUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutProductCategoriesInput
    upsert?: SiteUpsertWithoutProductCategoriesInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutProductCategoriesInput, SiteUpdateWithoutProductCategoriesInput>, SiteUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type SiteProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput> | SiteProductCreateWithoutCategoryInput[] | SiteProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutCategoryInput | SiteProductCreateOrConnectWithoutCategoryInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutCategoryInput | SiteProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SiteProductCreateManyCategoryInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutCategoryInput | SiteProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutCategoryInput | SiteProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type SiteProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput> | SiteProductCreateWithoutCategoryInput[] | SiteProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SiteProductCreateOrConnectWithoutCategoryInput | SiteProductCreateOrConnectWithoutCategoryInput[]
    upsert?: SiteProductUpsertWithWhereUniqueWithoutCategoryInput | SiteProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SiteProductCreateManyCategoryInputEnvelope
    set?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    disconnect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    delete?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    connect?: SiteProductWhereUniqueInput | SiteProductWhereUniqueInput[]
    update?: SiteProductUpdateWithWhereUniqueWithoutCategoryInput | SiteProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SiteProductUpdateManyWithWhereWithoutCategoryInput | SiteProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ContentTypeCreateWithoutContentInput = {
    name: string
    description?: string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentTypeUncheckedCreateWithoutContentInput = {
    id?: number
    name: string
    description?: string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentTypeCreateOrConnectWithoutContentInput = {
    where: ContentTypeWhereUniqueInput
    create: XOR<ContentTypeCreateWithoutContentInput, ContentTypeUncheckedCreateWithoutContentInput>
  }

  export type ContentCategoryCreateWithoutContentInput = {
    category: CategoryCreateNestedOneWithoutContentInput
  }

  export type ContentCategoryUncheckedCreateWithoutContentInput = {
    categoryId: number
  }

  export type ContentCategoryCreateOrConnectWithoutContentInput = {
    where: ContentCategoryWhereUniqueInput
    create: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput>
  }

  export type ContentCategoryCreateManyContentInputEnvelope = {
    data: ContentCategoryCreateManyContentInput | ContentCategoryCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentTagCreateWithoutContentInput = {
    tag: TagCreateNestedOneWithoutContentInput
  }

  export type ContentTagUncheckedCreateWithoutContentInput = {
    tagId: number
  }

  export type ContentTagCreateOrConnectWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    create: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput>
  }

  export type ContentTagCreateManyContentInputEnvelope = {
    data: ContentTagCreateManyContentInput | ContentTagCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentVersionCreateWithoutContentInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
  }

  export type ContentVersionUncheckedCreateWithoutContentInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
  }

  export type ContentVersionCreateOrConnectWithoutContentInput = {
    where: ContentVersionWhereUniqueInput
    create: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput>
  }

  export type ContentVersionCreateManyContentInputEnvelope = {
    data: ContentVersionCreateManyContentInput | ContentVersionCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type SiteContentCreateWithoutContentInput = {
    site: SiteCreateNestedOneWithoutContentInput
  }

  export type SiteContentUncheckedCreateWithoutContentInput = {
    siteId: string
  }

  export type SiteContentCreateOrConnectWithoutContentInput = {
    where: SiteContentWhereUniqueInput
    create: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput>
  }

  export type SiteContentCreateManyContentInputEnvelope = {
    data: SiteContentCreateManyContentInput | SiteContentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type SiteMediaCreateWithoutContentInput = {
    mediaAsset: MediaAssetCreateNestedOneWithoutSiteMediaInput
    site: SiteCreateNestedOneWithoutMediaInput
  }

  export type SiteMediaUncheckedCreateWithoutContentInput = {
    siteId: string
    mediaAssetId: string
  }

  export type SiteMediaCreateOrConnectWithoutContentInput = {
    where: SiteMediaWhereUniqueInput
    create: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput>
  }

  export type SiteMediaCreateManyContentInputEnvelope = {
    data: SiteMediaCreateManyContentInput | SiteMediaCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentTypeUpsertWithoutContentInput = {
    update: XOR<ContentTypeUpdateWithoutContentInput, ContentTypeUncheckedUpdateWithoutContentInput>
    create: XOR<ContentTypeCreateWithoutContentInput, ContentTypeUncheckedCreateWithoutContentInput>
    where?: ContentTypeWhereInput
  }

  export type ContentTypeUpdateToOneWithWhereWithoutContentInput = {
    where?: ContentTypeWhereInput
    data: XOR<ContentTypeUpdateWithoutContentInput, ContentTypeUncheckedUpdateWithoutContentInput>
  }

  export type ContentTypeUpdateWithoutContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentTypeUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentCategoryUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentCategoryWhereUniqueInput
    update: XOR<ContentCategoryUpdateWithoutContentInput, ContentCategoryUncheckedUpdateWithoutContentInput>
    create: XOR<ContentCategoryCreateWithoutContentInput, ContentCategoryUncheckedCreateWithoutContentInput>
  }

  export type ContentCategoryUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentCategoryWhereUniqueInput
    data: XOR<ContentCategoryUpdateWithoutContentInput, ContentCategoryUncheckedUpdateWithoutContentInput>
  }

  export type ContentCategoryUpdateManyWithWhereWithoutContentInput = {
    where: ContentCategoryScalarWhereInput
    data: XOR<ContentCategoryUpdateManyMutationInput, ContentCategoryUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentCategoryScalarWhereInput = {
    AND?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
    OR?: ContentCategoryScalarWhereInput[]
    NOT?: ContentCategoryScalarWhereInput | ContentCategoryScalarWhereInput[]
    contentId?: UuidFilter<"ContentCategory"> | string
    categoryId?: IntFilter<"ContentCategory"> | number
  }

  export type ContentTagUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    update: XOR<ContentTagUpdateWithoutContentInput, ContentTagUncheckedUpdateWithoutContentInput>
    create: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput>
  }

  export type ContentTagUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    data: XOR<ContentTagUpdateWithoutContentInput, ContentTagUncheckedUpdateWithoutContentInput>
  }

  export type ContentTagUpdateManyWithWhereWithoutContentInput = {
    where: ContentTagScalarWhereInput
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentTagScalarWhereInput = {
    AND?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
    OR?: ContentTagScalarWhereInput[]
    NOT?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
    contentId?: UuidFilter<"ContentTag"> | string
    tagId?: IntFilter<"ContentTag"> | number
  }

  export type ContentVersionUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentVersionWhereUniqueInput
    update: XOR<ContentVersionUpdateWithoutContentInput, ContentVersionUncheckedUpdateWithoutContentInput>
    create: XOR<ContentVersionCreateWithoutContentInput, ContentVersionUncheckedCreateWithoutContentInput>
  }

  export type ContentVersionUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentVersionWhereUniqueInput
    data: XOR<ContentVersionUpdateWithoutContentInput, ContentVersionUncheckedUpdateWithoutContentInput>
  }

  export type ContentVersionUpdateManyWithWhereWithoutContentInput = {
    where: ContentVersionScalarWhereInput
    data: XOR<ContentVersionUpdateManyMutationInput, ContentVersionUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentVersionScalarWhereInput = {
    AND?: ContentVersionScalarWhereInput | ContentVersionScalarWhereInput[]
    OR?: ContentVersionScalarWhereInput[]
    NOT?: ContentVersionScalarWhereInput | ContentVersionScalarWhereInput[]
    id?: UuidFilter<"ContentVersion"> | string
    contentId?: UuidFilter<"ContentVersion"> | string
    version?: IntFilter<"ContentVersion"> | number
    data?: JsonFilter<"ContentVersion">
    createdBy?: UuidNullableFilter<"ContentVersion"> | string | null
    createdAt?: DateTimeNullableFilter<"ContentVersion"> | Date | string | null
  }

  export type SiteContentUpsertWithWhereUniqueWithoutContentInput = {
    where: SiteContentWhereUniqueInput
    update: XOR<SiteContentUpdateWithoutContentInput, SiteContentUncheckedUpdateWithoutContentInput>
    create: XOR<SiteContentCreateWithoutContentInput, SiteContentUncheckedCreateWithoutContentInput>
  }

  export type SiteContentUpdateWithWhereUniqueWithoutContentInput = {
    where: SiteContentWhereUniqueInput
    data: XOR<SiteContentUpdateWithoutContentInput, SiteContentUncheckedUpdateWithoutContentInput>
  }

  export type SiteContentUpdateManyWithWhereWithoutContentInput = {
    where: SiteContentScalarWhereInput
    data: XOR<SiteContentUpdateManyMutationInput, SiteContentUncheckedUpdateManyWithoutContentInput>
  }

  export type SiteContentScalarWhereInput = {
    AND?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
    OR?: SiteContentScalarWhereInput[]
    NOT?: SiteContentScalarWhereInput | SiteContentScalarWhereInput[]
    siteId?: UuidFilter<"SiteContent"> | string
    contentId?: UuidFilter<"SiteContent"> | string
  }

  export type SiteMediaUpsertWithWhereUniqueWithoutContentInput = {
    where: SiteMediaWhereUniqueInput
    update: XOR<SiteMediaUpdateWithoutContentInput, SiteMediaUncheckedUpdateWithoutContentInput>
    create: XOR<SiteMediaCreateWithoutContentInput, SiteMediaUncheckedCreateWithoutContentInput>
  }

  export type SiteMediaUpdateWithWhereUniqueWithoutContentInput = {
    where: SiteMediaWhereUniqueInput
    data: XOR<SiteMediaUpdateWithoutContentInput, SiteMediaUncheckedUpdateWithoutContentInput>
  }

  export type SiteMediaUpdateManyWithWhereWithoutContentInput = {
    where: SiteMediaScalarWhereInput
    data: XOR<SiteMediaUpdateManyMutationInput, SiteMediaUncheckedUpdateManyWithoutContentInput>
  }

  export type SiteMediaScalarWhereInput = {
    AND?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
    OR?: SiteMediaScalarWhereInput[]
    NOT?: SiteMediaScalarWhereInput | SiteMediaScalarWhereInput[]
    siteId?: UuidFilter<"SiteMedia"> | string
    contentId?: UuidFilter<"SiteMedia"> | string
    mediaAssetId?: UuidFilter<"SiteMedia"> | string
  }

  export type ContentCreateWithoutContentTypeInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutContentTypeInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutContentTypeInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput>
  }

  export type ContentCreateManyContentTypeInputEnvelope = {
    data: ContentCreateManyContentTypeInput | ContentCreateManyContentTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContentUpsertWithWhereUniqueWithoutContentTypeInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutContentTypeInput, ContentUncheckedUpdateWithoutContentTypeInput>
    create: XOR<ContentCreateWithoutContentTypeInput, ContentUncheckedCreateWithoutContentTypeInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutContentTypeInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutContentTypeInput, ContentUncheckedUpdateWithoutContentTypeInput>
  }

  export type ContentUpdateManyWithWhereWithoutContentTypeInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutContentTypeInput>
  }

  export type ContentScalarWhereInput = {
    AND?: ContentScalarWhereInput | ContentScalarWhereInput[]
    OR?: ContentScalarWhereInput[]
    NOT?: ContentScalarWhereInput | ContentScalarWhereInput[]
    id?: UuidFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    slug?: StringFilter<"Content"> | string
    contentTypeId?: IntFilter<"Content"> | number
    data?: JsonFilter<"Content">
    status?: StringFilter<"Content"> | string
    createdBy?: UuidNullableFilter<"Content"> | string | null
    updatedBy?: UuidNullableFilter<"Content"> | string | null
    createdAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    version?: IntNullableFilter<"Content"> | number | null
    scheduledPublishAt?: DateTimeNullableFilter<"Content"> | Date | string | null
  }

  export type CategoryCreateWithoutChildrenInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    content?: ContentCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    parentId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    content?: ContentCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: CategoryCreateNestedManyWithoutParentInput
    content?: ContentCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    content?: ContentCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ContentCategoryCreateWithoutCategoryInput = {
    content: ContentCreateNestedOneWithoutCategoriesInput
  }

  export type ContentCategoryUncheckedCreateWithoutCategoryInput = {
    contentId: string
  }

  export type ContentCategoryCreateOrConnectWithoutCategoryInput = {
    where: ContentCategoryWhereUniqueInput
    create: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ContentCategoryCreateManyCategoryInputEnvelope = {
    data: ContentCategoryCreateManyCategoryInput | ContentCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    content?: ContentCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    parentId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
  }

  export type ContentCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ContentCategoryWhereUniqueInput
    update: XOR<ContentCategoryUpdateWithoutCategoryInput, ContentCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ContentCategoryCreateWithoutCategoryInput, ContentCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ContentCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ContentCategoryWhereUniqueInput
    data: XOR<ContentCategoryUpdateWithoutCategoryInput, ContentCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ContentCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ContentCategoryScalarWhereInput
    data: XOR<ContentCategoryUpdateManyMutationInput, ContentCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutContentInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutContentInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    parentId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutContentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
  }

  export type ContentCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutCategoriesInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutCategoriesInput, ContentUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryUpsertWithoutContentInput = {
    update: XOR<CategoryUpdateWithoutContentInput, CategoryUncheckedUpdateWithoutContentInput>
    create: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutContentInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutContentInput, CategoryUncheckedUpdateWithoutContentInput>
  }

  export type CategoryUpdateWithoutContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ContentUpsertWithoutCategoriesInput = {
    update: XOR<ContentUpdateWithoutCategoriesInput, ContentUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ContentCreateWithoutCategoriesInput, ContentUncheckedCreateWithoutCategoriesInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutCategoriesInput, ContentUncheckedUpdateWithoutCategoriesInput>
  }

  export type ContentUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentTagCreateWithoutTagInput = {
    content: ContentCreateNestedOneWithoutTagsInput
  }

  export type ContentTagUncheckedCreateWithoutTagInput = {
    contentId: string
  }

  export type ContentTagCreateOrConnectWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    create: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput>
  }

  export type ContentTagCreateManyTagInputEnvelope = {
    data: ContentTagCreateManyTagInput | ContentTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ContentTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    update: XOR<ContentTagUpdateWithoutTagInput, ContentTagUncheckedUpdateWithoutTagInput>
    create: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput>
  }

  export type ContentTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    data: XOR<ContentTagUpdateWithoutTagInput, ContentTagUncheckedUpdateWithoutTagInput>
  }

  export type ContentTagUpdateManyWithWhereWithoutTagInput = {
    where: ContentTagScalarWhereInput
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ContentCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutTagsInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutTagsInput, ContentUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutContentInput = {
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagUncheckedCreateWithoutContentInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TagCreateOrConnectWithoutContentInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutContentInput, TagUncheckedCreateWithoutContentInput>
  }

  export type ContentUpsertWithoutTagsInput = {
    update: XOR<ContentUpdateWithoutTagsInput, ContentUncheckedUpdateWithoutTagsInput>
    create: XOR<ContentCreateWithoutTagsInput, ContentUncheckedCreateWithoutTagsInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutTagsInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutTagsInput, ContentUncheckedUpdateWithoutTagsInput>
  }

  export type ContentUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type TagUpsertWithoutContentInput = {
    update: XOR<TagUpdateWithoutContentInput, TagUncheckedUpdateWithoutContentInput>
    create: XOR<TagCreateWithoutContentInput, TagUncheckedCreateWithoutContentInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutContentInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutContentInput, TagUncheckedUpdateWithoutContentInput>
  }

  export type TagUpdateWithoutContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AffiliateLinkCreateWithoutSiteInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    merchant?: MerchantCreateNestedOneWithoutAffiliateLinksInput
    product?: ProductCreateNestedOneWithoutAffiliateLinksInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutSiteInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput>
  }

  export type AffiliateLinkCreateManySiteInputEnvelope = {
    data: AffiliateLinkCreateManySiteInput | AffiliateLinkCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type AutoBlogPostCreateWithoutSiteInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AutoBlogPostUncheckedCreateWithoutSiteInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AutoBlogPostCreateOrConnectWithoutSiteInput = {
    where: AutoBlogPostWhereUniqueInput
    create: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput>
  }

  export type AutoBlogPostCreateManySiteInputEnvelope = {
    data: AutoBlogPostCreateManySiteInput | AutoBlogPostCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type ContentScheduleCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentScheduleUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentScheduleCreateOrConnectWithoutSiteInput = {
    where: ContentScheduleWhereUniqueInput
    create: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput>
  }

  export type ContentScheduleCreateManySiteInputEnvelope = {
    data: ContentScheduleCreateManySiteInput | ContentScheduleCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type InteractiveQuizCreateWithoutSiteInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    results?: QuizResultCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizUncheckedCreateWithoutSiteInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    results?: QuizResultUncheckedCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizCreateOrConnectWithoutSiteInput = {
    where: InteractiveQuizWhereUniqueInput
    create: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput>
  }

  export type InteractiveQuizCreateManySiteInputEnvelope = {
    data: InteractiveQuizCreateManySiteInput | InteractiveQuizCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type PriceAlertCreateWithoutSiteInput = {
    id?: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
  }

  export type PriceAlertUncheckedCreateWithoutSiteInput = {
    id?: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
  }

  export type PriceAlertCreateOrConnectWithoutSiteInput = {
    where: PriceAlertWhereUniqueInput
    create: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput>
  }

  export type PriceAlertCreateManySiteInputEnvelope = {
    data: PriceAlertCreateManySiteInput | PriceAlertCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: SiteProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: SiteProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutSiteInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput>
  }

  export type ProductCategoryCreateManySiteInputEnvelope = {
    data: ProductCategoryCreateManySiteInput | ProductCategoryCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type ProductCustomFieldCreateWithoutSiteInput = {
    id?: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCustomFieldsInput
  }

  export type ProductCustomFieldUncheckedCreateWithoutSiteInput = {
    id?: string
    productId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCustomFieldCreateOrConnectWithoutSiteInput = {
    where: ProductCustomFieldWhereUniqueInput
    create: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput>
  }

  export type ProductCustomFieldCreateManySiteInputEnvelope = {
    data: ProductCustomFieldCreateManySiteInput | ProductCustomFieldCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type SiteContentCreateWithoutSiteInput = {
    content: ContentCreateNestedOneWithoutSiteContentInput
  }

  export type SiteContentUncheckedCreateWithoutSiteInput = {
    contentId: string
  }

  export type SiteContentCreateOrConnectWithoutSiteInput = {
    where: SiteContentWhereUniqueInput
    create: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput>
  }

  export type SiteContentCreateManySiteInputEnvelope = {
    data: SiteContentCreateManySiteInput | SiteContentCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type SiteMediaCreateWithoutSiteInput = {
    content: ContentCreateNestedOneWithoutMediaInput
    mediaAsset: MediaAssetCreateNestedOneWithoutSiteMediaInput
  }

  export type SiteMediaUncheckedCreateWithoutSiteInput = {
    contentId: string
    mediaAssetId: string
  }

  export type SiteMediaCreateOrConnectWithoutSiteInput = {
    where: SiteMediaWhereUniqueInput
    create: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput>
  }

  export type SiteMediaCreateManySiteInputEnvelope = {
    data: SiteMediaCreateManySiteInput | SiteMediaCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type SiteProductCreateWithoutSiteInput = {
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSiteProductsInput
  }

  export type SiteProductUncheckedCreateWithoutSiteInput = {
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type SiteProductCreateOrConnectWithoutSiteInput = {
    where: SiteProductWhereUniqueInput
    create: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput>
  }

  export type SiteProductCreateManySiteInputEnvelope = {
    data: SiteProductCreateManySiteInput | SiteProductCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type CustomNicheCreateWithoutSitesInput = {
    id?: string
    name: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    competitionLevel?: string | null
    profitabilityScore?: number | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CustomNicheUncheckedCreateWithoutSitesInput = {
    id?: string
    name: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    competitionLevel?: string | null
    profitabilityScore?: number | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CustomNicheCreateOrConnectWithoutSitesInput = {
    where: CustomNicheWhereUniqueInput
    create: XOR<CustomNicheCreateWithoutSitesInput, CustomNicheUncheckedCreateWithoutSitesInput>
  }

  export type AffiliateLinkUpsertWithWhereUniqueWithoutSiteInput = {
    where: AffiliateLinkWhereUniqueInput
    update: XOR<AffiliateLinkUpdateWithoutSiteInput, AffiliateLinkUncheckedUpdateWithoutSiteInput>
    create: XOR<AffiliateLinkCreateWithoutSiteInput, AffiliateLinkUncheckedCreateWithoutSiteInput>
  }

  export type AffiliateLinkUpdateWithWhereUniqueWithoutSiteInput = {
    where: AffiliateLinkWhereUniqueInput
    data: XOR<AffiliateLinkUpdateWithoutSiteInput, AffiliateLinkUncheckedUpdateWithoutSiteInput>
  }

  export type AffiliateLinkUpdateManyWithWhereWithoutSiteInput = {
    where: AffiliateLinkScalarWhereInput
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyWithoutSiteInput>
  }

  export type AffiliateLinkScalarWhereInput = {
    AND?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
    OR?: AffiliateLinkScalarWhereInput[]
    NOT?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
    id?: UuidFilter<"AffiliateLink"> | string
    name?: StringFilter<"AffiliateLink"> | string
    originalUrl?: StringFilter<"AffiliateLink"> | string
    affiliateUrl?: StringFilter<"AffiliateLink"> | string
    siteId?: UuidFilter<"AffiliateLink"> | string
    createdBy?: UuidNullableFilter<"AffiliateLink"> | string | null
    createdAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    productId?: UuidNullableFilter<"AffiliateLink"> | string | null
    merchantId?: UuidNullableFilter<"AffiliateLink"> | string | null
    displayText?: StringNullableFilter<"AffiliateLink"> | string | null
    trackingId?: StringNullableFilter<"AffiliateLink"> | string | null
    status?: StringFilter<"AffiliateLink"> | string
    commissionInfo?: JsonNullableFilter<"AffiliateLink">
    expirationDate?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
  }

  export type AutoBlogPostUpsertWithWhereUniqueWithoutSiteInput = {
    where: AutoBlogPostWhereUniqueInput
    update: XOR<AutoBlogPostUpdateWithoutSiteInput, AutoBlogPostUncheckedUpdateWithoutSiteInput>
    create: XOR<AutoBlogPostCreateWithoutSiteInput, AutoBlogPostUncheckedCreateWithoutSiteInput>
  }

  export type AutoBlogPostUpdateWithWhereUniqueWithoutSiteInput = {
    where: AutoBlogPostWhereUniqueInput
    data: XOR<AutoBlogPostUpdateWithoutSiteInput, AutoBlogPostUncheckedUpdateWithoutSiteInput>
  }

  export type AutoBlogPostUpdateManyWithWhereWithoutSiteInput = {
    where: AutoBlogPostScalarWhereInput
    data: XOR<AutoBlogPostUpdateManyMutationInput, AutoBlogPostUncheckedUpdateManyWithoutSiteInput>
  }

  export type AutoBlogPostScalarWhereInput = {
    AND?: AutoBlogPostScalarWhereInput | AutoBlogPostScalarWhereInput[]
    OR?: AutoBlogPostScalarWhereInput[]
    NOT?: AutoBlogPostScalarWhereInput | AutoBlogPostScalarWhereInput[]
    id?: UuidFilter<"AutoBlogPost"> | string
    siteId?: UuidFilter<"AutoBlogPost"> | string
    title?: StringFilter<"AutoBlogPost"> | string
    content?: StringFilter<"AutoBlogPost"> | string
    summary?: StringNullableFilter<"AutoBlogPost"> | string | null
    keyTakeaways?: JsonNullableFilter<"AutoBlogPost">
    featuredImage?: StringNullableFilter<"AutoBlogPost"> | string | null
    status?: StringFilter<"AutoBlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    seoData?: JsonNullableFilter<"AutoBlogPost">
    tags?: JsonNullableFilter<"AutoBlogPost">
    category?: StringNullableFilter<"AutoBlogPost"> | string | null
    postType?: StringFilter<"AutoBlogPost"> | string
    wordCount?: IntNullableFilter<"AutoBlogPost"> | number | null
    readingTime?: IntNullableFilter<"AutoBlogPost"> | number | null
    affiliateLinks?: JsonNullableFilter<"AutoBlogPost">
    internalLinks?: JsonNullableFilter<"AutoBlogPost">
    externalLinks?: JsonNullableFilter<"AutoBlogPost">
    aiProvider?: StringNullableFilter<"AutoBlogPost"> | string | null
    generationCost?: DecimalNullableFilter<"AutoBlogPost"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AutoBlogPost"> | Date | string | null
  }

  export type ContentScheduleUpsertWithWhereUniqueWithoutSiteInput = {
    where: ContentScheduleWhereUniqueInput
    update: XOR<ContentScheduleUpdateWithoutSiteInput, ContentScheduleUncheckedUpdateWithoutSiteInput>
    create: XOR<ContentScheduleCreateWithoutSiteInput, ContentScheduleUncheckedCreateWithoutSiteInput>
  }

  export type ContentScheduleUpdateWithWhereUniqueWithoutSiteInput = {
    where: ContentScheduleWhereUniqueInput
    data: XOR<ContentScheduleUpdateWithoutSiteInput, ContentScheduleUncheckedUpdateWithoutSiteInput>
  }

  export type ContentScheduleUpdateManyWithWhereWithoutSiteInput = {
    where: ContentScheduleScalarWhereInput
    data: XOR<ContentScheduleUpdateManyMutationInput, ContentScheduleUncheckedUpdateManyWithoutSiteInput>
  }

  export type ContentScheduleScalarWhereInput = {
    AND?: ContentScheduleScalarWhereInput | ContentScheduleScalarWhereInput[]
    OR?: ContentScheduleScalarWhereInput[]
    NOT?: ContentScheduleScalarWhereInput | ContentScheduleScalarWhereInput[]
    id?: UuidFilter<"ContentSchedule"> | string
    siteId?: UuidFilter<"ContentSchedule"> | string
    name?: StringFilter<"ContentSchedule"> | string
    description?: StringNullableFilter<"ContentSchedule"> | string | null
    frequency?: StringFilter<"ContentSchedule"> | string
    interval?: IntFilter<"ContentSchedule"> | number
    postTypes?: JsonFilter<"ContentSchedule">
    categories?: JsonFilter<"ContentSchedule">
    keywords?: JsonFilter<"ContentSchedule">
    isActive?: BoolFilter<"ContentSchedule"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ContentSchedule"> | Date | string | null
  }

  export type InteractiveQuizUpsertWithWhereUniqueWithoutSiteInput = {
    where: InteractiveQuizWhereUniqueInput
    update: XOR<InteractiveQuizUpdateWithoutSiteInput, InteractiveQuizUncheckedUpdateWithoutSiteInput>
    create: XOR<InteractiveQuizCreateWithoutSiteInput, InteractiveQuizUncheckedCreateWithoutSiteInput>
  }

  export type InteractiveQuizUpdateWithWhereUniqueWithoutSiteInput = {
    where: InteractiveQuizWhereUniqueInput
    data: XOR<InteractiveQuizUpdateWithoutSiteInput, InteractiveQuizUncheckedUpdateWithoutSiteInput>
  }

  export type InteractiveQuizUpdateManyWithWhereWithoutSiteInput = {
    where: InteractiveQuizScalarWhereInput
    data: XOR<InteractiveQuizUpdateManyMutationInput, InteractiveQuizUncheckedUpdateManyWithoutSiteInput>
  }

  export type InteractiveQuizScalarWhereInput = {
    AND?: InteractiveQuizScalarWhereInput | InteractiveQuizScalarWhereInput[]
    OR?: InteractiveQuizScalarWhereInput[]
    NOT?: InteractiveQuizScalarWhereInput | InteractiveQuizScalarWhereInput[]
    id?: UuidFilter<"InteractiveQuiz"> | string
    siteId?: UuidFilter<"InteractiveQuiz"> | string
    title?: StringFilter<"InteractiveQuiz"> | string
    description?: StringNullableFilter<"InteractiveQuiz"> | string | null
    isActive?: BoolFilter<"InteractiveQuiz"> | boolean
    createdAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"InteractiveQuiz"> | Date | string | null
  }

  export type PriceAlertUpsertWithWhereUniqueWithoutSiteInput = {
    where: PriceAlertWhereUniqueInput
    update: XOR<PriceAlertUpdateWithoutSiteInput, PriceAlertUncheckedUpdateWithoutSiteInput>
    create: XOR<PriceAlertCreateWithoutSiteInput, PriceAlertUncheckedCreateWithoutSiteInput>
  }

  export type PriceAlertUpdateWithWhereUniqueWithoutSiteInput = {
    where: PriceAlertWhereUniqueInput
    data: XOR<PriceAlertUpdateWithoutSiteInput, PriceAlertUncheckedUpdateWithoutSiteInput>
  }

  export type PriceAlertUpdateManyWithWhereWithoutSiteInput = {
    where: PriceAlertScalarWhereInput
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyWithoutSiteInput>
  }

  export type PriceAlertScalarWhereInput = {
    AND?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
    OR?: PriceAlertScalarWhereInput[]
    NOT?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
    id?: UuidFilter<"PriceAlert"> | string
    siteId?: UuidFilter<"PriceAlert"> | string
    productId?: UuidFilter<"PriceAlert"> | string
    alertType?: StringFilter<"PriceAlert"> | string
    threshold?: DecimalFilter<"PriceAlert"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    createdAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutSiteInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutSiteInput, ProductCategoryUncheckedUpdateWithoutSiteInput>
    create: XOR<ProductCategoryCreateWithoutSiteInput, ProductCategoryUncheckedCreateWithoutSiteInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutSiteInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutSiteInput, ProductCategoryUncheckedUpdateWithoutSiteInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutSiteInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutSiteInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: UuidFilter<"ProductCategory"> | string
    siteId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
    displayOrder?: IntFilter<"ProductCategory"> | number
    isActive?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
    seoKeywords?: StringNullableFilter<"ProductCategory"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
  }

  export type ProductCustomFieldUpsertWithWhereUniqueWithoutSiteInput = {
    where: ProductCustomFieldWhereUniqueInput
    update: XOR<ProductCustomFieldUpdateWithoutSiteInput, ProductCustomFieldUncheckedUpdateWithoutSiteInput>
    create: XOR<ProductCustomFieldCreateWithoutSiteInput, ProductCustomFieldUncheckedCreateWithoutSiteInput>
  }

  export type ProductCustomFieldUpdateWithWhereUniqueWithoutSiteInput = {
    where: ProductCustomFieldWhereUniqueInput
    data: XOR<ProductCustomFieldUpdateWithoutSiteInput, ProductCustomFieldUncheckedUpdateWithoutSiteInput>
  }

  export type ProductCustomFieldUpdateManyWithWhereWithoutSiteInput = {
    where: ProductCustomFieldScalarWhereInput
    data: XOR<ProductCustomFieldUpdateManyMutationInput, ProductCustomFieldUncheckedUpdateManyWithoutSiteInput>
  }

  export type ProductCustomFieldScalarWhereInput = {
    AND?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
    OR?: ProductCustomFieldScalarWhereInput[]
    NOT?: ProductCustomFieldScalarWhereInput | ProductCustomFieldScalarWhereInput[]
    id?: UuidFilter<"ProductCustomField"> | string
    productId?: UuidFilter<"ProductCustomField"> | string
    siteId?: UuidFilter<"ProductCustomField"> | string
    fieldName?: StringFilter<"ProductCustomField"> | string
    fieldType?: StringFilter<"ProductCustomField"> | string
    fieldValue?: StringFilter<"ProductCustomField"> | string
    displayOrder?: IntFilter<"ProductCustomField"> | number
    isRequired?: BoolFilter<"ProductCustomField"> | boolean
    createdAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductCustomField"> | Date | string | null
  }

  export type SiteContentUpsertWithWhereUniqueWithoutSiteInput = {
    where: SiteContentWhereUniqueInput
    update: XOR<SiteContentUpdateWithoutSiteInput, SiteContentUncheckedUpdateWithoutSiteInput>
    create: XOR<SiteContentCreateWithoutSiteInput, SiteContentUncheckedCreateWithoutSiteInput>
  }

  export type SiteContentUpdateWithWhereUniqueWithoutSiteInput = {
    where: SiteContentWhereUniqueInput
    data: XOR<SiteContentUpdateWithoutSiteInput, SiteContentUncheckedUpdateWithoutSiteInput>
  }

  export type SiteContentUpdateManyWithWhereWithoutSiteInput = {
    where: SiteContentScalarWhereInput
    data: XOR<SiteContentUpdateManyMutationInput, SiteContentUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteMediaUpsertWithWhereUniqueWithoutSiteInput = {
    where: SiteMediaWhereUniqueInput
    update: XOR<SiteMediaUpdateWithoutSiteInput, SiteMediaUncheckedUpdateWithoutSiteInput>
    create: XOR<SiteMediaCreateWithoutSiteInput, SiteMediaUncheckedCreateWithoutSiteInput>
  }

  export type SiteMediaUpdateWithWhereUniqueWithoutSiteInput = {
    where: SiteMediaWhereUniqueInput
    data: XOR<SiteMediaUpdateWithoutSiteInput, SiteMediaUncheckedUpdateWithoutSiteInput>
  }

  export type SiteMediaUpdateManyWithWhereWithoutSiteInput = {
    where: SiteMediaScalarWhereInput
    data: XOR<SiteMediaUpdateManyMutationInput, SiteMediaUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteProductUpsertWithWhereUniqueWithoutSiteInput = {
    where: SiteProductWhereUniqueInput
    update: XOR<SiteProductUpdateWithoutSiteInput, SiteProductUncheckedUpdateWithoutSiteInput>
    create: XOR<SiteProductCreateWithoutSiteInput, SiteProductUncheckedCreateWithoutSiteInput>
  }

  export type SiteProductUpdateWithWhereUniqueWithoutSiteInput = {
    where: SiteProductWhereUniqueInput
    data: XOR<SiteProductUpdateWithoutSiteInput, SiteProductUncheckedUpdateWithoutSiteInput>
  }

  export type SiteProductUpdateManyWithWhereWithoutSiteInput = {
    where: SiteProductScalarWhereInput
    data: XOR<SiteProductUpdateManyMutationInput, SiteProductUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteProductScalarWhereInput = {
    AND?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
    OR?: SiteProductScalarWhereInput[]
    NOT?: SiteProductScalarWhereInput | SiteProductScalarWhereInput[]
    siteId?: UuidFilter<"SiteProduct"> | string
    productId?: UuidFilter<"SiteProduct"> | string
    price?: DecimalFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SiteProduct"> | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFilter<"SiteProduct"> | boolean
    createdAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SiteProduct"> | Date | string | null
    categoryId?: UuidNullableFilter<"SiteProduct"> | string | null
  }

  export type CustomNicheUpsertWithoutSitesInput = {
    update: XOR<CustomNicheUpdateWithoutSitesInput, CustomNicheUncheckedUpdateWithoutSitesInput>
    create: XOR<CustomNicheCreateWithoutSitesInput, CustomNicheUncheckedCreateWithoutSitesInput>
    where?: CustomNicheWhereInput
  }

  export type CustomNicheUpdateToOneWithWhereWithoutSitesInput = {
    where?: CustomNicheWhereInput
    data: XOR<CustomNicheUpdateWithoutSitesInput, CustomNicheUncheckedUpdateWithoutSitesInput>
  }

  export type CustomNicheUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomNicheUncheckedUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    competitionLevel?: NullableStringFieldUpdateOperationsInput | string | null
    profitabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentCreateWithoutSiteContentInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutSiteContentInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutSiteContentInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutSiteContentInput, ContentUncheckedCreateWithoutSiteContentInput>
  }

  export type SiteCreateWithoutContentInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutContentInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutContentInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutContentInput, SiteUncheckedCreateWithoutContentInput>
  }

  export type ContentUpsertWithoutSiteContentInput = {
    update: XOR<ContentUpdateWithoutSiteContentInput, ContentUncheckedUpdateWithoutSiteContentInput>
    create: XOR<ContentCreateWithoutSiteContentInput, ContentUncheckedCreateWithoutSiteContentInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutSiteContentInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutSiteContentInput, ContentUncheckedUpdateWithoutSiteContentInput>
  }

  export type ContentUpdateWithoutSiteContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutSiteContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type SiteUpsertWithoutContentInput = {
    update: XOR<SiteUpdateWithoutContentInput, SiteUncheckedUpdateWithoutContentInput>
    create: XOR<SiteCreateWithoutContentInput, SiteUncheckedCreateWithoutContentInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutContentInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutContentInput, SiteUncheckedUpdateWithoutContentInput>
  }

  export type SiteUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteMediaCreateWithoutMediaAssetInput = {
    content: ContentCreateNestedOneWithoutMediaInput
    site: SiteCreateNestedOneWithoutMediaInput
  }

  export type SiteMediaUncheckedCreateWithoutMediaAssetInput = {
    siteId: string
    contentId: string
  }

  export type SiteMediaCreateOrConnectWithoutMediaAssetInput = {
    where: SiteMediaWhereUniqueInput
    create: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput>
  }

  export type SiteMediaCreateManyMediaAssetInputEnvelope = {
    data: SiteMediaCreateManyMediaAssetInput | SiteMediaCreateManyMediaAssetInput[]
    skipDuplicates?: boolean
  }

  export type SiteMediaUpsertWithWhereUniqueWithoutMediaAssetInput = {
    where: SiteMediaWhereUniqueInput
    update: XOR<SiteMediaUpdateWithoutMediaAssetInput, SiteMediaUncheckedUpdateWithoutMediaAssetInput>
    create: XOR<SiteMediaCreateWithoutMediaAssetInput, SiteMediaUncheckedCreateWithoutMediaAssetInput>
  }

  export type SiteMediaUpdateWithWhereUniqueWithoutMediaAssetInput = {
    where: SiteMediaWhereUniqueInput
    data: XOR<SiteMediaUpdateWithoutMediaAssetInput, SiteMediaUncheckedUpdateWithoutMediaAssetInput>
  }

  export type SiteMediaUpdateManyWithWhereWithoutMediaAssetInput = {
    where: SiteMediaScalarWhereInput
    data: XOR<SiteMediaUpdateManyMutationInput, SiteMediaUncheckedUpdateManyWithoutMediaAssetInput>
  }

  export type ContentCreateWithoutMediaInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    versions?: ContentVersionCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutMediaInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    versions?: ContentVersionUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutMediaInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
  }

  export type MediaAssetCreateWithoutSiteMediaInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MediaAssetUncheckedCreateWithoutSiteMediaInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MediaAssetCreateOrConnectWithoutSiteMediaInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutSiteMediaInput, MediaAssetUncheckedCreateWithoutSiteMediaInput>
  }

  export type SiteCreateWithoutMediaInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutMediaInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutMediaInput, SiteUncheckedCreateWithoutMediaInput>
  }

  export type ContentUpsertWithoutMediaInput = {
    update: XOR<ContentUpdateWithoutMediaInput, ContentUncheckedUpdateWithoutMediaInput>
    create: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutMediaInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutMediaInput, ContentUncheckedUpdateWithoutMediaInput>
  }

  export type ContentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type MediaAssetUpsertWithoutSiteMediaInput = {
    update: XOR<MediaAssetUpdateWithoutSiteMediaInput, MediaAssetUncheckedUpdateWithoutSiteMediaInput>
    create: XOR<MediaAssetCreateWithoutSiteMediaInput, MediaAssetUncheckedCreateWithoutSiteMediaInput>
    where?: MediaAssetWhereInput
  }

  export type MediaAssetUpdateToOneWithWhereWithoutSiteMediaInput = {
    where?: MediaAssetWhereInput
    data: XOR<MediaAssetUpdateWithoutSiteMediaInput, MediaAssetUncheckedUpdateWithoutSiteMediaInput>
  }

  export type MediaAssetUpdateWithoutSiteMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaAssetUncheckedUpdateWithoutSiteMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteUpsertWithoutMediaInput = {
    update: XOR<SiteUpdateWithoutMediaInput, SiteUncheckedUpdateWithoutMediaInput>
    create: XOR<SiteCreateWithoutMediaInput, SiteUncheckedCreateWithoutMediaInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutMediaInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutMediaInput, SiteUncheckedUpdateWithoutMediaInput>
  }

  export type SiteUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type AffiliateLinkCreateWithoutProductInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    merchant?: MerchantCreateNestedOneWithoutAffiliateLinksInput
    site: SiteCreateNestedOneWithoutAffiliateLinksInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutProductInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput>
  }

  export type AffiliateLinkCreateManyProductInputEnvelope = {
    data: AffiliateLinkCreateManyProductInput | AffiliateLinkCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCustomFieldCreateWithoutProductInput = {
    id?: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutCustomFieldsInput
  }

  export type ProductCustomFieldUncheckedCreateWithoutProductInput = {
    id?: string
    siteId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCustomFieldCreateOrConnectWithoutProductInput = {
    where: ProductCustomFieldWhereUniqueInput
    create: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput>
  }

  export type ProductCustomFieldCreateManyProductInputEnvelope = {
    data: ProductCustomFieldCreateManyProductInput | ProductCustomFieldCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductPriceHistoryCreateWithoutProductInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
  }

  export type ProductPriceHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
  }

  export type ProductPriceHistoryCreateOrConnectWithoutProductInput = {
    where: ProductPriceHistoryWhereUniqueInput
    create: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductPriceHistoryCreateManyProductInputEnvelope = {
    data: ProductPriceHistoryCreateManyProductInput | ProductPriceHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SiteProductCreateWithoutProductInput = {
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    site: SiteCreateNestedOneWithoutProductsInput
  }

  export type SiteProductUncheckedCreateWithoutProductInput = {
    siteId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type SiteProductCreateOrConnectWithoutProductInput = {
    where: SiteProductWhereUniqueInput
    create: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput>
  }

  export type SiteProductCreateManyProductInputEnvelope = {
    data: SiteProductCreateManyProductInput | SiteProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateLinkUpsertWithWhereUniqueWithoutProductInput = {
    where: AffiliateLinkWhereUniqueInput
    update: XOR<AffiliateLinkUpdateWithoutProductInput, AffiliateLinkUncheckedUpdateWithoutProductInput>
    create: XOR<AffiliateLinkCreateWithoutProductInput, AffiliateLinkUncheckedCreateWithoutProductInput>
  }

  export type AffiliateLinkUpdateWithWhereUniqueWithoutProductInput = {
    where: AffiliateLinkWhereUniqueInput
    data: XOR<AffiliateLinkUpdateWithoutProductInput, AffiliateLinkUncheckedUpdateWithoutProductInput>
  }

  export type AffiliateLinkUpdateManyWithWhereWithoutProductInput = {
    where: AffiliateLinkScalarWhereInput
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCustomFieldUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCustomFieldWhereUniqueInput
    update: XOR<ProductCustomFieldUpdateWithoutProductInput, ProductCustomFieldUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCustomFieldCreateWithoutProductInput, ProductCustomFieldUncheckedCreateWithoutProductInput>
  }

  export type ProductCustomFieldUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCustomFieldWhereUniqueInput
    data: XOR<ProductCustomFieldUpdateWithoutProductInput, ProductCustomFieldUncheckedUpdateWithoutProductInput>
  }

  export type ProductCustomFieldUpdateManyWithWhereWithoutProductInput = {
    where: ProductCustomFieldScalarWhereInput
    data: XOR<ProductCustomFieldUpdateManyMutationInput, ProductCustomFieldUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductPriceHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductPriceHistoryWhereUniqueInput
    update: XOR<ProductPriceHistoryUpdateWithoutProductInput, ProductPriceHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPriceHistoryCreateWithoutProductInput, ProductPriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductPriceHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductPriceHistoryWhereUniqueInput
    data: XOR<ProductPriceHistoryUpdateWithoutProductInput, ProductPriceHistoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductPriceHistoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductPriceHistoryScalarWhereInput
    data: XOR<ProductPriceHistoryUpdateManyMutationInput, ProductPriceHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductPriceHistoryScalarWhereInput = {
    AND?: ProductPriceHistoryScalarWhereInput | ProductPriceHistoryScalarWhereInput[]
    OR?: ProductPriceHistoryScalarWhereInput[]
    NOT?: ProductPriceHistoryScalarWhereInput | ProductPriceHistoryScalarWhereInput[]
    id?: UuidFilter<"ProductPriceHistory"> | string
    productId?: UuidFilter<"ProductPriceHistory"> | string
    price?: DecimalFilter<"ProductPriceHistory"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ProductPriceHistory"> | string
    source?: StringFilter<"ProductPriceHistory"> | string
    recordedAt?: DateTimeNullableFilter<"ProductPriceHistory"> | Date | string | null
  }

  export type SiteProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SiteProductWhereUniqueInput
    update: XOR<SiteProductUpdateWithoutProductInput, SiteProductUncheckedUpdateWithoutProductInput>
    create: XOR<SiteProductCreateWithoutProductInput, SiteProductUncheckedCreateWithoutProductInput>
  }

  export type SiteProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SiteProductWhereUniqueInput
    data: XOR<SiteProductUpdateWithoutProductInput, SiteProductUncheckedUpdateWithoutProductInput>
  }

  export type SiteProductUpdateManyWithWhereWithoutProductInput = {
    where: SiteProductScalarWhereInput
    data: XOR<SiteProductUpdateManyMutationInput, SiteProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    site: SiteCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutSiteProductsInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSiteProductsInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSiteProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSiteProductsInput, ProductUncheckedCreateWithoutSiteProductsInput>
  }

  export type SiteCreateWithoutProductsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutProductsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutProductsInput, SiteUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    site?: SiteUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ProductUpsertWithoutSiteProductsInput = {
    update: XOR<ProductUpdateWithoutSiteProductsInput, ProductUncheckedUpdateWithoutSiteProductsInput>
    create: XOR<ProductCreateWithoutSiteProductsInput, ProductUncheckedCreateWithoutSiteProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSiteProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSiteProductsInput, ProductUncheckedUpdateWithoutSiteProductsInput>
  }

  export type ProductUpdateWithoutSiteProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSiteProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SiteUpsertWithoutProductsInput = {
    update: XOR<SiteUpdateWithoutProductsInput, SiteUncheckedUpdateWithoutProductsInput>
    create: XOR<SiteCreateWithoutProductsInput, SiteUncheckedCreateWithoutProductsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutProductsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutProductsInput, SiteUncheckedUpdateWithoutProductsInput>
  }

  export type SiteUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ProductCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryUncheckedCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomFieldsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomFieldsInput, ProductUncheckedCreateWithoutCustomFieldsInput>
  }

  export type SiteCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutCustomFieldsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutCustomFieldsInput, SiteUncheckedCreateWithoutCustomFieldsInput>
  }

  export type ProductUpsertWithoutCustomFieldsInput = {
    update: XOR<ProductUpdateWithoutCustomFieldsInput, ProductUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<ProductCreateWithoutCustomFieldsInput, ProductUncheckedCreateWithoutCustomFieldsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCustomFieldsInput, ProductUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type ProductUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SiteUpsertWithoutCustomFieldsInput = {
    update: XOR<SiteUpdateWithoutCustomFieldsInput, SiteUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<SiteCreateWithoutCustomFieldsInput, SiteUncheckedCreateWithoutCustomFieldsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutCustomFieldsInput, SiteUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type SiteUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ProductCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutProductInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
  }

  export type ProductUpsertWithoutPriceHistoryInput = {
    update: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type ProductUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutProductNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SiteCreateWithoutPriceAlertsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutPriceAlertsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutPriceAlertsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutPriceAlertsInput, SiteUncheckedCreateWithoutPriceAlertsInput>
  }

  export type SiteUpsertWithoutPriceAlertsInput = {
    update: XOR<SiteUpdateWithoutPriceAlertsInput, SiteUncheckedUpdateWithoutPriceAlertsInput>
    create: XOR<SiteCreateWithoutPriceAlertsInput, SiteUncheckedCreateWithoutPriceAlertsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutPriceAlertsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutPriceAlertsInput, SiteUncheckedUpdateWithoutPriceAlertsInput>
  }

  export type SiteUpdateWithoutPriceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutPriceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutQuizzesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutQuizzesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutQuizzesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutQuizzesInput, SiteUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    options?: QuizQuestionOptionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: QuizQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizResultCreateWithoutQuizInput = {
    id?: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    quizAnswers?: QuizAnswerCreateNestedManyWithoutResultInput
  }

  export type QuizResultUncheckedCreateWithoutQuizInput = {
    id?: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutResultInput
  }

  export type QuizResultCreateOrConnectWithoutQuizInput = {
    where: QuizResultWhereUniqueInput
    create: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput>
  }

  export type QuizResultCreateManyQuizInputEnvelope = {
    data: QuizResultCreateManyQuizInput | QuizResultCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type SiteUpsertWithoutQuizzesInput = {
    update: XOR<SiteUpdateWithoutQuizzesInput, SiteUncheckedUpdateWithoutQuizzesInput>
    create: XOR<SiteCreateWithoutQuizzesInput, SiteUncheckedCreateWithoutQuizzesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutQuizzesInput, SiteUncheckedUpdateWithoutQuizzesInput>
  }

  export type SiteUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: UuidFilter<"QuizQuestion"> | string
    quizId?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    questionType?: StringFilter<"QuizQuestion"> | string
    order?: IntFilter<"QuizQuestion"> | number
    isRequired?: BoolFilter<"QuizQuestion"> | boolean
    createdAt?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
  }

  export type QuizResultUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizResultWhereUniqueInput
    update: XOR<QuizResultUpdateWithoutQuizInput, QuizResultUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizResultCreateWithoutQuizInput, QuizResultUncheckedCreateWithoutQuizInput>
  }

  export type QuizResultUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizResultWhereUniqueInput
    data: XOR<QuizResultUpdateWithoutQuizInput, QuizResultUncheckedUpdateWithoutQuizInput>
  }

  export type QuizResultUpdateManyWithWhereWithoutQuizInput = {
    where: QuizResultScalarWhereInput
    data: XOR<QuizResultUpdateManyMutationInput, QuizResultUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizResultScalarWhereInput = {
    AND?: QuizResultScalarWhereInput | QuizResultScalarWhereInput[]
    OR?: QuizResultScalarWhereInput[]
    NOT?: QuizResultScalarWhereInput | QuizResultScalarWhereInput[]
    id?: UuidFilter<"QuizResult"> | string
    quizId?: UuidFilter<"QuizResult"> | string
    sessionId?: StringFilter<"QuizResult"> | string
    answers?: JsonFilter<"QuizResult">
    recommendations?: JsonNullableFilter<"QuizResult">
    completedAt?: DateTimeNullableFilter<"QuizResult"> | Date | string | null
  }

  export type QuizAnswerCreateWithoutQuestionInput = {
    id?: string
    answer: string
    createdAt?: Date | string | null
    result: QuizResultCreateNestedOneWithoutQuizAnswersInput
  }

  export type QuizAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    resultId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuizAnswerCreateManyQuestionInputEnvelope = {
    data: QuizAnswerCreateManyQuestionInput | QuizAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionOptionCreateWithoutQuestionInput = {
    id?: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
  }

  export type QuizQuestionOptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
  }

  export type QuizQuestionOptionCreateOrConnectWithoutQuestionInput = {
    where: QuizQuestionOptionWhereUniqueInput
    create: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizQuestionOptionCreateManyQuestionInputEnvelope = {
    data: QuizQuestionOptionCreateManyQuestionInput | QuizQuestionOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type InteractiveQuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutQuizzesInput
    results?: QuizResultCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    siteId: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    results?: QuizResultUncheckedCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizCreateOrConnectWithoutQuestionsInput = {
    where: InteractiveQuizWhereUniqueInput
    create: XOR<InteractiveQuizCreateWithoutQuestionsInput, InteractiveQuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutQuestionInput, QuizAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutQuestionInput, QuizAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizAnswerScalarWhereInput = {
    AND?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    OR?: QuizAnswerScalarWhereInput[]
    NOT?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    id?: UuidFilter<"QuizAnswer"> | string
    resultId?: UuidFilter<"QuizAnswer"> | string
    questionId?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    createdAt?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
  }

  export type QuizQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizQuestionOptionWhereUniqueInput
    update: XOR<QuizQuestionOptionUpdateWithoutQuestionInput, QuizQuestionOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizQuestionOptionCreateWithoutQuestionInput, QuizQuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizQuestionOptionWhereUniqueInput
    data: XOR<QuizQuestionOptionUpdateWithoutQuestionInput, QuizQuestionOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizQuestionOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizQuestionOptionScalarWhereInput
    data: XOR<QuizQuestionOptionUpdateManyMutationInput, QuizQuestionOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizQuestionOptionScalarWhereInput = {
    AND?: QuizQuestionOptionScalarWhereInput | QuizQuestionOptionScalarWhereInput[]
    OR?: QuizQuestionOptionScalarWhereInput[]
    NOT?: QuizQuestionOptionScalarWhereInput | QuizQuestionOptionScalarWhereInput[]
    id?: UuidFilter<"QuizQuestionOption"> | string
    questionId?: UuidFilter<"QuizQuestionOption"> | string
    optionText?: StringFilter<"QuizQuestionOption"> | string
    optionValue?: StringFilter<"QuizQuestionOption"> | string
    order?: IntFilter<"QuizQuestionOption"> | number
    createdAt?: DateTimeNullableFilter<"QuizQuestionOption"> | Date | string | null
  }

  export type InteractiveQuizUpsertWithoutQuestionsInput = {
    update: XOR<InteractiveQuizUpdateWithoutQuestionsInput, InteractiveQuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<InteractiveQuizCreateWithoutQuestionsInput, InteractiveQuizUncheckedCreateWithoutQuestionsInput>
    where?: InteractiveQuizWhereInput
  }

  export type InteractiveQuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: InteractiveQuizWhereInput
    data: XOR<InteractiveQuizUpdateWithoutQuestionsInput, InteractiveQuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type InteractiveQuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutQuizzesNestedInput
    results?: QuizResultUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    results?: QuizResultUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizQuestionCreateWithoutOptionsInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    quiz: InteractiveQuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    quizId: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutOptionsInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuizQuestionUpsertWithoutOptionsInput = {
    update: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuizQuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    quiz?: InteractiveQuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizAnswerCreateWithoutResultInput = {
    id?: string
    answer: string
    createdAt?: Date | string | null
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateWithoutResultInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizAnswerCreateOrConnectWithoutResultInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput>
  }

  export type QuizAnswerCreateManyResultInputEnvelope = {
    data: QuizAnswerCreateManyResultInput | QuizAnswerCreateManyResultInput[]
    skipDuplicates?: boolean
  }

  export type InteractiveQuizCreateWithoutResultsInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    site: SiteCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizUncheckedCreateWithoutResultsInput = {
    id?: string
    siteId: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type InteractiveQuizCreateOrConnectWithoutResultsInput = {
    where: InteractiveQuizWhereUniqueInput
    create: XOR<InteractiveQuizCreateWithoutResultsInput, InteractiveQuizUncheckedCreateWithoutResultsInput>
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutResultInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutResultInput, QuizAnswerUncheckedUpdateWithoutResultInput>
    create: XOR<QuizAnswerCreateWithoutResultInput, QuizAnswerUncheckedCreateWithoutResultInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutResultInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutResultInput, QuizAnswerUncheckedUpdateWithoutResultInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutResultInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutResultInput>
  }

  export type InteractiveQuizUpsertWithoutResultsInput = {
    update: XOR<InteractiveQuizUpdateWithoutResultsInput, InteractiveQuizUncheckedUpdateWithoutResultsInput>
    create: XOR<InteractiveQuizCreateWithoutResultsInput, InteractiveQuizUncheckedCreateWithoutResultsInput>
    where?: InteractiveQuizWhereInput
  }

  export type InteractiveQuizUpdateToOneWithWhereWithoutResultsInput = {
    where?: InteractiveQuizWhereInput
    data: XOR<InteractiveQuizUpdateWithoutResultsInput, InteractiveQuizUncheckedUpdateWithoutResultsInput>
  }

  export type InteractiveQuizUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizQuestionCreateWithoutAnswersInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    options?: QuizQuestionOptionCreateNestedManyWithoutQuestionInput
    quiz: InteractiveQuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    quizId: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
    options?: QuizQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuizResultCreateWithoutQuizAnswersInput = {
    id?: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    quiz: InteractiveQuizCreateNestedOneWithoutResultsInput
  }

  export type QuizResultUncheckedCreateWithoutQuizAnswersInput = {
    id?: string
    quizId: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
  }

  export type QuizResultCreateOrConnectWithoutQuizAnswersInput = {
    where: QuizResultWhereUniqueInput
    create: XOR<QuizResultCreateWithoutQuizAnswersInput, QuizResultUncheckedCreateWithoutQuizAnswersInput>
  }

  export type QuizQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    options?: QuizQuestionOptionUpdateManyWithoutQuestionNestedInput
    quiz?: InteractiveQuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    options?: QuizQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizResultUpsertWithoutQuizAnswersInput = {
    update: XOR<QuizResultUpdateWithoutQuizAnswersInput, QuizResultUncheckedUpdateWithoutQuizAnswersInput>
    create: XOR<QuizResultCreateWithoutQuizAnswersInput, QuizResultUncheckedCreateWithoutQuizAnswersInput>
    where?: QuizResultWhereInput
  }

  export type QuizResultUpdateToOneWithWhereWithoutQuizAnswersInput = {
    where?: QuizResultWhereInput
    data: XOR<QuizResultUpdateWithoutQuizAnswersInput, QuizResultUncheckedUpdateWithoutQuizAnswersInput>
  }

  export type QuizResultUpdateWithoutQuizAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: InteractiveQuizUpdateOneRequiredWithoutResultsNestedInput
  }

  export type QuizResultUncheckedUpdateWithoutQuizAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MerchantUncheckedCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MerchantCreateOrConnectWithoutAffiliateLinksInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutAffiliateLinksInput, MerchantUncheckedCreateWithoutAffiliateLinksInput>
  }

  export type ProductCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customFields?: ProductCustomFieldCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    description?: string | null
    manufacturer?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    mainImageUrl?: string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: ProductPriceHistoryUncheckedCreateNestedManyWithoutProductInput
    siteProducts?: SiteProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAffiliateLinksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAffiliateLinksInput, ProductUncheckedCreateWithoutAffiliateLinksInput>
  }

  export type SiteCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutAffiliateLinksInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAffiliateLinksInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAffiliateLinksInput, SiteUncheckedCreateWithoutAffiliateLinksInput>
  }

  export type ConversionCreateWithoutAffiliateLinkInput = {
    id?: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type ConversionUncheckedCreateWithoutAffiliateLinkInput = {
    id?: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type ConversionCreateOrConnectWithoutAffiliateLinkInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput>
  }

  export type ConversionCreateManyAffiliateLinkInputEnvelope = {
    data: ConversionCreateManyAffiliateLinkInput | ConversionCreateManyAffiliateLinkInput[]
    skipDuplicates?: boolean
  }

  export type LinkClickCreateWithoutAffiliateLinkInput = {
    id?: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUncheckedCreateWithoutAffiliateLinkInput = {
    id?: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickCreateOrConnectWithoutAffiliateLinkInput = {
    where: LinkClickWhereUniqueInput
    create: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput>
  }

  export type LinkClickCreateManyAffiliateLinkInputEnvelope = {
    data: LinkClickCreateManyAffiliateLinkInput | LinkClickCreateManyAffiliateLinkInput[]
    skipDuplicates?: boolean
  }

  export type MerchantUpsertWithoutAffiliateLinksInput = {
    update: XOR<MerchantUpdateWithoutAffiliateLinksInput, MerchantUncheckedUpdateWithoutAffiliateLinksInput>
    create: XOR<MerchantCreateWithoutAffiliateLinksInput, MerchantUncheckedCreateWithoutAffiliateLinksInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutAffiliateLinksInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutAffiliateLinksInput, MerchantUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type MerchantUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantUncheckedUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpsertWithoutAffiliateLinksInput = {
    update: XOR<ProductUpdateWithoutAffiliateLinksInput, ProductUncheckedUpdateWithoutAffiliateLinksInput>
    create: XOR<ProductCreateWithoutAffiliateLinksInput, ProductUncheckedCreateWithoutAffiliateLinksInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAffiliateLinksInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAffiliateLinksInput, ProductUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type ProductUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customFields?: ProductCustomFieldUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: ProductPriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    siteProducts?: SiteProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SiteUpsertWithoutAffiliateLinksInput = {
    update: XOR<SiteUpdateWithoutAffiliateLinksInput, SiteUncheckedUpdateWithoutAffiliateLinksInput>
    create: XOR<SiteCreateWithoutAffiliateLinksInput, SiteUncheckedCreateWithoutAffiliateLinksInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutAffiliateLinksInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutAffiliateLinksInput, SiteUncheckedUpdateWithoutAffiliateLinksInput>
  }

  export type SiteUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutAffiliateLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ConversionUpsertWithWhereUniqueWithoutAffiliateLinkInput = {
    where: ConversionWhereUniqueInput
    update: XOR<ConversionUpdateWithoutAffiliateLinkInput, ConversionUncheckedUpdateWithoutAffiliateLinkInput>
    create: XOR<ConversionCreateWithoutAffiliateLinkInput, ConversionUncheckedCreateWithoutAffiliateLinkInput>
  }

  export type ConversionUpdateWithWhereUniqueWithoutAffiliateLinkInput = {
    where: ConversionWhereUniqueInput
    data: XOR<ConversionUpdateWithoutAffiliateLinkInput, ConversionUncheckedUpdateWithoutAffiliateLinkInput>
  }

  export type ConversionUpdateManyWithWhereWithoutAffiliateLinkInput = {
    where: ConversionScalarWhereInput
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyWithoutAffiliateLinkInput>
  }

  export type ConversionScalarWhereInput = {
    AND?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    OR?: ConversionScalarWhereInput[]
    NOT?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    id?: UuidFilter<"Conversion"> | string
    affiliateLinkId?: UuidFilter<"Conversion"> | string
    orderId?: StringNullableFilter<"Conversion"> | string | null
    orderValue?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"Conversion"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Conversion"> | string
    conversionDate?: DateTimeNullableFilter<"Conversion"> | Date | string | null
    status?: StringFilter<"Conversion"> | string
    notes?: StringNullableFilter<"Conversion"> | string | null
  }

  export type LinkClickUpsertWithWhereUniqueWithoutAffiliateLinkInput = {
    where: LinkClickWhereUniqueInput
    update: XOR<LinkClickUpdateWithoutAffiliateLinkInput, LinkClickUncheckedUpdateWithoutAffiliateLinkInput>
    create: XOR<LinkClickCreateWithoutAffiliateLinkInput, LinkClickUncheckedCreateWithoutAffiliateLinkInput>
  }

  export type LinkClickUpdateWithWhereUniqueWithoutAffiliateLinkInput = {
    where: LinkClickWhereUniqueInput
    data: XOR<LinkClickUpdateWithoutAffiliateLinkInput, LinkClickUncheckedUpdateWithoutAffiliateLinkInput>
  }

  export type LinkClickUpdateManyWithWhereWithoutAffiliateLinkInput = {
    where: LinkClickScalarWhereInput
    data: XOR<LinkClickUpdateManyMutationInput, LinkClickUncheckedUpdateManyWithoutAffiliateLinkInput>
  }

  export type LinkClickScalarWhereInput = {
    AND?: LinkClickScalarWhereInput | LinkClickScalarWhereInput[]
    OR?: LinkClickScalarWhereInput[]
    NOT?: LinkClickScalarWhereInput | LinkClickScalarWhereInput[]
    id?: UuidFilter<"LinkClick"> | string
    affiliateLinkId?: UuidFilter<"LinkClick"> | string
    ipAddress?: StringNullableFilter<"LinkClick"> | string | null
    userAgent?: StringNullableFilter<"LinkClick"> | string | null
    referrer?: StringNullableFilter<"LinkClick"> | string | null
    clickedAt?: DateTimeNullableFilter<"LinkClick"> | Date | string | null
    conversionStatus?: StringNullableFilter<"LinkClick"> | string | null
    conversionValue?: DecimalNullableFilter<"LinkClick"> | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkCreateWithoutMerchantInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    product?: ProductCreateNestedOneWithoutAffiliateLinksInput
    site: SiteCreateNestedOneWithoutAffiliateLinksInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutMerchantInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput
    linkClicks?: LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutMerchantInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput>
  }

  export type AffiliateLinkCreateManyMerchantInputEnvelope = {
    data: AffiliateLinkCreateManyMerchantInput | AffiliateLinkCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateLinkUpsertWithWhereUniqueWithoutMerchantInput = {
    where: AffiliateLinkWhereUniqueInput
    update: XOR<AffiliateLinkUpdateWithoutMerchantInput, AffiliateLinkUncheckedUpdateWithoutMerchantInput>
    create: XOR<AffiliateLinkCreateWithoutMerchantInput, AffiliateLinkUncheckedCreateWithoutMerchantInput>
  }

  export type AffiliateLinkUpdateWithWhereUniqueWithoutMerchantInput = {
    where: AffiliateLinkWhereUniqueInput
    data: XOR<AffiliateLinkUpdateWithoutMerchantInput, AffiliateLinkUncheckedUpdateWithoutMerchantInput>
  }

  export type AffiliateLinkUpdateManyWithWhereWithoutMerchantInput = {
    where: AffiliateLinkScalarWhereInput
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyWithoutMerchantInput>
  }

  export type AffiliateLinkCreateWithoutLinkClicksInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    merchant?: MerchantCreateNestedOneWithoutAffiliateLinksInput
    product?: ProductCreateNestedOneWithoutAffiliateLinksInput
    site: SiteCreateNestedOneWithoutAffiliateLinksInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutLinkClicksInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutLinkClicksInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutLinkClicksInput, AffiliateLinkUncheckedCreateWithoutLinkClicksInput>
  }

  export type AffiliateLinkUpsertWithoutLinkClicksInput = {
    update: XOR<AffiliateLinkUpdateWithoutLinkClicksInput, AffiliateLinkUncheckedUpdateWithoutLinkClicksInput>
    create: XOR<AffiliateLinkCreateWithoutLinkClicksInput, AffiliateLinkUncheckedCreateWithoutLinkClicksInput>
    where?: AffiliateLinkWhereInput
  }

  export type AffiliateLinkUpdateToOneWithWhereWithoutLinkClicksInput = {
    where?: AffiliateLinkWhereInput
    data: XOR<AffiliateLinkUpdateWithoutLinkClicksInput, AffiliateLinkUncheckedUpdateWithoutLinkClicksInput>
  }

  export type AffiliateLinkUpdateWithoutLinkClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneWithoutAffiliateLinksNestedInput
    product?: ProductUpdateOneWithoutAffiliateLinksNestedInput
    site?: SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutLinkClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkCreateWithoutConversionsInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    merchant?: MerchantCreateNestedOneWithoutAffiliateLinksInput
    product?: ProductCreateNestedOneWithoutAffiliateLinksInput
    site: SiteCreateNestedOneWithoutAffiliateLinksInput
    linkClicks?: LinkClickCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutConversionsInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
    linkClicks?: LinkClickUncheckedCreateNestedManyWithoutAffiliateLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutConversionsInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutConversionsInput, AffiliateLinkUncheckedCreateWithoutConversionsInput>
  }

  export type AffiliateLinkUpsertWithoutConversionsInput = {
    update: XOR<AffiliateLinkUpdateWithoutConversionsInput, AffiliateLinkUncheckedUpdateWithoutConversionsInput>
    create: XOR<AffiliateLinkCreateWithoutConversionsInput, AffiliateLinkUncheckedCreateWithoutConversionsInput>
    where?: AffiliateLinkWhereInput
  }

  export type AffiliateLinkUpdateToOneWithWhereWithoutConversionsInput = {
    where?: AffiliateLinkWhereInput
    data: XOR<AffiliateLinkUpdateWithoutConversionsInput, AffiliateLinkUncheckedUpdateWithoutConversionsInput>
  }

  export type AffiliateLinkUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneWithoutAffiliateLinksNestedInput
    product?: ProductUpdateOneWithoutAffiliateLinksNestedInput
    site?: SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput
    linkClicks?: LinkClickUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkClicks?: LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type UserRoleCreateWithoutRoleInput = {
    userId: string
    siteId?: string | null
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
    siteId?: string | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    siteId?: UuidNullableFilter<"UserRole"> | string | null
  }

  export type RoleCreateWithoutUserRolesInput = {
    name: string
    description?: string | null
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientCreateWithoutRecipeInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
  }

  export type RecipeIngredientUncheckedCreateWithoutRecipeInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
  }

  export type RecipeIngredientCreateOrConnectWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateManyRecipeInputEnvelope = {
    data: RecipeIngredientCreateManyRecipeInput | RecipeIngredientCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type RecipeInstructionCreateWithoutRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
  }

  export type RecipeInstructionUncheckedCreateWithoutRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
  }

  export type RecipeInstructionCreateOrConnectWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    create: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInstructionCreateManyRecipeInputEnvelope = {
    data: RecipeInstructionCreateManyRecipeInput | RecipeInstructionCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeIngredientScalarWhereInput = {
    AND?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    OR?: RecipeIngredientScalarWhereInput[]
    NOT?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    id?: UuidFilter<"RecipeIngredient"> | string
    recipeId?: UuidFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
    order?: IntFilter<"RecipeIngredient"> | number
    createdAt?: DateTimeNullableFilter<"RecipeIngredient"> | Date | string | null
  }

  export type RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    update: XOR<RecipeInstructionUpdateWithoutRecipeInput, RecipeInstructionUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    data: XOR<RecipeInstructionUpdateWithoutRecipeInput, RecipeInstructionUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeInstructionUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeInstructionScalarWhereInput
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeInstructionScalarWhereInput = {
    AND?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
    OR?: RecipeInstructionScalarWhereInput[]
    NOT?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
    id?: UuidFilter<"RecipeInstruction"> | string
    recipeId?: UuidFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
    imageUrl?: StringNullableFilter<"RecipeInstruction"> | string | null
    createdAt?: DateTimeNullableFilter<"RecipeInstruction"> | Date | string | null
  }

  export type RecipeCreateWithoutIngredientsInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutIngredientsInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutIngredientsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
  }

  export type RecipeUpsertWithoutIngredientsInput = {
    update: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutInstructionsInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutInstructionsInput = {
    id?: string
    title: string
    description?: string | null
    prepTime?: number | null
    cookTime?: number | null
    servings?: number | null
    difficulty?: string | null
    cuisine?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutInstructionsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
  }

  export type RecipeUpsertWithoutInstructionsInput = {
    update: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutInstructionsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type RecipeUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    cookTime?: NullableIntFieldUpdateOperationsInput | number | null
    servings?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type ContentCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    contentType: ContentTypeCreateNestedOneWithoutContentInput
    categories?: ContentCategoryCreateNestedManyWithoutContentInput
    tags?: ContentTagCreateNestedManyWithoutContentInput
    siteContent?: SiteContentCreateNestedManyWithoutContentInput
    media?: SiteMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    contentTypeId: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
    categories?: ContentCategoryUncheckedCreateNestedManyWithoutContentInput
    tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    siteContent?: SiteContentUncheckedCreateNestedManyWithoutContentInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutVersionsInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutVersionsInput, ContentUncheckedCreateWithoutVersionsInput>
  }

  export type ContentUpsertWithoutVersionsInput = {
    update: XOR<ContentUpdateWithoutVersionsInput, ContentUncheckedUpdateWithoutVersionsInput>
    create: XOR<ContentCreateWithoutVersionsInput, ContentUncheckedCreateWithoutVersionsInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutVersionsInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutVersionsInput, ContentUncheckedUpdateWithoutVersionsInput>
  }

  export type ContentUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentType?: ContentTypeUpdateOneRequiredWithoutContentNestedInput
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contentTypeId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type SiteCreateWithoutCustomNicheInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutCustomNicheInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutCustomNicheInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput>
  }

  export type SiteCreateManyCustomNicheInputEnvelope = {
    data: SiteCreateManyCustomNicheInput | SiteCreateManyCustomNicheInput[]
    skipDuplicates?: boolean
  }

  export type SiteUpsertWithWhereUniqueWithoutCustomNicheInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutCustomNicheInput, SiteUncheckedUpdateWithoutCustomNicheInput>
    create: XOR<SiteCreateWithoutCustomNicheInput, SiteUncheckedCreateWithoutCustomNicheInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutCustomNicheInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutCustomNicheInput, SiteUncheckedUpdateWithoutCustomNicheInput>
  }

  export type SiteUpdateManyWithWhereWithoutCustomNicheInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutCustomNicheInput>
  }

  export type SiteScalarWhereInput = {
    AND?: SiteScalarWhereInput | SiteScalarWhereInput[]
    OR?: SiteScalarWhereInput[]
    NOT?: SiteScalarWhereInput | SiteScalarWhereInput[]
    id?: UuidFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    domain?: StringFilter<"Site"> | string
    logoUrl?: StringNullableFilter<"Site"> | string | null
    primaryColor?: StringNullableFilter<"Site"> | string | null
    secondaryColor?: StringNullableFilter<"Site"> | string | null
    nicheType?: StringFilter<"Site"> | string
    customNicheId?: UuidNullableFilter<"Site"> | string | null
    nicheKeywords?: JsonNullableFilter<"Site">
    targetAudience?: StringNullableFilter<"Site"> | string | null
    siteTitle?: StringNullableFilter<"Site"> | string | null
    siteDescription?: StringNullableFilter<"Site"> | string | null
    heroTitle?: StringNullableFilter<"Site"> | string | null
    heroSubtitle?: StringNullableFilter<"Site"> | string | null
    aboutTitle?: StringNullableFilter<"Site"> | string | null
    aboutDescription?: StringNullableFilter<"Site"> | string | null
    contactEmail?: StringNullableFilter<"Site"> | string | null
    metaTitle?: StringNullableFilter<"Site"> | string | null
    metaDescription?: StringNullableFilter<"Site"> | string | null
    metaKeywords?: StringNullableFilter<"Site"> | string | null
    featuredPostsTitle?: StringNullableFilter<"Site"> | string | null
    featuredPostsSubtitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsTitle?: StringNullableFilter<"Site"> | string | null
    featuredProductsSubtitle?: StringNullableFilter<"Site"> | string | null
    newsletterTitle?: StringNullableFilter<"Site"> | string | null
    newsletterSubtitle?: StringNullableFilter<"Site"> | string | null
    autoBlogEnabled?: BoolFilter<"Site"> | boolean
    autoBlogFrequency?: StringNullableFilter<"Site"> | string | null
    autoBlogPostTypes?: JsonNullableFilter<"Site">
    autoBlogCategories?: JsonNullableFilter<"Site">
    footerText?: StringNullableFilter<"Site"> | string | null
    socialLinks?: JsonNullableFilter<"Site">
    createdAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
  }

  export type SiteCreateWithoutAutoBlogPostsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutAutoBlogPostsInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAutoBlogPostsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAutoBlogPostsInput, SiteUncheckedCreateWithoutAutoBlogPostsInput>
  }

  export type SiteUpsertWithoutAutoBlogPostsInput = {
    update: XOR<SiteUpdateWithoutAutoBlogPostsInput, SiteUncheckedUpdateWithoutAutoBlogPostsInput>
    create: XOR<SiteCreateWithoutAutoBlogPostsInput, SiteUncheckedCreateWithoutAutoBlogPostsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutAutoBlogPostsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutAutoBlogPostsInput, SiteUncheckedUpdateWithoutAutoBlogPostsInput>
  }

  export type SiteUpdateWithoutAutoBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutAutoBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutContentSchedulesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutContentSchedulesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutContentSchedulesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutContentSchedulesInput, SiteUncheckedCreateWithoutContentSchedulesInput>
  }

  export type SiteUpsertWithoutContentSchedulesInput = {
    update: XOR<SiteUpdateWithoutContentSchedulesInput, SiteUncheckedUpdateWithoutContentSchedulesInput>
    create: XOR<SiteCreateWithoutContentSchedulesInput, SiteUncheckedCreateWithoutContentSchedulesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutContentSchedulesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutContentSchedulesInput, SiteUncheckedUpdateWithoutContentSchedulesInput>
  }

  export type SiteUpdateWithoutContentSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutContentSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ProductCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    site: SiteCreateNestedOneWithoutProductCategoriesInput
    products?: SiteProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    products?: SiteProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutChildrenInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ProductCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    site: SiteCreateNestedOneWithoutProductCategoriesInput
    products?: SiteProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: SiteProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryCreateManyParentInputEnvelope = {
    data: ProductCategoryCreateManyParentInput | ProductCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type SiteCreateWithoutProductCategoriesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldCreateNestedManyWithoutSiteInput
    content?: SiteContentCreateNestedManyWithoutSiteInput
    media?: SiteMediaCreateNestedManyWithoutSiteInput
    products?: SiteProductCreateNestedManyWithoutSiteInput
    customNiche?: CustomNicheCreateNestedOneWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutProductCategoriesInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    customNicheId?: string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedCreateNestedManyWithoutSiteInput
    autoBlogPosts?: AutoBlogPostUncheckedCreateNestedManyWithoutSiteInput
    contentSchedules?: ContentScheduleUncheckedCreateNestedManyWithoutSiteInput
    quizzes?: InteractiveQuizUncheckedCreateNestedManyWithoutSiteInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutSiteInput
    customFields?: ProductCustomFieldUncheckedCreateNestedManyWithoutSiteInput
    content?: SiteContentUncheckedCreateNestedManyWithoutSiteInput
    media?: SiteMediaUncheckedCreateNestedManyWithoutSiteInput
    products?: SiteProductUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutProductCategoriesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutProductCategoriesInput, SiteUncheckedCreateWithoutProductCategoriesInput>
  }

  export type SiteProductCreateWithoutCategoryInput = {
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutSiteProductsInput
    site: SiteCreateNestedOneWithoutProductsInput
  }

  export type SiteProductUncheckedCreateWithoutCategoryInput = {
    siteId: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SiteProductCreateOrConnectWithoutCategoryInput = {
    where: SiteProductWhereUniqueInput
    create: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput>
  }

  export type SiteProductCreateManyCategoryInputEnvelope = {
    data: SiteProductCreateManyCategoryInput | SiteProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithoutChildrenInput = {
    update: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    site?: SiteUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: SiteProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SiteProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type SiteUpsertWithoutProductCategoriesInput = {
    update: XOR<SiteUpdateWithoutProductCategoriesInput, SiteUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<SiteCreateWithoutProductCategoriesInput, SiteUncheckedCreateWithoutProductCategoriesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutProductCategoriesInput, SiteUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type SiteUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
    customNiche?: CustomNicheUpdateOneWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    customNicheId?: NullableStringFieldUpdateOperationsInput | string | null
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SiteProductWhereUniqueInput
    update: XOR<SiteProductUpdateWithoutCategoryInput, SiteProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<SiteProductCreateWithoutCategoryInput, SiteProductUncheckedCreateWithoutCategoryInput>
  }

  export type SiteProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SiteProductWhereUniqueInput
    data: XOR<SiteProductUpdateWithoutCategoryInput, SiteProductUncheckedUpdateWithoutCategoryInput>
  }

  export type SiteProductUpdateManyWithWhereWithoutCategoryInput = {
    where: SiteProductScalarWhereInput
    data: XOR<SiteProductUpdateManyMutationInput, SiteProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ContentCategoryCreateManyContentInput = {
    categoryId: number
  }

  export type ContentTagCreateManyContentInput = {
    tagId: number
  }

  export type ContentVersionCreateManyContentInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string | null
  }

  export type SiteContentCreateManyContentInput = {
    siteId: string
  }

  export type SiteMediaCreateManyContentInput = {
    siteId: string
    mediaAssetId: string
  }

  export type ContentCategoryUpdateWithoutContentInput = {
    category?: CategoryUpdateOneRequiredWithoutContentNestedInput
  }

  export type ContentCategoryUncheckedUpdateWithoutContentInput = {
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCategoryUncheckedUpdateManyWithoutContentInput = {
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUpdateWithoutContentInput = {
    tag?: TagUpdateOneRequiredWithoutContentNestedInput
  }

  export type ContentTagUncheckedUpdateWithoutContentInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUncheckedUpdateManyWithoutContentInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentVersionUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentVersionUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentVersionUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteContentUpdateWithoutContentInput = {
    site?: SiteUpdateOneRequiredWithoutContentNestedInput
  }

  export type SiteContentUncheckedUpdateWithoutContentInput = {
    siteId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteContentUncheckedUpdateManyWithoutContentInput = {
    siteId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaUpdateWithoutContentInput = {
    mediaAsset?: MediaAssetUpdateOneRequiredWithoutSiteMediaNestedInput
    site?: SiteUpdateOneRequiredWithoutMediaNestedInput
  }

  export type SiteMediaUncheckedUpdateWithoutContentInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaUncheckedUpdateManyWithoutContentInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentCreateManyContentTypeInput = {
    id?: string
    title: string
    slug: string
    data: JsonNullValueInput | InputJsonValue
    status?: string
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    version?: number | null
    scheduledPublishAt?: Date | string | null
  }

  export type ContentUpdateWithoutContentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUpdateManyWithoutContentNestedInput
    tags?: ContentTagUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUpdateManyWithoutContentNestedInput
    media?: SiteMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutContentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: ContentCategoryUncheckedUpdateManyWithoutContentNestedInput
    tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    versions?: ContentVersionUncheckedUpdateManyWithoutContentNestedInput
    siteContent?: SiteContentUncheckedUpdateManyWithoutContentNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutContentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledPublishAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateManyParentInput = {
    id?: number
    name: string
    description?: string | null
    slug: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentCategoryCreateManyCategoryInput = {
    contentId: string
  }

  export type CategoryUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUpdateManyWithoutParentNestedInput
    content?: ContentCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    content?: ContentCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentCategoryUpdateWithoutCategoryInput = {
    content?: ContentUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ContentCategoryUncheckedUpdateWithoutCategoryInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentCategoryUncheckedUpdateManyWithoutCategoryInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentTagCreateManyTagInput = {
    contentId: string
  }

  export type ContentTagUpdateWithoutTagInput = {
    content?: ContentUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ContentTagUncheckedUpdateWithoutTagInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentTagUncheckedUpdateManyWithoutTagInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type AffiliateLinkCreateManySiteInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
  }

  export type AutoBlogPostCreateManySiteInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: string | null
    status?: string
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    postType?: string
    wordCount?: number | null
    readingTime?: number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: string | null
    generationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContentScheduleCreateManySiteInput = {
    id?: string
    name: string
    description?: string | null
    frequency: string
    interval?: number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InteractiveQuizCreateManySiteInput = {
    id?: string
    title: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PriceAlertCreateManySiteInput = {
    id?: string
    productId: string
    alertType: string
    threshold: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string | null
    triggeredAt?: Date | string | null
  }

  export type ProductCategoryCreateManySiteInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    parentId?: string | null
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCustomFieldCreateManySiteInput = {
    id?: string
    productId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SiteContentCreateManySiteInput = {
    contentId: string
  }

  export type SiteMediaCreateManySiteInput = {
    contentId: string
    mediaAssetId: string
  }

  export type SiteProductCreateManySiteInput = {
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type AffiliateLinkUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneWithoutAffiliateLinksNestedInput
    product?: ProductUpdateOneWithoutAffiliateLinksNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoBlogPostUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: NullableJsonNullValueInput | InputJsonValue
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seoData?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    postType?: StringFieldUpdateOperationsInput | string
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    affiliateLinks?: NullableJsonNullValueInput | InputJsonValue
    internalLinks?: NullableJsonNullValueInput | InputJsonValue
    externalLinks?: NullableJsonNullValueInput | InputJsonValue
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentScheduleUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    postTypes?: JsonNullValueInput | InputJsonValue
    categories?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InteractiveQuizUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    results?: QuizResultUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    results?: QuizResultUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type InteractiveQuizUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceAlertUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: SiteProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type ProductCustomFieldUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteContentUpdateWithoutSiteInput = {
    content?: ContentUpdateOneRequiredWithoutSiteContentNestedInput
  }

  export type SiteContentUncheckedUpdateWithoutSiteInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteContentUncheckedUpdateManyWithoutSiteInput = {
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaUpdateWithoutSiteInput = {
    content?: ContentUpdateOneRequiredWithoutMediaNestedInput
    mediaAsset?: MediaAssetUpdateOneRequiredWithoutSiteMediaNestedInput
  }

  export type SiteMediaUncheckedUpdateWithoutSiteInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaUncheckedUpdateManyWithoutSiteInput = {
    contentId?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteProductUpdateWithoutSiteInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSiteProductsNestedInput
  }

  export type SiteProductUncheckedUpdateWithoutSiteInput = {
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteProductUncheckedUpdateManyWithoutSiteInput = {
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteMediaCreateManyMediaAssetInput = {
    siteId: string
    contentId: string
  }

  export type SiteMediaUpdateWithoutMediaAssetInput = {
    content?: ContentUpdateOneRequiredWithoutMediaNestedInput
    site?: SiteUpdateOneRequiredWithoutMediaNestedInput
  }

  export type SiteMediaUncheckedUpdateWithoutMediaAssetInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteMediaUncheckedUpdateManyWithoutMediaAssetInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type AffiliateLinkCreateManyProductInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    merchantId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
  }

  export type ProductCustomFieldCreateManyProductInput = {
    id?: string
    siteId: string
    fieldName: string
    fieldType: string
    fieldValue: string
    displayOrder?: number
    isRequired?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductPriceHistoryCreateManyProductInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    source: string
    recordedAt?: Date | string | null
  }

  export type SiteProductCreateManyProductInput = {
    siteId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    categoryId?: string | null
  }

  export type AffiliateLinkUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneWithoutAffiliateLinksNestedInput
    site?: SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type ProductCustomFieldUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCustomFieldUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldValue?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteProductUpdateWithoutProductInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    site?: SiteUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SiteProductUncheckedUpdateWithoutProductInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteProductUncheckedUpdateManyWithoutProductInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    question: string
    questionType: string
    order: number
    isRequired?: boolean
    createdAt?: Date | string | null
  }

  export type QuizResultCreateManyQuizInput = {
    id?: string
    sessionId: string
    answers: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    options?: QuizQuestionOptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: QuizQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizResultUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAnswers?: QuizAnswerUpdateManyWithoutResultNestedInput
  }

  export type QuizResultUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutResultNestedInput
  }

  export type QuizResultUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateManyQuestionInput = {
    id?: string
    resultId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizQuestionOptionCreateManyQuestionInput = {
    id?: string
    optionText: string
    optionValue: string
    order: number
    createdAt?: Date | string | null
  }

  export type QuizAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: QuizResultUpdateOneRequiredWithoutQuizAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionText?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateManyResultInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string | null
  }

  export type QuizAnswerUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateManyWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversionCreateManyAffiliateLinkInput = {
    id?: string
    orderId?: string | null
    orderValue: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    currency?: string
    conversionDate?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type LinkClickCreateManyAffiliateLinkInput = {
    id?: string
    ipAddress?: string | null
    userAgent?: string | null
    referrer?: string | null
    clickedAt?: Date | string | null
    conversionStatus?: string | null
    conversionValue?: Decimal | DecimalJsLike | number | string | null
  }

  export type ConversionUpdateWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversionUncheckedUpdateWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversionUncheckedUpdateManyWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    conversionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkClickUpdateWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUncheckedUpdateWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LinkClickUncheckedUpdateManyWithoutAffiliateLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    conversionValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AffiliateLinkCreateManyMerchantInput = {
    id?: string
    name: string
    originalUrl: string
    affiliateUrl: string
    siteId: string
    createdBy?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productId?: string | null
    displayText?: string | null
    trackingId?: string | null
    status?: string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: Date | string | null
  }

  export type AffiliateLinkUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutAffiliateLinksNestedInput
    site?: SiteUpdateOneRequiredWithoutAffiliateLinksNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateLinkNestedInput
    linkClicks?: LinkClickUncheckedUpdateManyWithoutAffiliateLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    affiliateUrl?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    commissionInfo?: NullableJsonNullValueInput | InputJsonValue
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
    siteId?: string | null
  }

  export type UserRoleUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientCreateManyRecipeInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    order: number
    createdAt?: Date | string | null
  }

  export type RecipeInstructionCreateManyRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
    imageUrl?: string | null
    createdAt?: Date | string | null
  }

  export type RecipeIngredientUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeIngredientUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeInstructionUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteCreateManyCustomNicheInput = {
    id?: string
    name: string
    domain: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    nicheType?: string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: string | null
    siteTitle?: string | null
    siteDescription?: string | null
    heroTitle?: string | null
    heroSubtitle?: string | null
    aboutTitle?: string | null
    aboutDescription?: string | null
    contactEmail?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    featuredPostsTitle?: string | null
    featuredPostsSubtitle?: string | null
    featuredProductsTitle?: string | null
    featuredProductsSubtitle?: string | null
    newsletterTitle?: string | null
    newsletterSubtitle?: string | null
    autoBlogEnabled?: boolean
    autoBlogFrequency?: string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SiteUpdateWithoutCustomNicheInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUpdateManyWithoutSiteNestedInput
    content?: SiteContentUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUpdateManyWithoutSiteNestedInput
    products?: SiteProductUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutCustomNicheInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateLinks?: AffiliateLinkUncheckedUpdateManyWithoutSiteNestedInput
    autoBlogPosts?: AutoBlogPostUncheckedUpdateManyWithoutSiteNestedInput
    contentSchedules?: ContentScheduleUncheckedUpdateManyWithoutSiteNestedInput
    quizzes?: InteractiveQuizUncheckedUpdateManyWithoutSiteNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutSiteNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSiteNestedInput
    customFields?: ProductCustomFieldUncheckedUpdateManyWithoutSiteNestedInput
    content?: SiteContentUncheckedUpdateManyWithoutSiteNestedInput
    media?: SiteMediaUncheckedUpdateManyWithoutSiteNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutCustomNicheInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    nicheType?: StringFieldUpdateOperationsInput | string
    nicheKeywords?: NullableJsonNullValueInput | InputJsonValue
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    siteTitle?: NullableStringFieldUpdateOperationsInput | string | null
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: NullableStringFieldUpdateOperationsInput | string | null
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    aboutDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredPostsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsTitle?: NullableStringFieldUpdateOperationsInput | string | null
    featuredProductsSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    newsletterSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoBlogFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    autoBlogPostTypes?: NullableJsonNullValueInput | InputJsonValue
    autoBlogCategories?: NullableJsonNullValueInput | InputJsonValue
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryCreateManyParentInput = {
    id?: string
    siteId: string
    name: string
    description?: string | null
    slug: string
    displayOrder?: number
    isActive?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    seoKeywords?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SiteProductCreateManyCategoryInput = {
    siteId: string
    productId: string
    price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    inStock?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    site?: SiteUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: SiteProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: SiteProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seoKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteProductUpdateWithoutCategoryInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutSiteProductsNestedInput
    site?: SiteUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SiteProductUncheckedUpdateWithoutCategoryInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteProductUncheckedUpdateManyWithoutCategoryInput = {
    siteId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}